<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Standard Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded affix "><li class="part-title">How-To Guides</li><li class="chapter-item expanded "><a href="guides/hello-world/index.html"><strong aria-hidden="true">1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="guides/growing-cells.html"><strong aria-hidden="true">2.</strong> Growing Cells</a></li><li class="chapter-item expanded "><a href="guides/incl.html"><strong aria-hidden="true">3.</strong> Include Filter</a></li><li class="chapter-item expanded "><a href="guides/envrc.html"><strong aria-hidden="true">4.</strong> Setup .envrc</a></li><li class="chapter-item expanded affix "><li class="part-title">Explanation</li><li class="chapter-item expanded "><a href="explain/why-nix.html"><strong aria-hidden="true">5.</strong> Why nix?</a></li><li class="chapter-item expanded "><a href="explain/why-std.html"><strong aria-hidden="true">6.</strong> Why std?</a></li><li class="chapter-item expanded "><a href="explain/architecture-decision-records/index.html"><strong aria-hidden="true">7.</strong> Architecture Decisions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explain/architecture-decision-records/0003-drop-as-nix-cli-epiphyte-flag.html"><strong aria-hidden="true">7.1.</strong> 0001 Drop as-nix-cli-epiphyte flag</a></li><li class="chapter-item expanded "><a href="explain/architecture-decision-records/0002-wire-up-documentation-instrumentation.html"><strong aria-hidden="true">7.2.</strong> 0002 Wire Up Documentation Instrumentation</a></li><li class="chapter-item expanded "><a href="explain/architecture-decision-records/0001-increase-repo-discoverability-with-a-tui.html"><strong aria-hidden="true">7.3.</strong> 0003 Increase Repo Discoverability With a Tui</a></li><li class="chapter-item expanded "><a href="explain/architecture-decision-records/0004-add-nixago-instrumentation.html"><strong aria-hidden="true">7.4.</strong> 0004 Add Nixago Instrumentation</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/cli.html"><strong aria-hidden="true">8.</strong> TUI/CLI</a></li><li class="chapter-item expanded "><a href="reference/conventions.html"><strong aria-hidden="true">9.</strong> Conventions</a></li><li class="chapter-item expanded "><a href="reference/clades.html"><strong aria-hidden="true">10.</strong> Builtin Clades</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/clades/data-clade.html"><strong aria-hidden="true">10.1.</strong> Data</a></li><li class="chapter-item expanded "><a href="reference/clades/functions-clade.html"><strong aria-hidden="true">10.2.</strong> Functions</a></li><li class="chapter-item expanded "><a href="reference/clades/runnables-clade.html"><strong aria-hidden="true">10.3.</strong> Runnables</a></li><li class="chapter-item expanded "><a href="reference/clades/installables-clade.html"><strong aria-hidden="true">10.4.</strong> Installables</a></li><li class="chapter-item expanded "><a href="reference/clades/microvms-clade.html"><strong aria-hidden="true">10.5.</strong> Microvms</a></li><li class="chapter-item expanded "><a href="reference/clades/devshells-clade.html"><strong aria-hidden="true">10.6.</strong> Devshells</a></li><li class="chapter-item expanded "><a href="reference/clades/containers-clade.html"><strong aria-hidden="true">10.7.</strong> Containers</a></li><li class="chapter-item expanded "><a href="reference/clades/nixago-clade.html"><strong aria-hidden="true">10.8.</strong> Nixago</a></li></ol></li><li class="chapter-item expanded "><a href="reference/std/index.html"><strong aria-hidden="true">11.</strong> //std</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/std/cli/index.html"><strong aria-hidden="true">11.1.</strong> /cli</a></li><li class="chapter-item expanded "><a href="reference/std/devshellProfiles/index.html"><strong aria-hidden="true">11.2.</strong> /devshellProfiles</a></li><li class="chapter-item expanded "><a href="reference/std/lib/index.html"><strong aria-hidden="true">11.3.</strong> /lib</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/std/lib/fromMakesWith.html"><strong aria-hidden="true">11.3.1.</strong> /fromMakesWith</a></li><li class="chapter-item expanded "><a href="reference/std/lib/mkShell.html"><strong aria-hidden="true">11.3.2.</strong> /mkShell</a></li><li class="chapter-item expanded "><a href="reference/std/lib/mkNixago.html"><strong aria-hidden="true">11.3.3.</strong> /mkNixago</a></li></ol></li><li class="chapter-item expanded "><a href="reference/std/nixago/index.html"><strong aria-hidden="true">11.4.</strong> /nixago</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/std/nixago/adrgen.html"><strong aria-hidden="true">11.4.1.</strong> /adrgen</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/conform.html"><strong aria-hidden="true">11.4.2.</strong> /conform</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/editorconfig.html"><strong aria-hidden="true">11.4.3.</strong> /editorconfig</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/lefthook.html"><strong aria-hidden="true">11.4.4.</strong> /lefthook</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/mdbook.html"><strong aria-hidden="true">11.4.5.</strong> /mdbook</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/treefmt.html"><strong aria-hidden="true">11.4.6.</strong> /treefmt</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> //automation</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/automation/devshells/index.html"><strong aria-hidden="true">12.1.</strong> /devshells</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Standard Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
SPDX-FileCopyrightText: 2022 The Standard Authors
SPDX-FileCopyrightText: 2022 Kevin Amado <kamadorueda@gmail.com>

SPDX-License-Identifier: Unlicense
-->
<div align="center">
  <img src="https://github.com/divnix/std/raw/main/artwork/logo.png" width="250" />
  <h1 id="standard"><a class="header" href="#standard">Standard</a></h1>
  <p>Ship today.</span>
</div>
<!--
_By [Kevin Amado](https://github.com/kamadorueda),
with contributions from [David Arnold](https://github.com/blaggacao),
[Timothy DeHerrera](https://github.com/nrdxp)
and many more amazing people (see end of file for a full list)._
-->
<p><a href="https://github.com/divnix/std">Standard</a> is THE opinionated, generic,
<a href="https://nixos.org/manual/nix/unstable">Nix</a> <a href="https://nixos.wiki/wiki/Flakes">Flakes</a> framework
that will allow you to grow and cultivate
Nix Cells with ease. Nix Cells are the fine
art of code organization using flakes.</p>
<p><em>Once</em> your <code>nix</code> code has evolved into a giant
ball of spaghetti and nobody else except a few
select members of your tribe can still read it
with ease; and <em>once</em> to the rest of your colleagues
it has grown into an impertinence, <em>then</em> <code>std</code>
brings the overdue order to your piece of art
through a well-defined folder structure and
disciplining generic interfaces.</p>
<p>With <code>std</code>, you'll learn how to organize your <code>nix</code>
flake outputs ('<strong>Targets</strong>') into <strong>Cells</strong> and
<strong>Organelles</strong> ‚Äî folded into a useful
<strong>CLI &amp; TUI</strong> to also make the lives of your
colleagues easier.</p>
<p>Through more intuition and less documentation,
your team and community will finally find a
<em>canonical</em> answer to the everlasting question:
<em>What can I <strong>do</strong> with this repository?</em></p>
<hr />
<h2 id="the-std-repository-itself"><a class="header" href="#the-std-repository-itself">The <code>std</code> repository itself</a></h2>
<p>In this repository, you'll find, both, the <em>implementation</em> and an <em>application</em> of <a href="https://github.com/divnix/std">Standard</a>.</p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p><em>What is <code>std</code>? ‚Äî The well-commented <code>nix</code> code ‚Üí <a href="https://github.com/divnix/std/tree/main/src"><code>./src</code></a>.</em></p>
<p>That folder implements:</p>
<ul>
<li><a href="https://github.com/divnix/std/blob/main/src/grow.nix"><code>std.grow</code></a>: the &quot;smart&quot; importer</li>
<li><a href="https://github.com/divnix/std/blob/main/src/grow-on.nix"><code>std.growOn</code></a>: <code>std.grow</code>-variant that recursively merges all additional variadic arguments</li>
<li><a href="https://github.com/divnix/std/blob/main/src/harvest.nix"><code>std.harvest</code></a>: harvest your <strong>Targets</strong> into a different shape for compatibility</li>
<li><a href="https://github.com/divnix/std/blob/main/src/incl.nix"><code>std.incl</code></a>: a straight-forward source filter with additive semantics</li>
<li><a href="https://github.com/divnix/std/blob/main/src/de-systemize.nix"><code>std.deSystemize</code></a>: a helper to hide <code>system</code> from plain sight</li>
<li><a href="https://github.com/divnix/std/blob/main/src/clades.nix"><code>std.&lt;clade&gt;</code></a>: builtin <strong>Organelle</strong> types that implement <strong>Actions</strong></li>
</ul>
<p><em>What is this crazy verbiage? ‚Üí Unambiguous identifiers on the phone.</em> ‚òéÔ∏è</p>
<h3 id="application"><a class="header" href="#application">Application</a></h3>
<p><em>Dog-fooding? ‚Üí <a href="https://github.com/divnix/std/tree/main/cells"><code>./cells</code></a>.</em></p>
<ul>
<li><strong>Cells:</strong> this is no big monorepo, so <a href="https://github.com/divnix/std/tree/main/cells"><code>./cells</code></a> only implements a single <strong>Cell</strong>: <a href="https://github.com/divnix/std/tree/main/cells/std"><code>std</code></a>.</li>
<li><strong>Organelles:</strong> <a href="https://github.com/divnix/std/tree/main/cells/std"><code>std</code></a> implements the <a href="https://github.com/divnix/std/blob/main/cells/std/cli.nix"><code>cli</code></a>,
<a href="https://github.com/divnix/std/blob/main/cells/std/devshellProfiles.nix"><code>devshellProfiles</code></a>, <a href="https://github.com/divnix/std/blob/main/cells/std/devshells.nix"><code>devshells</code></a>
&amp; <a href="https://github.com/divnix/std/blob/main/cells/std/lib/default.nix"><code>lib</code></a> <strong>Organelle</strong>.</li>
<li><strong>Targets:</strong> <a href="https://github.com/divnix/std/blob/main/cells/std/cli.nix"><code>cli</code></a>, <a href="https://github.com/divnix/std/blob/main/cells/std/devshellProfiles.nix"><code>devshellProfiles</code></a> &amp; <a href="https://github.com/divnix/std/blob/main/cells/std/devshells.nix"><code>devshells</code></a>
each only implement a <code>default</code> <strong>Target</strong>. <a href="https://github.com/divnix/std/blob/main/cells/std/lib/default.nix"><code>lib</code></a> has more.</li>
<li><strong>Actions:</strong> some <strong>Targets</strong> have <strong>Actions</strong> derived from the <strong>Organelles</strong>. See <a href="https://github.com/divnix/std/blob/main/flake.nix"><code>./flake.nix</code></a>
for the defined <strong>Organelles</strong>. Not all <strong>Clades</strong> implement <strong>Actions</strong>.</li>
</ul>
<pre><code class="language-nix">{
  growOn,
  inputs,
  clades,
  harvest,
}:
growOn {
  inherit inputs;
  cellsFrom = ./cells;
  organelles = [
    (clades.runnables &quot;cli&quot;)
    (clades.functions &quot;lib&quot;)
    (clades.functions &quot;devshellProfiles&quot;)
    (clades.devshells &quot;devshells&quot;)
    (clades.installables &quot;packages&quot;)
    (clades.nixago &quot;nixago&quot;)
    (clades.data &quot;data&quot;)
    (clades.files &quot;files&quot;)
  ];
} {
  devShells = harvest inputs.self [&quot;automation&quot; &quot;devshells&quot;];
  packages = harvest inputs.self [[&quot;std&quot; &quot;cli&quot;] [&quot;std&quot; &quot;packages&quot;]];
}
</code></pre>
<p><em>That's it. <code>std.grow</code> is a &quot;smart&quot; importer of your <code>nix</code> code and is designed to keep boilerplate at bay.</em></p>
<blockquote>
<p><strong>TIP:</strong>
Now, enter the devshell (<code>direnv allow</code>) and play with the <code>std</code> CLI/TUI companion.
It answers one critical question to newcomers and veterans alike:</p>
<center><i>What can I <b>do</b> with this repository?</i></center>
&emsp;
</blockquote>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<p><em>Where can I find the documentation? ‚Üí <a href="https://github.com/divnix/std/tree/main/docs"><code>./docs</code></a>.</em></p>
<p><em>No, I mean rendered? ‚Üí <a href="https://divnix.github.io/std">The Standard Book</a>.</em></p>
<p>The documentation is structured around these axes:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>For Study</th><th>For Work</th></tr></thead><tbody>
<tr><td><strong>The Practice</strong></td><td>Tutorials</td><td>How-To Guides</td></tr>
<tr><td><strong>The Theory</strong></td><td>Explanation</td><td>Reference</td></tr>
</tbody></table>
</div>
<h3 id="licenses"><a class="header" href="#licenses">Licenses</a></h3>
<p><em>What licenses are used? ‚Üí <a href="https://github.com/divnix/std/blob/main/.reuse/dep5"><code>./.reuse/dep5</code></a>.</em></p>
<p><em>And the usual copies? ‚Üí <a href="https://github.com/divnix/std/tree/main/LICENSES"><code>./LICENSES</code></a>.</em></p>
<h2 id="releases"><a class="header" href="#releases">Releases</a></h2>
<p>You may find releases on the <a href="https://github.com/divnix/std/releases">GitHub Release Page</a> of this repository.</p>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<ul>
<li><a href="https://divnix.github.io/std/explain/why-nix.html">Why <code>nix</code>?</a></li>
<li><a href="https://divnix.github.io/std/explain/why-std.html">Why <code>std</code>?</a></li>
</ul>
<h2 id="examples-in-the-wild"><a class="header" href="#examples-in-the-wild">Examples in the Wild</a></h2>
<p>If you'd like to see some examples
of what a <a href="https://github.com/divnix/std">Standard</a> project looks like,
take a look at the following:</p>
<ul>
<li><a href="https://github.com/input-output-hk/bitte-cells"><code>input-output-hk/bitte-cells</code></a></li>
<li><a href="https://github.com/divnix/hive"><code>divnix/hive</code></a></li>
<li><a href="https://github.com/input-output-hk/tullia"><code>input-output-hk/tullia</code></a></li>
<li><a href="https://github.com/input-output-hk/mdbook-kroki-preprocessor"><code>mdbook-kroki-preprocessor</code></a></li>
<li><a href="https://github.com/hardenedlinux/HardenedNixOS-Profile"><code>HardenedNixOS-Profile</code></a></li>
<li><a href="https://github.com/JuliaCN/Julia2Nix.jl"><code>Julia2Nix.jl</code></a></li>
<li><a href="https://github.com/input-output-hk/cardano-world"><code>inputs-output-hk/cardano-world</code></a></li>
</ul>
<p>:construction: Work in progress, would like to help us extend this section?</p>
<h2 id="contributions"><a class="header" href="#contributions">Contributions</a></h2>
<p>Please enter the development environment:</p>
<pre><code class="language-console">direnv allow
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p><a href="https://github.com/divnix/std">Standard</a> features a special project structure
that brings some awesome innovation
to this often overlooked (but important) part of your project.
With the default <strong>Organelles</strong>, an <code>apps.nix</code> file tells <a href="https://github.com/divnix/std">Standard</a>
that we are creating an Application.
<code>flake.nix</code> is in charge
of explicitly defining
the inputs of your project.</p>
<h4 id="flakenix"><a class="header" href="#flakenix"><code>./flake.nix</code></a></h4>
<pre><code class="language-nix">{
  inputs.std.url = &quot;github:divnix/std&quot;;
  inputs.nixpkgs.url = &quot;nixpkgs&quot;;

  outputs = {std, ...} @ inputs:
    std.grow {
      inherit inputs;
      cellsFrom = ./cells;
    };
}
</code></pre>
<h4 id="cellshelloappsnix"><a class="header" href="#cellshelloappsnix"><code>./cells/hello/apps.nix</code></a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: {
  default = inputs.nixpkgs.stdenv.mkDerivation rec {
    pname = &quot;hello&quot;;
    version = &quot;2.10&quot;;
    src = inputs.nixpkgs.fetchurl {
      url = &quot;mirror://gnu/hello/${pname}-${version}.tar.gz&quot;;
      sha256 = &quot;0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i&quot;;
    };
  };
}
</code></pre>
<pre><code class="language-bash">$ cd hello-world
# fetch `std`
$ nix shell github:divnix/std
$ std //hello/apps/default:run
Hello, world!
</code></pre>
<p>You see? from nothing
to running your first application
in just a few seconds ‚ú®</p>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<p>This example consumes the following defaults or builtins:</p>
<h3 id="default-organelles"><a class="header" href="#default-organelles"><a href="https://github.com/divnix/std/blob/main/src/grow.nix#L63-L67">Default <code>organelles</code></a></a></h3>
<pre><code class="language-nix">    organelles ? [
      (clades.functions &quot;library&quot;)
      (clades.runnables &quot;apps&quot;)
      (clades.installables &quot;packages&quot;)
    ],
</code></pre>
<h3 id="default-systems"><a class="header" href="#default-systems"><a href="https://github.com/divnix/std/blob/main/src/grow.nix#L68-L77">Default <code>systems</code></a></a></h3>
<pre><code class="language-nix">    systems ? [
      # Tier 1
      &quot;x86_64-linux&quot;
      # Tier 2
      &quot;aarch64-linux&quot;
      &quot;x86_64-darwin&quot;
      # Other platforms with sufficient support in stdenv which is not formally
      # mandated by their platform tier.
      &quot;aarch64-darwin&quot; # a lot of apple M1 already out there
    ],
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="growing-cells"><a class="header" href="#growing-cells">Growing Cells</a></h1>
<p>Growing cells can be done via two variants:</p>
<ul>
<li><code>std.grow { cellsFrom = &quot;...&quot;; /* ... */ }</code></li>
<li><code>std.growOn { cellsFrom = &quot;...&quot;; /* ... */ } # soil</code></li>
</ul>
<h2 id="stdgrowon---soil"><a class="header" href="#stdgrowon---soil"><code>std.growOn {} # soil</code></a></h2>
<p>This eases talking and reasoning about a <code>std</code>ized repository, that also needs
some sort of adapters to work together better with external frameworks.</p>
<p>Typically, you'd arrange those adapters in numbered layers of soil, just
so that it's easier to conceptually reference them when talking / chatting.</p>
<p>It's a variadic function and takes an unlimited number of &quot;soil layers&quot;.</p>
<pre><code class="language-nix">{
  inputs.std.url = &quot;github:divnix/std&quot;;

  outputs = {std, ...} @ inputs:
    std.growOn {
      inherit inputs;
      cellsFrom = ./cells;
    }
    # soil
    () # first layer
    () # second layer
    () # ... nth layer
    ;
}
</code></pre>
<p>These layers get recursively merged onto the output of <code>std.grow</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="include-filter"><a class="header" href="#include-filter">Include Filter</a></h1>
<p>It is very common that you want to filter your source code in order
to avoid unnecessary rebuilds and increase your cache hits.</p>
<p>This is so common that <code>std</code> includes a tool for this:</p>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
  inherit (inputs) std;
in {
  backend = nixpkgs.mkYarnPackage {
    name = &quot;backend&quot;;
    src = std.incl (inputs.self + /src/backend) [
      (inputs.self + /src/backend/app.js)
      (inputs.self + /src/backend/config/config.js)
      /* ... */
    ];
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-envrc"><a class="header" href="#setup-envrc">Setup <code>.envrc</code></a></h1>
<p>Standard provides an extension to the <code>stdlib</code> via <code>direnv_lib.sh</code>.</p>
<p>The integrity hash below ensures it is downloaded only once and cached
from there on.</p>
<pre><code class="language-bash">#! /bin/sh

# SPDX-FileCopyrightText: 2022 David Arnold &lt;dgx.arnold@gmail.com&gt;
# SPDX-FileCopyrightText: 2022 Kevin Amado &lt;kamadorueda@gmail.com&gt;
#
# SPDX-License-Identifier: Unlicense

# for debugging, change to:
# source_env ./direnv_lib.sh

source_url \
  &quot;https://raw.githubusercontent.com/divnix/std/main/direnv_lib.sh&quot; \
  &quot;sha256-gnjtiJpKbz4L4udoK12AvBwL1lo5RqPR9mbLu1zuajw=&quot;
use std cells //automation/devshells:default
</code></pre>
<blockquote>
<p><strong>NOTE:</strong>
In the above code (<code>use</code> <code>std</code>) <strong><code>cells</code></strong> (<code>//std/...</code>) refers to the
folder where <strong>Cells</strong> are grown from. If your folder is e.g. <code>nix</code>, adapt
to (<code>use</code> <code>std</code>) <strong><code>nix</code></strong> (<code>//...</code>) and so forth.</p>
</blockquote>
<p>It is used to automatically set up file watches on files that could modify the
current devshell, discoverable through these or similar logs during loading:</p>
<pre><code class="language-console">direnv: loading https://raw.githubusercontent.com/divnix/std/...
direnv: using std cells //automation/devshells:default
direnv: Watching: cells/automation/devshells.nix
direnv: Watching: cells/automation/devshells (recursively)
</code></pre>
<p>For reference, the above example loads the <code>default</code> devshell from:</p>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  l = nixpkgs.lib // builtins;
  inherit (inputs) nixpkgs;
  inherit (inputs.cells) std;
in
  l.mapAttrs (_: std.lib.mkShell) {
    default = {
      extraModulesPath,
      pkgs,
      ...
    }: {
      name = &quot;Standard&quot;;
      nixago = [
        (std.nixago.conform {configData = {inherit (inputs) cells;};})
        cell.nixago.treefmt
        cell.nixago.editorconfig
        cell.nixago.mdbook
        std.nixago.lefthook
        std.nixago.adrgen
      ];
      commands =
        [
          {
            package = nixpkgs.reuse;
            category = &quot;legal&quot;;
          }
          {
            package = nixpkgs.delve;
            category = &quot;cli-dev&quot;;
            name = &quot;dlv&quot;;
          }
          {
            package = nixpkgs.go;
            category = &quot;cli-dev&quot;;
          }
          {
            package = nixpkgs.gotools;
            category = &quot;cli-dev&quot;;
          }
          {
            package = nixpkgs.gopls;
            category = &quot;cli-dev&quot;;
          }
        ]
        ++ l.optionals nixpkgs.stdenv.isLinux [
          {
            package = nixpkgs.golangci-lint;
            category = &quot;cli-dev&quot;;
          }
        ];
      imports = [
        std.devshellProfiles.default
      ];
    };
    checks = {
      pkgs,
      config,
      ...
    }: {
      name = &quot;checks&quot;;
      imports = [
        std.devshellProfiles.default
      ];
      commands = [
        {
          name = &quot;clade-data&quot;;
          command = &quot;cat $(std //tests/data/example:write)&quot;;
        }
        {
          name = &quot;clade-devshells&quot;;
          command = &quot;std //std/devshell/default:enter -- echo OK&quot;;
        }
        {
          name = &quot;clade-runnables&quot;;
          command = &quot;std //std/cli/default:run -- std OK&quot;;
        }
      ];
    };
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-nix"><a class="header" href="#why-nix">Why <code>nix</code>?</a></h1>
<p>A lot of people write a lot of confusing stuff about nix.</p>
<p>So here, we'll try to break it down, instead.</p>
<h2 id="nix-is-json-on-steroids"><a class="header" href="#nix-is-json-on-steroids"><code>nix</code> is &quot;<code>json</code> on steroids&quot;</a></h2>
<p>In configuration management, you have a choice: data vs. language.</p>
<p>On stackoverflow, you'll be taught the &quot;data&quot; stance, because it's simple.</p>
<p>And all of a sudden you hit reality. Outside of a &quot;lab&quot; environment, you suddenly
need to manage a varying degree of complexity.</p>
<p>So you need configuration combinators, or in other words a full blown language
to efficiently render your configurations.</p>
<p>There are a couple of options, that you'll recognize if you've gotten serious about
the configuration challenge, like:</p>
<ul>
<li><a href="https://dhall-lang.org/"><code>dhall</code></a></li>
<li><a href="https://cuelang.org/"><code>cue</code></a></li>
<li><a href="https://jsonnet.org/"><code>jsonnet</code></a></li>
<li><a href="https://nickel-lang.org/"><code>nickel</code></a></li>
</ul>
<p>And there is <a href="https://nixos.org/"><code>nix</code></a>, the language. In most aspects, it isn't hugely distinct from the others,
but it has superpowers. Read on!</p>
<h2 id="nix-superpowers"><a class="header" href="#nix-superpowers"><code>nix</code>' superpowers</a></h2>
<p>You know the concept of string interpolation.</p>
<p>Every time <code>nix</code> interpolates an identifier, there is something that
you don't immediately see: it keeps a so called &quot;string context&quot; right
at the site of interpolation. That string context holds a directed acyclic
graph of all the dependencies that are required to make that string.</p>
<p>&quot;Well, it's just a string; what on earth should I need to make a string?&quot;, you may say.</p>
<p>There is a special category of strings, so called &quot;Nix store paths&quot;
(strings that start with <code>/nix/store/...</code>). These store paths represent
build artifacts that are content addressed ahead-of-time through
the inputs of an otherwise pure build function, called <a href="https://nixos.org/manual/nix/stable/expressions/derivations.html"><code>derivation</code></a>.</p>
<p>When you finally reify (i.e. &quot;build&quot;) your string interpolation, then all these Nix store
paths get build as well.</p>
<p>This might be a bit of a mind-boggling angle, but after a while, you may realize:</p>
<ul>
<li>Nix is a massive build pipeline that tracks all things to their source.</li>
<li>In their capacity as <em>pure</em> build functions, <a href="https://nixos.org/manual/nix/stable/expressions/derivations.html"><code>derviation</code>s</a> build <em>reproducibly</em>.</li>
<li>Reproducible builds are the future of software supply chain security, among other things.</li>
<li>You'll start asking: &quot;who the heck invented all that insecure nonsense of opaque binary registries?
Shouldn't have those smart people have known better?&quot;</li>
<li>And from this realization, there's no coming back.</li>
<li>And you'll have joined the <a href="https://discourse.nixos.org/t/nixos-foundation-participating-in-eus-next-generation-internet-initiative/2011">European Union</a>, <a href="https://discourse.nixos.org/t/mercury-bank-nix-engineers/13784">banks</a> and <a href="https://github.com/input-output-hk/cardano-world">blockchain companies</a> who also realized:
we need to fix our utterly broken and insecure build systems!</li>
<li>By that time, you'll have already assimilated the legendary <a href="http://users.ece.cmu.edu/%7Eganger/712.fall02/papers/p761-thompson.pdf">Ken Thompson's &quot;Reflections on Trusting Trust&quot;</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-std"><a class="header" href="#why-std">Why std?</a></h1>
<h2 id="problem"><a class="header" href="#problem">Problem</a></h2>
<p>Nix is marvel to ones and cruelty to others.</p>
<p>Much of this professional schism is due to two fundamental issues:</p>
<ul>
<li>Nix is a functional language without typing</li>
<li>Therefore, Nix-enthusiast seem to freaking love writing the most elegant and novel boilerplate all over again the next day.</li>
</ul>
<p>The amount of domain specific knowledge required to untangle those most elegant and novel boilerplate patterns prevent
the other side of the schism, very understandably, to see through the smoke the true beauty and benefits of <code>nix</code> as a
build and configuration language.</p>
<p>Lack of typing adds to the problem by forcing <code>nix</code>-practitioners to go out of their way (e.g. via <a href="https://github.com/divnix/yants"><code>divnix/yants</code></a>) to
add some internal boundaries and contracts to an ever morphing global context.</p>
<p>As a consequence, few actually <em>do</em> that. And contracts across internal code boundaries are either absent or rudimentary or ‚Äî yet again ‚Äî
&quot;elegant and novel&quot;. Neither of which satisfactorily settles the issue.</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p><code>std</code> doesn't add language-level typing. But a well-balanced folder layout cut at 3 layers of conceptual
nesting provides the fundamentals for establishing internal boundaries.</p>
<blockquote>
<p><strong>Cell ‚Üí Organelle ‚Üí Target ‚Üí [Action]</strong></p>
<p>Where ...</p>
<ul>
<li><strong>Cells</strong> group functionality.</li>
<li><strong>Organelles</strong> type outputs and implement <strong>Actions</strong>.</li>
<li><strong>Targets</strong> name outputs.</li>
</ul>
</blockquote>
<p>Programmers are really good at pattern-abstraction when looking at two similar but slightly
different things: <em><strong>Cells</strong> and <strong>Organelles</strong> set the stage for code readability.</em></p>
<p><strong>Organelles</strong> only allow one possible interface: <code>{inputs, cell}</code>:</p>
<ul>
<li><code>cell</code> the local <strong>Cell</strong>, promoting separation of concern</li>
<li><code>inputs</code> the <code>deSystemize</code>ed flake inputs ‚Äî plus:
<ul>
<li><code>inputs.self = self.sourceInfo;</code> reference source code in <code>nix</code>; filter with <code>std.incl</code>; don't misuse the global <code>self</code>.</li>
<li><code>inputs.cells</code>: the other cells by name; code that documents its boundaries.</li>
<li><code>inputs.nixpkgs</code>: an <em>instantiated</em> <code>nixpkgs</code> for the current system;</li>
</ul>
</li>
</ul>
<p>Now, we have <em>organized</em> <code>nix</code> code. Still, <code>nix</code> is not for everybody.
And for everybody else the <code>std</code> TUI/CLI companion answers a single question to perfection:</p>
<blockquote>
<p><strong>The GitOps Question:</strong></p>
<center><i>What can I actually <b>do</b> with this <code>std</code>-ized repository?</i></center>
&emsp;
</blockquote>
<blockquote>
<p><strong>The Standard Answer:</strong></p>
<center><i><code>std</code> breaks down GitOps into a single UX-optimized TUI/CLI entrypoint.</i></center>
&emsp;
</blockquote>
<h2 id="benefit"><a class="header" href="#benefit">Benefit</a></h2>
<p>Not everybody is going to love <code>nix</code> now.</p>
<p>But the ones, who know its secrets, now have an effective tool
to more empathically spark the joy.</p>
<p>Or simply: üíî ‚Üí üßô ‚Üí üîß ‚Üí ‚ú®‚Üí üèñÔ∏è</p>
<p>The smallest common denominator, in any case:</p>
<blockquote>
<p>Only ever install a single dependency (<code>nix</code>) and reach <em>any</em> repository target. Reproducibly.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-decision-record"><a class="header" href="#architecture-decision-record">Architecture Decision Record</a></h1>
<p>An architecture decision record (ADR) is a document that captures an
important architectural decision made along with its context and consequences.</p>
<p>The template in this folder has all the info.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To interact with this ADR, enter the devshell and interact though the <code>adrgen</code> tool.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-drop-as-nix-cli-epiphyte-flag"><a class="header" href="#3-drop-as-nix-cli-epiphyte-flag">3. Drop <code>as-nix-cli-epiphyte</code> flag</a></h1>
<p>Date: 2022-04-28</p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>accepted</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p>Currently, <code>std.grow</code> has a <code>as-nix-cli-epiphyte</code> flag to make the output scheme
compatible with the <code>nix</code> CLI output scheme.</p>
<p>However, part of the raison-d'etre of <code>std</code> are the deficiencies of the <code>nix</code> CLI
output scheme.</p>
<p>With the introduction of a TUI and soon a CLI equivalence, the need for matching
the <code>nix</code> CLI interface is diminishing.</p>
<p>For part of the target audience of <code>std</code>, however, the <code>nix</code> CLI interface is a
productivity sink and not really a good day to day companion.</p>
<p>Especially at the intersection of <code>nix</code> experts and non-nix experts, that particular
aspect might be neglected by experienced <code>nix</code> experts that come with different
priorities, habits and workflows.</p>
<h2 id="decision"><a class="header" href="#decision">Decision</a></h2>
<p>To cater the purpose of <code>std</code> to make this a productive Nix-related framework for
teams, we remove the <code>as-nix-cli-epiphyte</code> flag and thereby discourage the wide-spread
and general purpose use of the <code>nix</code> CLI.</p>
<p>If such interoperability is still needed, a layer of soil can bring back the necessary
adapter.</p>
<h2 id="consequences"><a class="header" href="#consequences">Consequences</a></h2>
<p>Nix experts that are making use of <code>std</code> outside of the above described context might
prefer to add back a nix cli adapter as a layer of soil. However, being experts and
knowing their needs, this is probably not a huge show stopper.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-wire-up-documentation-instrumentation"><a class="header" href="#2-wire-up-documentation-instrumentation">2. Wire up documentation instrumentation</a></h1>
<p>Date: 2022-04-20</p>
<h2 id="status-1"><a class="header" href="#status-1">Status</a></h2>
<p>superseded</p>
<p>Superseded by <a href="explain/architecture-decision-records/0004-add-nixago-instrumentation.html">4. Add Nixago Instrumentation</a></p>
<h2 id="context-1"><a class="header" href="#context-1">Context</a></h2>
<p>Documentation instrumentation is always necessary. But because there are so many options,
oftentimes it's not the first thing to do when kick-starting a project.</p>
<p>Either because fingers are eager to hack or because the myriad of options stalls efficient
decision making.</p>
<h2 id="decision-1"><a class="header" href="#decision-1">Decision</a></h2>
<p>In this context, we want to provide a default doc instrumentation setup, that, at the very
minimum is capable of rendering and hosting the ADRs.</p>
<p>Batteries included &amp; (this time) not removable.</p>
<p><em>You can have any color you like as long as it's black.</em></p>
<h2 id="consequences-1"><a class="header" href="#consequences-1">Consequences</a></h2>
<p>As a consequence, entering a devshell, and if no <code>book.toml</code> exists, a minimal layout will be
created.</p>
<p>The user is then expected to fill it with life according to the <code>mdbook</code> docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-increase-repo-discoverability-with-a-tui"><a class="header" href="#1-increase-repo-discoverability-with-a-tui">1. Increase repo discoverability with a TUI</a></h1>
<p>Date: 2022-04-20</p>
<h2 id="status-2"><a class="header" href="#status-2">Status</a></h2>
<p>accepted</p>
<h2 id="context-2"><a class="header" href="#context-2">Context</a></h2>
<p>In general, the more a polyglot repository grows, the more folks need very contextual knowledge to
assess the old and still same question: &quot;What's in it for me?&quot; / WIIFM.</p>
<p>And once they find an answer to that question, already ensues the next: &quot;And how do I make use of it?&quot;.</p>
<p>Finding an answer to these questions is regularly not trivial and hugely language specific.</p>
<p>The classic solution always has been: &quot;Write a (boilerplate) readme.&quot;.</p>
<h2 id="decision-2"><a class="header" href="#decision-2">Decision</a></h2>
<p>Thanks to <code>nix</code>, we can largely outperform that classic solution.</p>
<p>So, we implement a TUI that is duly wired with the repository it represents.</p>
<p>It queries the <code>nix</code> for the necessary metadata including targets and
the target's actions.</p>
<p>It also detects well-placed readme files and presents them contextually on the CLI
to the user.</p>
<p>The user can then fuzzy search any desired target, query its contextual help or choose
one of the actions for execution.</p>
<h2 id="consequences-2"><a class="header" href="#consequences-2">Consequences</a></h2>
<p>Not only in a polyglot repository, the different stakeholders can now easily and naturally
interact (&quot;speak&quot;) with the repository.</p>
<p>This has the potential of optimizing away a lot of very engrained media-breaks that today sometimes
render massive collaboration across a broad team increasingly friction-laden.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-add-nixago-instrumentation"><a class="header" href="#4-add-nixago-instrumentation">4. Add Nixago Instrumentation</a></h1>
<p>Date: 2022-07-29</p>
<h2 id="status-3"><a class="header" href="#status-3">Status</a></h2>
<p>accepted</p>
<p>Supersedes <a href="explain/architecture-decision-records/0002-wire-up-documentation-instrumentation.html">2. Wire up documentation instrumentation</a></p>
<h2 id="context-3"><a class="header" href="#context-3">Context</a></h2>
<p>The current implementation of mdbook instrumentation and adrgen instrumentation is brittle and ad-hoc.
Furthermore, the making these two &quot;special&quot; is a contentious decision.</p>
<p>Adjacently, oftentimes, there are other &quot;repo dotfiles&quot; that we want to somehow centrally manage (and
auto-update), instead of copy pasting them for the n-th time.</p>
<p>Recently, the Nixago project has seen the face of the earth which deals precisely with repo dotfile
templating and linking/copying.</p>
<h2 id="decision-3"><a class="header" href="#decision-3">Decision</a></h2>
<p>Implement a first class integreation with Nixago and add the appropriate glue-code to work seamlessly
together with Devshells.</p>
<p>Ship some generic Nixago Pebbles as part of the <code>std</code> Celle.</p>
<h2 id="consequences-3"><a class="header" href="#consequences-3">Consequences</a></h2>
<ul>
<li>mdbook / adgen dotfile templating is no more &quot;special&quot;</li>
<li>user can make use of this instrumentation to template <em>any</em> repo dotfile</li>
<li>user can reuse the shipped Nixago Pebbles and take inspiration from our dogfooding</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuicli"><a class="header" href="#tuicli">TUI/CLI</a></h1>
<h4 id="tuicli-1"><a class="header" href="#tuicli-1">TUI/CLI:</a></h4>
<pre><code class="language-console"># TUI
std

# CLI
std //&lt;TAB&gt;

# Version
std -v
</code></pre>
<h4 id="help"><a class="header" href="#help">Help:</a></h4>
<pre><code class="language-console">‚ùØ std -h
std is the CLI / TUI companion for Standard.

- Invoke without any arguments to start the TUI.
- Invoke with a target spec and action to run a known target's action directly.

Usage:
std //cell/organelle/target:action [flags]

Flags:
-h, --help      help for std
-v, --version   version for std
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conventions-in-std"><a class="header" href="#conventions-in-std">Conventions in <code>std</code></a></h1>
<p>In principle, we all want to be able to read code with local reasoning.</p>
<p>However, these few conventions are pure quality of life and
help us to keep our nix code organized.</p>
<h2 id="nix-file-locations"><a class="header" href="#nix-file-locations">Nix File Locations</a></h2>
<p>Nix files are imported from either of these two locations, if present, in this order of precedence:</p>
<pre><code>${cellsFrom}/${cell}/${organelle}.nix
${cellsFrom}/${cell}/${organelle}/default.nix
</code></pre>
<h2 id="readme-file-locations"><a class="header" href="#readme-file-locations">Readme File Locations</a></h2>
<p>Readme files are picked up by the TUI in the following places:</p>
<pre><code>${cellsFrom}/${cell}/Readme.md
${cellsFrom}/${cell}/${organelle}/Readme.md
${cellsFrom}/${cell}/${organelle}/${target}.md
</code></pre>
<h2 id="organelle-file-arguments"><a class="header" href="#organelle-file-arguments">Organelle File Arguments</a></h2>
<p>Each organelle is a function and expects the following standardized interface for interoperability:</p>
<pre><code class="language-nix">{ inputs, cell }: {}
</code></pre>
<h2 id="the-inputs-argument"><a class="header" href="#the-inputs-argument">The <code>inputs</code> argument</a></h2>
<p>The <code>inputs</code> argument holds all the de-systemized flake inputs plus a few special inputs:</p>
<pre><code class="language-nix">{
  inputs = {
    self = {}; # sourceInfo of the current repository
    nixpkgs = {}; # an _instantiated_ nixpkgs
    cells = {}; # the other cells in this repo
  };
}
</code></pre>
<h2 id="the-cell-argument"><a class="header" href="#the-cell-argument">The <code>cell</code> argument</a></h2>
<p>The <code>cell</code> argument holds all the different organelle targets of the current cell.
This is the main mechanism by which code organization and separation of concern is enabled.</p>
<h2 id="the-desytemized-inputs"><a class="header" href="#the-desytemized-inputs">The <code>deSytemize</code>d inputs</a></h2>
<p>All inputs are scoped for the <em>current</em> system, that is derived from the <code>systems</code> input list to <code>std.grow</code>.
That means contrary to the usual nix-UX, in most cases, you don't need to worry about <code>system</code>.</p>
<p>The current system will be &quot;lifted up&quot; one level, while still providing full access to all <code>systems</code> for
cross-compilation scenarios.</p>
<pre><code class="language-nix"># inputs.a.packages.${system}
{
  inputs.a.packages.pkg1 = {};
  inputs.a.packages.pkg2 = {};
  /* ... */
  inputs.a.packages.${system}.pkgs1 = {};
  inputs.a.packages.${system}.pkgs2 = {};
  /* ... */
}
</code></pre>
<h4 id="desystemizes-implementation"><a class="header" href="#desystemizes-implementation"><code>deSystemize</code>'s implementation</a></h4>
<pre><code class="language-nix">let
  l = builtins;
  /*
  A helper function which hides the complexities of dealing
  with 'system' properly from you, while still providing
  escape hatches when dealing with cross-compilation.

  You can use this function independently of the rest of std.
  */
  deSystemize = let
    iteration = cutoff: system: fragment:
      if ! (l.isAttrs fragment) || cutoff == 0
      then fragment
      else if l.hasAttr &quot;${system}&quot; fragment &amp;&amp; ! l.isFunction fragment.${system}
      then fragment // fragment.${system}
      else if l.hasAttr &quot;${system}&quot; fragment &amp;&amp; l.isFunction fragment.${system}
      then fragment // {__functor = _: fragment.${system};}
      else l.mapAttrs (_: iteration (cutoff - 1) system) fragment;
  in
    iteration 3;
in
  deSystemize
</code></pre>
<h2 id="top-level-system-scoping-of-outputs"><a class="header" href="#top-level-system-scoping-of-outputs">Top-level <code>system</code>-scoping of outputs</a></h2>
<p>Contrary to the upstream flake schema, all outputs are <code>system</code> spaced at the top-level.
This allows us to uniformly select on the <em>current</em> system and forget about it for most
of the time.</p>
<p>Sometimes <code>nix</code> evaluations don't strictly depend on a particular <code>system</code>, and scoping
them seems counter-intuitive. But due to the fact that function calls are memoized, there
is never a penalty in actually scoping them. So for the sake of uniformity, we scope them
anyways.</p>
<p>The outputs therefore abide by the following &quot;schema&quot;:</p>
<pre><code class="language-nix">{
  ${system}.${cell}.${organelle}.${target} = {};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtin-clades"><a class="header" href="#builtin-clades">Builtin Clades</a></h1>
<p>A few clades (&quot;typed organelles&quot;) are packaged with <code>std</code>.</p>
<p>In practical terms, clades distinguish themselves through the
actions they provide to a particular organelle.</p>
<p>It is entirely possible to define custom clades with custom
actions according to the needs of your project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data"><a class="header" href="#data">Data</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Data Clade for json serializable data.

  Available actions:
    - write
    - explore

  For all actions is true:
    Nix-proper 'stringContext'-carried dependency will be realized
    to the store, if present.
  */
  data = name: {
    inherit name;
    clade = &quot;data&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: let
      builder = [&quot;nix&quot; &quot;build&quot; &quot;--impure&quot; &quot;--json&quot; &quot;--no-link&quot; &quot;--expr&quot; expr];
      jq = [&quot;|&quot; &quot;${nixpkgs.legacyPackages.${system}.jq}/bin/jq&quot; &quot;-r&quot; &quot;'.[].outputs.out'&quot;];
      fx = [&quot;|&quot; &quot;xargs&quot; &quot;cat&quot; &quot;|&quot; &quot;${nixpkgs.legacyPackages.${system}.fx}/bin/fx&quot;];
      expr = l.strings.escapeShellArg ''
        let
          pkgs = (builtins.getFlake &quot;${nixpkgs.sourceInfo.outPath}&quot;).legacyPackages.${system};
          this = (builtins.getFlake &quot;${flake}&quot;).${fragment};
        in
          pkgs.writeTextFile {
            name = &quot;data.json&quot;;
            text = builtins.toJSON this;
          }
      '';
    in [
      {
        name = &quot;write&quot;;
        description = &quot;write to file&quot;;
        command = l.concatStringsSep &quot;\t&quot; (builder ++ jq);
      }
      {
        name = &quot;explore&quot;;
        description = &quot;interactively explore&quot;;
        command = l.concatStringsSep &quot;\t&quot; (builder ++ jq ++ fx);
      }
    ];
  };
in
  data
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Functions Clade for reusable nix functions that you would
  call elswhere in the code.

  Also use this for all types of modules and profiles, since they are
  implemented as functions.

  Consequently, there are no actions available for functions.
  */
  functions = name: {
    inherit name;
    clade = &quot;functions&quot;;
  };
in
  functions
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runnables"><a class="header" href="#runnables">Runnables</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Runnables Clade for targets that you want to
  make accessible with a 'run' action on the TUI.
  */
  runnables = name: {
    inherit name;
    clade = &quot;runnables&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: [
      {
        name = &quot;run&quot;;
        description = &quot;exec this target&quot;;
        command = ''
          nix run ${flake}#${fragment}
        '';
      }
    ];
  };
in
  runnables
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installables"><a class="header" href="#installables">Installables</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Installables Clade for targets that you want to
  make availabe for installation into the user's nix profile.

  Available actions:
    - install
    - upgrade
    - remove
    - build
    - bundle
    - bundleImage
    - bundleAppImage
  */
  installables = name: {
    inherit name;
    clade = &quot;installables&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: [
      {
        name = &quot;install&quot;;
        description = &quot;install this target&quot;;
        command = ''
          nix profile install ${flake}#${fragment}
        '';
      }
      {
        name = &quot;upgrade&quot;;
        description = &quot;upgrade this target&quot;;
        command = ''
          nix profile upgrade ${flake}#${fragment}
        '';
      }
      {
        name = &quot;remove&quot;;
        description = &quot;remove this target&quot;;
        command = ''
          nix profile remove ${flake}#${fragment}
        '';
      }
      {
        name = &quot;build&quot;;
        description = &quot;build this target&quot;;
        command = ''
          nix build ${flake}#${fragment}
        '';
      }
      {
        name = &quot;bundle&quot;;
        description = &quot;bundle this target&quot;;
        command = ''
          nix bundle --bundler github:Ninlives/relocatable.nix --refresh ${flake}#${fragment}
        '';
      }
      {
        name = &quot;bundleImage&quot;;
        description = &quot;bundle this target to image&quot;;
        command = ''
          nix bundle --bundler github:NixOS/bundlers#toDockerImage --refresh ${flake}#${fragment}
        '';
      }
      {
        name = &quot;bundleAppImage&quot;;
        description = &quot;bundle this target to AppImage&quot;;
        command = ''
          nix bundle --bundler github:ralismark/nix-appimage --refresh ${flake}#${fragment}
        '';
      }
    ];
  };
in
  installables
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microvms"><a class="header" href="#microvms">Microvms</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Microvms Clade for Microvm.nix - https://github.com/astro/microvm.nix

  Available actions:
    - microvm
  */
  substituters = &quot;--option extra-substituters https://microvm.cachix.org&quot;;
  keys = &quot;--option extra-trusted-public-keys microvm.cachix.org-1:oXnBc6hRE3eX5rSYdRyMYXnfzcCxC7yKPTbZXALsqys=&quot;;

  microvms = name: {
    inherit name;
    clade = &quot;microvms&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: let
      run = [&quot;nix&quot; &quot;run&quot; &quot;${flake}#${fragment}.config.microvm.runner&quot;];
    in [
      {
        name = &quot;microvm&quot;;
        description = &quot;exec this microvm&quot;;
        command =
          (l.concatStringsSep &quot;\t&quot; run)
          + &quot;.$(nix eval --json --option warn-dirty false\ &quot;
          + &quot;${flake}#${fragment}.config.microvm.hypervisor)&quot;
          + &quot;\ ${substituters} ${keys}&quot;;
      }
    ];
  };
in
  microvms
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="devshells"><a class="header" href="#devshells">Devshells</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Devshells Clade for devShells.

  Available actions:
    - enter
  */
  devshells = name: {
    inherit name;
    clade = &quot;devshells&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: [
      {
        name = &quot;enter&quot;;
        description = &quot;enter this devshell&quot;;
        command = ''
          std_layout_dir=$PRJ_ROOT/.std
          profile_path=&quot;$std_layout_dir/${fragmentRelPath}&quot;
          mkdir -p &quot;$profile_path&quot;
          nix_args=(
            &quot;$PRJ_ROOT#${fragment}&quot;
            &quot;--no-update-lock-file&quot;
            &quot;--no-write-lock-file&quot;
            &quot;--no-warn-dirty&quot;
            &quot;--accept-flake-config&quot;
            &quot;--no-link&quot;
            &quot;--keep-outputs&quot;
            &quot;--build-poll-interval&quot; &quot;0&quot;
          )
          nix build &quot;''${nix_args[@]}&quot; --profile &quot;$profile_path/shell-profile&quot;
          bash -c &quot;source $profile_path/shell-profile/env.bash; SHLVL=$SHLVL; __devshell-motd; exec $SHELL -i&quot;
        '';
      }
    ];
  };
in
  devshells
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containers"><a class="header" href="#containers">Containers</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Containers Clade for OCI-images built with nix2container.

  Available actions:
    - print-image
    - copy-to-registry
    - copy-to-podman
    - copy-to-docker
  */
  containers = name: {
    inherit name;
    clade = &quot;containers&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: [
      {
        name = &quot;print-image&quot;;
        description = &quot;print out the image name &amp; tag&quot;;
        command = ''
          echo
          echo &quot;$(nix eval --raw ${flake}#${fragment}.imageName):$(nix eval --raw ${flake}#${fragment}.imageTag)&quot;
        '';
      }
      {
        name = &quot;copy-to-registry&quot;;
        description = &quot;copy the image to its remote registry&quot;;
        command = ''
          nix run ${flake}#${fragment}.copyToRegistry
        '';
      }
      {
        name = &quot;copy-to-docker&quot;;
        description = &quot;copy the image to the local docker registry&quot;;
        command = ''
          nix run ${flake}#${fragment}.copyToDockerDaemon
        '';
      }
      {
        name = &quot;copy-to-podman&quot;;
        description = &quot;copy the image to the local podman registry&quot;;
        command = ''
          nix run ${flake}#${fragment}.copyToPodman
        '';
      }
    ];
  };
in
  containers
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nixago"><a class="header" href="#nixago">Nixago</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Nixago Clade for nixago pebbles.

  Use Nixago pebbles to ensure files are present
  or symlinked into your repository. You may typically
  use this for repo dotfiles.

  For more information, see: https://github.com/nix-community/nixago.

  Available actions:
    - ensure
    - explore

  */
  nixago = name: {
    inherit name;
    clade = &quot;nixago&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: [
      {
        name = &quot;populate&quot;;
        description = &quot;populate this nixago file into the repo&quot;;
        command = ''
          nix run ${flake}#${fragment}.install
        '';
      }
      {
        name = &quot;explore&quot;;
        description = &quot;interactively explore the nixago file&quot;;
        command = ''
          ${nixpkgs.legacyPackages.${system}.bat}/bin/bat &quot;$(nix build --no-link --print-out-paths ${flake}#${fragment}.configFile)&quot;
        '';
      }
    ];
  };
in
  nixago
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-std-cell"><a class="header" href="#the-std-cell">The <code>std</code> Cell</a></h1>
<p>... is the only cell in <code>divnix/std</code> and provides only very limited functionality.</p>
<ul>
<li>It contains the TUI, in <code>./cli</code>.</li>
<li>It contains a <code>devshellProfile</code> in <code>./devshellProfiles</code>.</li>
<li>It contains a growing number of second level library functions in <code>./lib</code>.</li>
<li>Packages that are used in std devshells are proxied in <code>./packages</code>.</li>
</ul>
<p>That's it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-std-tui--cli"><a class="header" href="#the-std-tui--cli">The <code>std</code> TUI / CLI</a></h1>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<ul>
<li>Enter a <code>std</code>ized repository.</li>
<li>Enter it's devshell (which must include <code>//std/devshellProfiles:default</code>)</li>
<li>Run <code>std</code>.</li>
</ul>
<p>It will show you around interactively and lead you very quickly to what you're looking for.</p>
<p>It's self-documented on it's legend.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stds-devshellprofiles"><a class="header" href="#stds-devshellprofiles"><code>std</code>'s <code>devshellProfiles</code></a></h1>
<p>This organelle only exports a single <code>default</code> devshellProfile.</p>
<p>Any <code>std</code>ized repository should include this into its <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code></a>
in order to provide any visitor with the fully pre-configured <code>std</code> TUI.</p>
<p>It also wires &amp; instantiates a decent ADR tool. Or were you planning to hack away
without some minimal conscious effort of decision making and recording? üòÖ</p>
<h1 id="usage-example"><a class="header" href="#usage-example">Usage Example</a></h1>
<pre><code class="language-nix"># ./nix/automation/devshells.nix
{
  inputs,
  cell,
}: let
  l = nixpkgs.lib // builtins;
  inherit (inputs) nixpkgs;
  inherit (inputs.std) std;
in
  l.mapAttrs (_: std.lib.mkShell) {
    # `default` is a special target in newer nix versions
    # see: harvesting below
    default = {
      name = &quot;My Devshell&quot;;
      # make `std` available in the numtide/devshell
      imports = [ std.devshellProfiles.default ];
    };
  }
</code></pre>
<pre><code class="language-nix"># ./flake.nix
{
  inputs.std.url = &quot;github:divnix/std&quot;;

  outputs = inputs:
    inputs.std.growOn {
      inherit inputs;
      cellsFrom = ./nix;
      organelles = [
        /* ... */
        (inputs.std.clades.devshells &quot;devshells&quot;)
      ];
    }
    # soil for compatiblity ...
    {
      # ... with `nix develop` - `default` is a special target for `nix develop`
      devShells = inputs.std.harvest inputs.self [&quot;automation&quot; &quot;devshells&quot;];
    };
}
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-std-library"><a class="header" href="#the-std-library">The <code>std</code> library</a></h1>
<p>This library may accumulate over time library functions that provide
integrations with other frameworks or are so overwhelmingly &amp; generally
useful that upstreaming them into Standard cannot be withheld.</p>
<p>In general, though, <code>std</code> is already opinionated enough in order to grow
this library very conservatively, only.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frommakeswith-provides-an-interface-to-makes-tasks"><a class="header" href="#frommakeswith-provides-an-interface-to-makes-tasks"><code>fromMakesWith</code> provides an interface to <code>makes</code> tasks</a></h1>
<p>This is an integration for <a href="https://github.com/fluidattacks/makes"><code>fluidattacks/makes</code></a>.</p>
<p>A version that has this <a href="https://github.com/fluidattacks/makes/commit/cd8c4eda69e2ce8dc6f811973ba0d80070b4628a">patch</a> is a prerequisite.</p>
<h2 id="usage-example-1"><a class="header" href="#usage-example-1">Usage example</a></h2>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  make = inputs.std.std.lib.fromMakesWith inputs;
in {
  task = make ./path/to/make/task//main.nix {};
}
</code></pre>
<p><em>Some refactoring of the tasks may be necessary. Let the error messages be your friend.</em></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="mkshell"><a class="header" href="#mkshell"><code>mkShell</code></a></h1>
<p>This is a transparent convenience proxy for <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code>'s</a> <code>mkShell</code> function.</p>
<p>It is enriched with a tight integration for <code>std</code> <a href="https://github.com/nix-community/nixago">Nixago</a> pebbles:</p>
<pre><code class="language-nix">{ inputs, cell}: {
  default = inputs.std.std.lib.mkShell {
    /* ... */
    nixago = [
      (cell.nixago.foo {
        configData.qux = &quot;xyz&quot;;
        packages = [ pkgs.additional-package ];
      })
      cell.nixago.bar
      cell.nixago.quz
    ];
  };
}
</code></pre>
<p><em>Note, that you can extend any Nixago Pebble at the calling site
via a built-in functor like in the example above.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mknixago"><a class="header" href="#mknixago"><code>mkNixago</code></a></h1>
<p>This is a transparent convenience proxy for <a href="https://github.com/nix-community/nixago"><code>nix-community/nixago</code>'s</a> <code>lib.${system}.make</code> function.</p>
<p>It is enriched with a forward contract towards <code>std</code> enriched <code>mkShell</code> implementation.</p>
<p>In order to define <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code>'s</a> <code>commands</code> &amp; <code>packages</code> alongside the Nixago pebble,
just add the following attrset to the Nixago spec. It will be picked up automatically by <code>mkShell</code> when that pebble
is used inside its <code>config.nixago</code>-option.</p>
<pre><code class="language-nix">{ inputs, cell }: {
  foo = inputs.std.std.lib.mkNixago {
    /* ... */
    packages = [ /* ... */ ];
    commands = [ /* ... */ ];
    devshell = { /* ... */ }; # e.g. for startup hooks
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-std-nixago-pebbles"><a class="header" href="#the-std-nixago-pebbles">The <code>std</code> Nixago Pebbles</a></h1>
<p>Standard comes packages with some <a href="https://github.com/nix-community/nixago">Nixago</a> Pebbles for easy
downstream re-use.</p>
<p>Some Pebbles may have a special integration for <code>std</code>.</p>
<p>For example, the <code>conform</code> Pebble can undestand <code>inputs.cells</code>
and add each Cell as a so called &quot;scope&quot; to its
<a href="https://www.conventionalcommits.org/">Conventional Commit</a> configuration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adrgen"><a class="header" href="#adrgen"><a href="https://github.com/asiermarques/adrgen"><code>adrgen</code></a></a></h1>
<p>A great tool to manage Architecture Decision Records.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conform"><a class="header" href="#conform"><a href="https://github.com/siderolabs/conform"><code>conform</code></a></a></h1>
<p>Conform your code to policies, e.g. in a pre-commit hook.</p>
<p>This version is wrapped, it can auto-enhance the conventional
commit scopes with your <code>cells</code> as follows:</p>
<pre><code class="language-nix">{ inputs, cell}: let
  inherit (inputs.std) std;
in {

  default = std.lib.mkShell {
    /* ... */
    nixago = [
      (std.nixago.conform {configData = {inherit (inputs) cells;};})
    ];
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editorconfig"><a class="header" href="#editorconfig"><a href="https://github.com/editorconfig/"><code>editorconfig</code></a></a></h1>
<p>Most editors understand this file and autoconfigure themselves accordingly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lefthook"><a class="header" href="#lefthook"><a href="https://github.com/evilmartians/lefthook"><code>lefthook</code></a></a></h1>
<p>A fast (parallel execution) and elegant git hook manager.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mdbook"><a class="header" href="#mdbook"><a href="https://github.com/rust-lang/mdBook"><code>mdbook</code></a></a></h1>
<p>Write clean docs for humans.</p>
<p>This version comes preset with this gem to make any
Solution Architect extra happy: <a href="https://github.com/joelcourtney/mdbook-kroki-preprocessor"><code>mdbook-kroki-preprocessor</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="treefmt"><a class="header" href="#treefmt"><a href="https://github.com/numtide/treefmt"><code>treefmt</code></a></a></h1>
<p>A code formatter to fromat the entire code tree extremly fast (in parallel and with a smart cache).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="devshells-1"><a class="header" href="#devshells-1">Devshells</a></h1>
<ul>
<li>The <code>default</code> devshell implements the development environment for the <code>std</code> TUI/CLI.</li>
<li>Furthermore, it implements a <code>pre-commit</code> hook to keep the source code formatted.</li>
<li>It makes use of <code>std.lib.mkShell</code> which is a convenience proxy for <code>numtide/devshell</code>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
