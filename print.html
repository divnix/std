<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Standard Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="docs/theme/pagetoc.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="ARCHITECTURE.html">Design & Architecture</a></li><li class="chapter-item expanded affix "><a href="PITCH.html">Sales Pitch</a></li><li class="chapter-item expanded affix "><a href="COMPARE.html">Comparisions</a></li><li class="chapter-item expanded affix "><a href="ROADMAP.html">Roadmap</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="tutorials/walk-in-the-park.html"><strong aria-hidden="true">1.</strong> A walk in the park</a></li><li class="chapter-item expanded "><a href="tutorials/hello-world/index.html"><strong aria-hidden="true">2.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="tutorials/hello-moon/index.html"><strong aria-hidden="true">3.</strong> Hello Moon</a></li><li class="chapter-item expanded affix "><li class="part-title">How-To Guides</li><li class="chapter-item expanded "><a href="guides/growing-cells.html"><strong aria-hidden="true">4.</strong> Growing Cells</a></li><li class="chapter-item expanded "><a href="guides/incl.html"><strong aria-hidden="true">5.</strong> Include Filter</a></li><li class="chapter-item expanded "><a href="guides/envrc.html"><strong aria-hidden="true">6.</strong> Setup .envrc</a></li><li class="chapter-item expanded affix "><li class="part-title">Explanation</li><li class="chapter-item expanded "><a href="explain/why-nix.html"><strong aria-hidden="true">7.</strong> Why nix?</a></li><li class="chapter-item expanded "><a href="explain/why-std.html"><strong aria-hidden="true">8.</strong> Why std?</a></li><li class="chapter-item expanded "><a href="explain/architecture-decision-records/index.html"><strong aria-hidden="true">9.</strong> Architecture Decisions</a></li><li class="chapter-item expanded affix "><li class="part-title">Patterns</li><li class="chapter-item expanded "><a href="patterns/four-packaging-layers.html"><strong aria-hidden="true">10.</strong> The 4 Packaging Layers</a></li><li class="chapter-item expanded "><a href="patterns/ci-cd-10000-feet.html"><strong aria-hidden="true">11.</strong> CI/CD — 10000ft flight height</a></li><li class="chapter-item expanded affix "><li class="part-title">Templates</li><li class="chapter-item expanded "><a href="templates/minimal.html"><strong aria-hidden="true">12.</strong> Minimal</a></li><li class="chapter-item expanded "><a href="templates/rust.html"><strong aria-hidden="true">13.</strong> Rust</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/cli.html"><strong aria-hidden="true">14.</strong> TUI/CLI</a></li><li class="chapter-item expanded "><a href="reference/conventions.html"><strong aria-hidden="true">15.</strong> Conventions</a></li><li class="chapter-item expanded "><a href="reference/deprecations.html"><strong aria-hidden="true">16.</strong> Deprecations</a></li><li class="chapter-item expanded "><a href="reference/blocktypes.html"><strong aria-hidden="true">17.</strong> Builtin Block Types</a></li><li class="chapter-item expanded "><a href="reference/lib.html"><strong aria-hidden="true">18.</strong> Cell: lib</a></li><li class="chapter-item expanded "><a href="reference/std.html"><strong aria-hidden="true">19.</strong> Cell: std</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">20.</strong> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Standard Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
SPDX-FileCopyrightText: 2022 The Standard Authors
SPDX-FileCopyrightText: 2022 Kevin Amado <kamadorueda@gmail.com>

SPDX-License-Identifier: Unlicense
-->
<div align="center">
  <img src="https://github.com/divnix/std/raw/main/artwork/logo.png" width="250" />
  <h1 id="standard"><a class="header" href="#standard">Standard</a></h1>
  <p>Ship today.</span>
</div>
<!--
_By [Kevin Amado](https://github.com/kamadorueda),
with contributions from [David Arnold](https://github.com/blaggacao),
[Timothy DeHerrera](https://github.com/nrdxp)
and many more amazing people (see end of file for a full list)._
-->
<hr />
<p><a href="https://github.com/divnix/std">Standard</a> is a nifty DevOps framework that
enables an efficient Software Development Life Cycle (SDLC) with the power of <a href="https://nixos.org/manual/nix/unstable">Nix</a> via <a href="https://nixos.wiki/wiki/Flakes">Flakes</a>.</p>
<p>It organizes and disciplines your Nix and thereby speeds you up.
It also comes with great horizontal integrations of high
quality vertical DevOps tooling crafted by the <a href="https://discourse.nixos.org">Nix Ecosystem</a>.</p>
<hr />
<p><a href="https://matrix.to/#/#std-nix:matrix.org"><img src="https://img.shields.io/matrix/std-nix:matrix.org?server_fqdn=matrix.org&amp;style=for-the-badge" alt="Support room on Matrix" /></a></p>
<h6 id="stack"><a class="header" href="#stack">Stack</a></h6>
<p><a href="https://github.com/divnix/yants"><img src="https://img.shields.io/badge/DivNix-Yants-green?style=for-the-badge&amp;logo=NixOS" alt="Yants" /></a>
<a href="https://github.com/divnix/data-merge"><img src="https://img.shields.io/badge/DivNix-DMerge-yellow?style=for-the-badge&amp;logo=NixOS" alt="DMerge" /></a>
<a href="https://github.com/divnix/nosys"><img src="https://img.shields.io/badge/DivNix-NoSys-orange?style=for-the-badge&amp;logo=NixOS" alt="NoSys" /></a>
<a href="https://github.com/divnix/blank"><img src="https://img.shields.io/badge/DivNix-Blank-grey?style=for-the-badge&amp;logo=NixOS" alt="Blank" /></a>
<a href="https://github.com/divnix/incl"><img src="https://img.shields.io/badge/DivNix-Incl-blue?style=for-the-badge&amp;logo=NixOS" alt="Incl" /></a>
<a href="https://github.com/divnix/paisano"><img src="https://img.shields.io/badge/DivNix-Paisano-red?style=for-the-badge&amp;logo=NixOS" alt="Paisano" /></a></p>
<h6 id="integrations"><a class="header" href="#integrations">Integrations</a></h6>
<p><a href="https://github.com/numtide/devshell"><img src="https://img.shields.io/badge/Numtide-Devshell-yellowgreen?style=for-the-badge&amp;logo=NixOS" alt="Numtide Devshell" /></a>
<a href="https://github.com/numtide/treefmt"><img src="https://img.shields.io/badge/Numtide-Treefmt-yellow?style=for-the-badge&amp;logo=NixOS" alt="Numtide Treefmt" /></a>
<a href="https://github.com/nlewo/nix2container"><img src="https://img.shields.io/badge/Nlewo-Nix2Container-blue?style=for-the-badge&amp;logo=NixOS" alt="Nlewo Nix2Container" /></a>
<a href="https://github.com/fluidattacks/makes"><img src="https://img.shields.io/badge/Fluidattacks-Makes-blue?style=for-the-badge&amp;logo=NixOS" alt="Fluidattacks Makes" /></a>
<a href="https://github.com/astro/microvm.nix"><img src="https://img.shields.io/badge/Astro-MicroVM-blue?style=for-the-badge&amp;logo=NixOS" alt="Astro MicroVM" /></a>
<a href="https://github.com/hercules-ci/flake-parts"><img src="https://img.shields.io/badge/HerculesCI-FlakeParts-lightgrey?style=for-the-badge&amp;logo=NixOS" alt="HerculesCI FlakeParts" /></a>
<a href="https://github.com/cachix"><img src="https://img.shields.io/badge/Cachix-Cache-blue?style=for-the-badge&amp;logo=NixOS" alt="Cachix Cache" /></a>
<a href="https://github.com/nix-community/nixago"><img src="https://img.shields.io/badge/NixCommunity-Nixago-yellow?style=for-the-badge&amp;logo=NixOS" alt="Nix-Community Nixago" /></a></p>
<h6 id="the-standard-story"><a class="header" href="#the-standard-story">The Standard Story</a></h6>
<p><em>Once</em> your <code>nix</code> code has evolved into a giant
ball of spaghetti and nobody else except a few
select members of your tribe can still read it
with ease; and <em>once</em> to the rest of your colleagues
it has grown into an impertinence, <em>then</em> <code>std</code>
brings the overdue order to your piece of art
through a well-defined folder structure and
disciplining generic interfaces.</p>
<p>With <code>std</code>, you'll learn how to organize your <code>nix</code>
flake outputs ('<strong>Targets</strong>') into <strong>Cells</strong> and
<strong>Cell Blocks</strong> — folded into a useful
<strong>CLI &amp; TUI</strong> to also make the lives of your
colleagues easier.</p>
<p>Through more intuition and less documentation,
your team and community will finally find a
<em>canonical</em> answer to the everlasting question:
<em>What can I <strong>do</strong> with this repository?</em></p>
<h6 id="the-standard-nixos-story-in-case-you-wondered"><a class="header" href="#the-standard-nixos-story-in-case-you-wondered">The Standard NixOS Story (in case you wondered)</a></h6>
<p><em>Once</em> you got fed up with <code>divnix/digga</code>
or a disorganized personal configuration,
please head straight over to <a href="https://github.com/divnix/hive"><code>divnix/hive</code></a>
and join the chat, there. It's work in progress.
But hey! It means: we can progress together!</p>
<hr />
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<pre><code class="language-nix"># flake.nix
{
  description = "Description for the project";

  inputs = {
    std.url = "github:divnix/std";
    nixpkgs.follows = "std/nixpkgs";
  };

  outputs = { std, self, ...} @ inputs: std.growOn {
    inherit inputs;
    # 1. Each folder inside `cellsFrom` becomes a "Cell"
    #    Run for example: 'mkdir nix/mycell'
    # 2. Each &lt;block&gt;.nix or &lt;block&gt;/default.nix within it becomes a "Cell Block"
    #    Run for example: '$EDITOR nix/mycell/packages.nix' - see example content below
    cellsFrom = ./nix;
    # 3. Only blocks with these names [here: "packages" &amp; "shells"] are picked up by Standard
    #    It's a bit like the output type system of your flake project (hint: CLI &amp; TUI!!)
    cellBlocks = with std.blockTypes; [
      (installables "packages" {ci.build = true;})
      (devshells "shells" {ci.build = true;})
    ];
  }
  # 4. Run 'nix run github:divnix/std'
  # 'growOn' ... Soil:
  #  - here, compat for the Nix CLI
  #  - but can use anything that produces flake outputs (e.g. flake-parts or flake-utils)
  # 5. Run: nix run .
  {
    devShells = std.harvest self ["mycell" "shells"];
    packages = std.harvest self ["mycell" "packages"];
  };
}

# nix/mycell/packages.nix
{inputs, cell}: {
  inherit (inputs.nixpkgs) hello;
  default = cell.packages.hello;
}
</code></pre>
<h2 id="this-repository"><a class="header" href="#this-repository">This Repository</a></h2>
<p>This repository combines the above mentioned stack components into the ready-to-use Standard framework.
It adds a curated collection of <a href="https://github.com/divnix/std/blob/main/src/blocktypes.nix"><strong>Block Types</strong></a> for DevOps use cases.
It further dogfoods itself and implements utilities in its own <a href="https://github.com/divnix/std/tree/main/cells"><strong>Cells</strong></a>.</p>
<h6 id="dogfooding"><a class="header" href="#dogfooding">Dogfooding</a></h6>
<p><sub>Only renders in the <a href="https://std.divnix.com">Documentation</a>.</sub></p>
<pre><code class="language-nix">inputs: let
  inherit (inputs) incl std;
  inherit (inputs.paisano) pick harvest;
in
  std.growOn {
    inherit inputs;
    cellsFrom = incl ./src ["local" "tests"];
    nixpkgsConfig = {allowUnfree = true;};
    cellBlocks = with std.blockTypes; [
      ## For local use in the Standard repository
      # local
      (devshells "shells" {ci.build = true;})
      (nixago "configs")
      (containers "containers")
      (namaka "checks" {ci.check = true;})
    ];
  }
  {
    devShells = harvest inputs.self ["local" "shells"];
    checks = harvest inputs.self ["tests" "checks" "snapshots" "check"];
  }
  (std.grow {
    inherit inputs;
    cellsFrom = incl ./src ["std" "lib" "data"];
    cellBlocks = with std.blockTypes; [
      ## For downstream use

      # std
      (runnables "cli" {ci.build = true;})
      (functions "devshellProfiles")
      (functions "errors")
      (data "templates")

      # lib
      (functions "dev")
      (functions "ops")
      (anything "cfg")
      (data "configs")
    ];
  })
  {
    packages = harvest inputs.self [["std" "cli"] ["std" "packages"]];
    templates = pick inputs.self ["std" "templates"];
  }
</code></pre>
<p><em>That's it. <code>std.grow</code> is a "smart" importer of your <code>nix</code> code and is designed to keep boilerplate at bay. In the so called "Soil" compatibility layer, you can do whatever your heart desires. For example put <code>flake-utils</code> or <code>flake-parts</code> patterns here. Or, as in the above example, just make your stuff play nicely with the Nix CLI.</em></p>
<blockquote>
<p><strong>TIP:</strong></p>
<ol>
<li>Clone this repo <code>git clone https://github.com/divnix/std.git</code></li>
<li>Install <code>direnv</code> &amp; inside the repo, do: <code>direnv allow</code> (first time takes a little longer)</li>
<li>Run the TUI by entering <code>std</code> (first time takes a little longer)</li>
</ol>
<center><i>What can I <b>do</b> with this repository?</i></center>
&emsp;
</blockquote>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>The <a href="https://std.divnix.com">Documentation</a> is here.</p>
<p>And here is the <a href="https://jmgilman.github.io/std-book/">Book</a>, a very good walk-trough. Start here!</p>
<h6 id="video-series"><a class="header" href="#video-series">Video Series</a></h6>
<ul>
<li><a href="https://www.loom.com/share/cf9d5d1a10514d65bf6b8287f7ddc7d6">Std - Introduction</a></li>
<li><a href="https://www.loom.com/share/04fa1d578fd044059b02c9c052d87b77">Std - Cell Blocks Deep Dive</a></li>
<li><a href="https://www.loom.com/share/27d91aa1eac24bcaaaed18ea6d6d03ca">Std - Operables &amp; OCI</a></li>
<li><a href="https://www.loom.com/share/5c1badd77ab641d3b8e256ddbba69042">Std - Nixago</a></li>
</ul>
<h6 id="examples-in-the-wild"><a class="header" href="#examples-in-the-wild">Examples in the Wild</a></h6>
<p>This <a href="https://github.com/search?q=%22divnix%2Fstd%22+path%3Aflake.nix&amp;type=Code">GitHub search query</a> holds a pretty good answer.</p>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<ul>
<li><a href="https://std.divnix.com/explain/why-nix.html">Why <code>nix</code>?</a></li>
<li><a href="https://std.divnix.com/explain/why-std.html">Why <code>std</code>?</a></li>
</ul>
<h2 id="contributions"><a class="header" href="#contributions">Contributions</a></h2>
<p>Please enter the contribution environment:</p>
<pre><code class="language-console">direnv allow || nix develop -c "$SHELL"
</code></pre>
<h2 id="licenses"><a class="header" href="#licenses">Licenses</a></h2>
<p><em>What licenses are used? → <a href="https://github.com/divnix/std/blob/main/.reuse/dep5"><code>./.reuse/dep5</code></a>.</em></p>
<p><em>And the usual copies? → <a href="https://github.com/divnix/std/tree/main/LICENSES"><code>./LICENSES</code></a>.</em></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-design-and-architecture"><a class="header" href="#standard-design-and-architecture">Standard Design and Architecture</a></h1>
<p>At the time of writing, almost a year of exploratory and freestyle project history has passed.
Fortunately, it is not necessary for further understanding, so I'll spare you that.
This document, though, lays out the design, architecture and direction of Standard.</p>
<p>If the topics discussed herein are dear to you, please take it as an invitation to get involved.</p>
<p>This design document shall be stable and amendments go through a proper process of consideration.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Standard is a collection of functionality and best practices (<em>"framework"</em>) to bootstrap and sustain the automatable sections of the Software Development Lifecycle (SDLC) <em>efficiently</em> with the power of Nix and Flakes.
In particular, Standard is a <em>Horizontal* Integration Framework</em> which integrates <em>vertical*</em> tooling.</p>
<blockquote>
<p><sub>We occasionally adapt concepts from non-technical contexts. This is one instance.</sub></p>
<p><em>Vertical Tooling</em> does one thing and does it well in a narrow scope (i.e "vertical").</p>
<p><em>Horizontal Tooling</em> stitches vertical tooling together to a polished whole.</p>
</blockquote>
<p>What is being integrated are the end-to-end automatable sections of the SDLC.
For these we curate a collection of functionality, tools and best practices.</p>
<p>An SDLCs <em>efficiency</em> is characterized by two things.</p>
<p>Firstly, by adequate <em>lead time</em> which is the amount of time it takes to set up an initial version of the software delivery pipeline.
It needs to be <em>adequate</em> rather than <em>just fast</em>, as it takes place in the context of a team.
Rather than for speed, they need optimization for success.
For example, a process needs to be documented &amp; explained and your team needs to be trained on it.
Standard encourages incremental adoption in order to leave enough space for these paramount activities.
If you're in a hurry and your team is onboard, though, you still can jumpstart its adoption.</p>
<p>Secondly, efficient SDLCs are characterized by short <em>cycle times</em> which is the amount of time it takes for a designed feature to be shipped to production.
Along this journey, we encounter our scope (more on it below):</p>
<ul>
<li>aspects of the <em>development</em> environment;</li>
<li>the packaging pipeline that produces artifacts;</li>
<li>and continuous processes integrating the application lifecycle.</li>
</ul>
<p>Hence, the goal of Standard is to:</p>
<ul>
<li>Enable easy and incremental adoption</li>
<li>Optimize the critical path that reduces your SDLC's cycle time.</li>
</ul>
<p>Additionally, unlike similar projects, we harness the power of Nix &amp; Flakes to ensure reproducibility.</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<ul>
<li><em>Complete</em>: Standard should cover the important use cases for setting up and running the automatable sections of the SDLC.</li>
<li><em>Optimized</em>: Standard should optimize both for the needs of the individual developers and the market success of the product.</li>
<li><em>Integrated</em>: Standard should provide the user with a satisfying integration experience across a well-curated assortment of tools and functionality.</li>
<li><em>Extensible</em>: Standard should account for the need to seamlessly modify, swap or extend its functionality when necessary.</li>
</ul>
<p>Please defer to the <a href="./PITCH.html">sales pitch</a>, if you need more context.</p>
<h2 id="ideals"><a class="header" href="#ideals">Ideals</a></h2>
<p>While we aim to improve the SDLC by applying Nix and its ecoysystem's ingenuity to the problem, we also want to build bridges.
In order to bring the powers of store based reproducible packaging to colleagues and friends, we need to maneuver around the ecosystem's pitfalls:</p>
<ul>
<li><em>Use nix only where it is best suited</em> — a Nix maximalist approach may be an innate condition to some of us, but to build bridges we deeply recognize and value other perspectives and don't dismiss them as ignorance.</li>
<li><em>Disrupt where disruption is necessary</em> — the Nix ecosystem has a fairly rigid set of principles and norms that we don't think always apply in every use case.</li>
<li><em>Look left, right, above and beyond</em> — our end-to-end perspective commands us to actively seek and reach out to other projects and ecosystems to compose our value chain; there's no place for the "not invented here"-syndrome.</li>
</ul>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>These are big goals and ideals.
In the interest of practical advancements, we'll narrow down the scope in this section.</p>
<p>We can subdivide (not break up!) our process into roughly three regions with different shapes and characteristics:</p>
<ul>
<li><strong>Development Environment</strong> roughly covers <em>code-to-commit</em>.</li>
<li><strong>Packaging Pipeline</strong> roughly covers <em>commit-to-distribution</em>.</li>
<li><strong>Deployment and Beyond</strong> roughly covers <em>distribution-to-next-rollout</em>.</li>
</ul>
<p>We delegate:</p>
<ul>
<li>The <strong>Development Environment</strong> to a trusted project in the broader Nix Community employing community outreach to promote our cause and ensure it is at least not accidentally sabotaged.</li>
<li>The <strong>Deployment and Beyond</strong> by cultivating outreach and dovetailing with initiatives of, among others, the Cloud Native ecosystem.</li>
</ul>
<p>And we focus on:</p>
<ul>
<li>The <strong>Packaging Pipeline</strong></li>
<li><em>Interfaces</em> and <em>Integration</em> with the other two</li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>With clarity about Standard's general scope and direction, let's procede to get an overview over its architecture.</p>
<h3 id="locating-standard-in-the-sdlc"><a class="header" href="#locating-standard-in-the-sdlc">Locating Standard in the SDLC</a></h3>
<p>Where is Standard located in the big picture?</p>
<p>This graphic locates Standard across the SDLC &amp; Application Lifecycle Management (ALM).</p>
<p>But not only that.
It also explains how automation in itself is implemented as <em>code</em>, just as the application itself.
Therefore, we make a distinction between:</p>
<ul>
<li>first order application code (L1); and</li>
<li>above that, higher order supporting code as exemplified by L2 and L3.</li>
</ul>
<blockquote>
<p>Glossary:</p>
<p><em>L2 &amp; L3</em> have no clearly defined meaning.
They represent that we may observe multiple layers of higher order code when automating.
Examples could be bash scripts, configuration data, platform utility code and more.</p>
</blockquote>
<div align="center"><img src="./artwork/sdlc.svg" width="900" /></div>
<h3 id="standards-components-and-their-value-contribution"><a class="header" href="#standards-components-and-their-value-contribution">Standard's Components and their Value Contribution</a></h3>
<p>What is Standard made of? And how do its components contribute value?</p>
<p>On the left side of the graphic, we show how Standard, like an onion, is build in layers:</p>
<p>Center to Standard is <a href="https://github.com/paisano-tui/core"><code>divnix/paisano</code></a>.
This flake (i.e. "Nix library") implements two main abstractions: Block Types and Cells.</p>
<p><em><strong>Block Types</strong></em> are not unlike Rust's traits or Golang's interfaces.
They are abstract definitions of artifact classes.
Those abstract classes implement <em>shared functionality</em>.</p>
<p>A few examples of artifact classes in our scope are: packages, containers, scripts and manifests, among others.
Examples of shared functionality are (a shared implementation of) <em>push</em> on containers and (a shared implementation of) <em>build</em> on packages.</p>
<p><em><strong>Cells</strong></em>, in turn, organize your code into related units of functionality.
Hence, Cells are a code <em>orgnization principle</em>.</p>
<p>On top of Paisano's abstractions, Standard implements within its scope:</p>
<ul>
<li>a collection of Block Types; and</li>
<li>a collection of library functionality organized in Cells.</li>
</ul>
<p>On the right side of the graphic, we sketch an idea of how these components are put into service for the SDLC.</p>
<div align="center"><img src="./artwork/components.svg" width="900" /></div>
<h3 id="paisano-code-organization"><a class="header" href="#paisano-code-organization">Paisano (Code Organization)</a></h3>
<p>We already learned about Paisano's two main abstractions: Cells &amp; Block Types.</p>
<p>Cells enable and encourage the user to cleanly organize their code into related units of functionality.
The concrete semantics of code layout are completely at her choosing.
For example, she could separate application tiers like frontend and backend into their own cells, each.
Or she could reflect the microservices architecture in the Cells.</p>
<p>Paisano has a first class concept of Cells.
By simply placing a folder in the repository, Paisano will pick it up.
In that regard, Paisano is an automated importer, that spares the user the need to setup and maintain boilerplate plumbing code.</p>
<p>Within a Cell, the user groups artifacts within Blocks of an appropriate Block Type.
When configuring Standard, she names her Blocks using Standard's Block Types so that Paisano's importer can pick them up, too.
By doing that, she also declares the repository's artifact type system to humans and machines.</p>
<p>Machines can make great use of that to interact with the artifact type system in multiple ways.
Paisano exports structured json-serializable data about a repository's <em>typed</em> artifacts in its so-called "Paisano Registry".
A CLI or TUI, as is bundled with Standard, or even a web user interface can consume, represent and act upon that data.</p>
<p>And so can CI.</p>
<p>In fact, this is an innovation in the SDLC space:
We can devise an implementation of a CI which, by querying Paisano's Registry, autonomously discovers all work that needs to be done.
In order to demonstrate the value of this proposition, we made a reference implementation for GitHub Actions over at <a href="https://github.com/divnix/std-action"><code>divnix/std-action</code></a>.
To our knowledge, this is the first and only "zero config" CI implementation based on the principles of artifact typing and code organization.
By using these principles rather than a rigid opinionated structure, it also remains highly flexible and adapts well to the user's preferences &amp; needs.</p>
<p>In summary, all these organization and typing principles enable:</p>
<ul>
<li>easy refactoring of your repository's devops namespace;</li>
<li>intuitive grouping of functionality that encourages well-defined internal boundaries,
<ul>
<li>allowing for keeping your automation code clean and maintainable;</li>
</ul>
</li>
<li>making use of Block Types and the shared library to implement the DRY principle;</li>
<li>reasoning about the content of your repo through structured data,
<ul>
<li>and, thereby, facilitate interesting user interfaces, such as a CLI, TUI or even a UI,</li>
<li>as well as services like a (close to) zero config, self-updating CI;</li>
</ul>
</li>
<li>similar organizational principles help to lower the cost of context switching between different projects.</li>
</ul>
<h3 id="standards-block-types-devops-type-system"><a class="header" href="#standards-block-types-devops-type-system">Standard's Block Types (DevOps Type System)</a></h3>
<p>As mentioned above, Standard exploits the Block Type abstraction to provide artifact types for the SDLC.
Within the semantics of each Block Type, we implement shared functionality.
This is designed to offer the user an optimized, audited implementation.
Alleviates the burden of devising "yet another" local implementation of otherwise well-understood generic functionality, such as, the building of a package or the pushing of a container image.</p>
<h3 id="standards-cells-function-library"><a class="header" href="#standards-cells-function-library">Standard's Cells (Function Library)</a></h3>
<p>Alongside the <strong>Packaging Pipeline</strong>, Standard provides a curated assortment of library functions and integrations that users can adopt.
While optional, an audited and community maintained function library and its corresponding documentation fulfills the promise of productivity, shared mental models and ease of adoption.</p>
<h2 id="modularity--virality-model"><a class="header" href="#modularity--virality-model">Modularity &amp; Virality Model</a></h2>
<p>We aim to provide a public registry in which we index and aggregate additional Block Types and Cells from the Standard user community that are not maintained in-tree.
To boost its value, aggregate documentation will be part of that registry.
We need to decide on how to deeply integrate documentation concerns, such as structured docstrings &amp; adjacent readmes, into the framework.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-matrix"><a class="header" href="#value-matrix">Value Matrix</a></h1>
<p>This section will explain how Standard intends to create value for different stakeholders.
It is essential to have an idea of who they are, so let's introduce:</p>
<p><strong><em>The Software Sponsor</em></strong>
Makes resources available in return for the expectation of future benefits.</p>
<p><strong><em>The Provider of Automation</em></strong>
Sets up and maintains the automation along the SDLC.
A helpful analogy would be the person who sets up and maintains the conveyor belt which moves features to production.</p>
<p><strong><em>The Consumer of Automation</em></strong>
Consumes and co-maintaines the automation along the SDLC.
A helpful analogy would be that this person not only uses and configures our conveyor belt, but is also capable of occasionally maintaining it.</p>
<p>It is essential to have an understanding of what they value, so let's try to get an overview.
We'll make use of a high level value matrix with simple sentiment scores:</p>
<ul>
<li>😍 → <i>"absolutely love it!!!"</i></li>
<li>😄 → <i>"feels pretty good."</i></li>
<li>😐 → <i>"whatever?!?"</i></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th style="text-align: center">Software Sponsor [Principal]</th><th style="text-align: center">Provider of SDLC Automation [Agent]</th><th style="text-align: center">Consumer of SDLC Automation [Agent]</th></tr></thead><tbody>
<tr><td>Productivity</td><td style="text-align: center">😍</td><td style="text-align: center">😍</td><td style="text-align: center">😄</td></tr>
<tr><td>Code Organization</td><td style="text-align: center">😄</td><td style="text-align: center">😍</td><td style="text-align: center">😄</td></tr>
<tr><td>Mental Model &amp; Learning</td><td style="text-align: center">😄</td><td style="text-align: center">😍</td><td style="text-align: center">😄</td></tr>
<tr><td>Batteries Included</td><td style="text-align: center">😐</td><td style="text-align: center">😍</td><td style="text-align: center">😐</td></tr>
<tr><td>Community and Ecosystem</td><td style="text-align: center">😐</td><td style="text-align: center">😍</td><td style="text-align: center">😄</td></tr>
<tr><td>Reproducibility &amp; Software Supply Chain Security</td><td style="text-align: center">😍</td><td style="text-align: center">😍</td><td style="text-align: center">😐</td></tr>
<tr><td>Modularity &amp; Incremental Adoption</td><td style="text-align: center">😄</td><td style="text-align: center">😄</td><td style="text-align: center">😍</td></tr>
<tr><td>Developer Experience &amp; Onboarding Story</td><td style="text-align: center">😄</td><td style="text-align: center">😄</td><td style="text-align: center">😍</td></tr>
</tbody></table>
</div>
<p>So, this is for you and your team, if you:</p>
<ul>
<li>Care about reproducibility for more reliablility throughout your software development</li>
<li>Value clean code for keeping a check on techincal debt and increased long-term maintainability</li>
<li>Have a deadline to meet with the help of the includes best practices and batteries</li>
<li>Want to serve an optimized UX to your colleagues via a repo CLI / TUI and (close to) zero-config CI</li>
</ul>
<h1 id="selling-points"><a class="header" href="#selling-points">Selling Points</a></h1>
<p>The main selling points of Standard are:</p>
<ul>
<li>
<p><strong>Efficiency:</strong> Standard automates the software delivery lifecycle, making the process more efficient and streamlined.</p>
</li>
<li>
<p><strong>Reproducibility:</strong> Standard's emphasis on reproducibility ensures that every stage of the SDLC can be easily replicated, leading to a more consistent and reliable software development process.</p>
</li>
<li>
<p><strong>Speed:</strong> Standard optimizes the critical path of the SDLC journey to achieve superior cycle times, which means that your software can be shipped to production faster.</p>
</li>
<li>
<p><strong>Flexibility:</strong> Standard is built to be flexible and adaptable, which allows it to be used in a variety of different contexts and industries.</p>
</li>
<li>
<p><strong>Cost-effective:</strong> Automating the software delivery lifecycle with Standard saves time and resources, making it more cost-effective.</p>
</li>
<li>
<p><strong>Integration:</strong> Standard is a horizontal integration framework that integrates vertical tooling, making it easier to stitch together different tools and processes to create a polished whole.</p>
</li>
<li>
<p><strong>Community Outreach:</strong> Standard is a part of the Nix ecosystem and is committed to community outreach to ensure that its optimization targets are met and that other perspectives are not dismissed.</p>
</li>
</ul>
<p>These points show how Standard can help adopters to improve their software delivery process, and how it can save them time, money and improve the quality of their software.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparing-standard-to-x"><a class="header" href="#comparing-standard-to-x">Comparing Standard to X</a></h1>
<p><em>Where appropriate, we compare with <code>divnix/paisano</code>, instead</em>.</p>
<h2 id="comparison-with-tools-in-the-nix-ecosystem"><a class="header" href="#comparison-with-tools-in-the-nix-ecosystem">Comparison with tools in the Nix ecosystem</a></h2>
<h3 id="flake-utils"><a class="header" href="#flake-utils">flake-utils</a></h3>
<p><code>numtide/flake-utils</code> is a small &amp; lightweight utility with a focus on generating flake file <em>outputs</em> in accordance with the packaging and NixOS use cases built into the Nix CLI tooling.</p>
<p>Paisano, in turn, is an importer with a focus on <em>code organization</em>.</p>
<p>Like Flake Utils, it, too, was designed to be used inside the <code>flake.nix</code> file.
However, <code>flake.nix</code> is a repository's prime estate.
And so Paisano was optimized for keeping that estate as clean as possible and, at the same time, beeing a useful table of content even to a relative nix-layman.</p>
<p>While you <em>can</em> use it to match the schema that Nix CLI expects, it also enables more flexibility as it is not specially optimized for any particular use case.</p>
<h3 id="flake-parts"><a class="header" href="#flake-parts">flake-parts</a></h3>
<p><code>hercules-ci/flake-parts</code> is a component aggregator with a focus on a flake schema that is built into the Nix CLI tooling that makes use of the NixOS module system for composability and aggregation.</p>
<p>Paisano, in turn, is an importer with a focus on <em>code organization</em>; it still plugs well into a <code>flake.nix</code> file, but also preserves its index function by keeping it clean.
While you <em>can</em> use it to match the schema that Nix CLI expects, it also enables more flexibility as it is not specially optimized for any particular use case.</p>
<p>To a lesser extent, Paisano is also a component aggregator for your flake outputs.
However, in that role, it gives you back the freedom to use the output schema that best fits your problem domain.</p>
<p>The core tenet of Flake Parts is domain specific interfaces for each use case.
Flake Parts implements and aggregates these interfaces based on the NixOS module system.</p>
<p>Paisano, in turn, focuses on code organization along high level code boundaries connected by generic interfaces.
The core tenet of Paisano remains Nix's original functional style.</p>
<p>Convergence towards the Flakes output schema is provided via the harvester family of utility functions (<code>winnow</code>, <code>harvest</code> &amp; <code>pick</code>).
Depending on the domain schema, it can be a <em>lossy</em> convergence, though, due the lesser expressivity of the flake output schema.</p>
<details>
<summary>Example usage of harvester functions</summary>
<pre><code class="language-nix">{
  inputs = { /* snip */ };
  outputs = { std, self, ...}:
    growOn {
      /* snip */
    }
    {
      devShells = std.harvest self ["automation" "shells"];
      packages = std.harvest self [["std" "cli"] ["std" "packages"]];
      templates = std.pick self ["presets" "templates"];
    };
}
</code></pre>
</details>
<h3 id="devshell"><a class="header" href="#devshell">Devshell</a></h3>
<p>Standard wraps <code>numtide/devshell</code> to improve the developer experience in the early parts of the SDLC via reproducible development shells.</p>
<h2 id="comparison-with-other-tools--frameworks"><a class="header" href="#comparison-with-other-tools--frameworks">Comparison with other tools &amp; frameworks</a></h2>
<h3 id="my-language-build-tool"><a class="header" href="#my-language-build-tool">My language build tool</a></h3>
<p>Nix wraps language level tooling into a sandbox and cross-language build graph to ensure reproducibility.
Most languages are already covered.</p>
<h3 id="bazel"><a class="header" href="#bazel">Bazel</a></h3>
<p>Bazel is similar to Nix in that it creates cross-language build graphs.
However, it does not guarantee reproducibility.
Currently it has more advanced build caching strategies: a gap that the Nix community is very eager to close soon.</p>
<h3 id="my-cicd"><a class="header" href="#my-cicd">My CI/CD</a></h3>
<p>Any CI can leverage Paisano's Registry to discover work.
Implementations can either be native to the CI or provided via CI-specific wrappers, a strategy chosen, for example, by our reference implementation for GitHub Actions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>
<p>The freestyle history of the project was productive during the alpha stage, but as the code stabilizes, so too must our processes.</p>
<p>This roadmap gives an overview of the short and mid term direction that the project aims to take.</p>
<h2 id="deliverable-categories"><a class="header" href="#deliverable-categories">Deliverable Categories</a></h2>
<p>We've identified a couple of deliverable categories in line with the <a href="./ARCHITECTURE.html">architectural overview</a>.</p>
<p>These help us to better understand the work spectrum associated with the project.</p>
<h5 id="process-categories"><a class="header" href="#process-categories">Process Categories</a></h5>
<p>To run <em>automation</em> we have to <em>set it up</em>, first.
We should keep that in mind when working on the backlog and therefore classify:</p>
<ul>
<li>Setup</li>
<li>Automation</li>
</ul>
<p>For setup, besides function libraries, a variety of supporting material is crucial, such as:</p>
<ul>
<li>Documentation &amp; Instructions</li>
<li>Patterns &amp; Shared Mental Models</li>
<li>Quick Start Templates</li>
<li>Onboarding &amp; Learning Content</li>
</ul>
<h5 id="process-regions"><a class="header" href="#process-regions">Process Regions</a></h5>
<p>Per our <a href="./ARCHITECTURE.html">architectural overview</a>, we distinguish these process regions:</p>
<ul>
<li>Development Environment</li>
<li>Build Pipeline</li>
<li>Deployment and Beyond (Application Lifecycle Management)</li>
</ul>
<h5 id="deliverable-types"><a class="header" href="#deliverable-types">Deliverable Types</a></h5>
<ul>
<li>Docs</li>
<li>CLI commands or TUI helpers</li>
<li>Integrations</li>
<li>Library functions</li>
<li>Block Types</li>
<li>Stable interfaces</li>
<li>Community outreach</li>
</ul>
<h2 id="milestone-v1"><a class="header" href="#milestone-v1">Milestone v1</a></h2>
<p>With the above in mind, the <a href="https://github.com/divnix/std/issues">issue backlog</a> will be regularly groomed and prioritized.
This is an aid for the core contributors, but it may also provide the necessary orientation to get new contributors set up.</p>
<p>Welcome!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-walk-in-the-park"><a class="header" href="#a-walk-in-the-park">A walk in the park</a></h1>
<p>This is an excellent tutorial series by Joshua Gilman in the form of The Standard Book.</p>
<p>It is ideal for people with prior Nix and Nix Flakes experience.</p>
<p>They are written in a way that feels like a walk in the park, hence the nickname.</p>
<p>They are also often used to dogfood some new <code>std</code> functionality and document it alongside in a palatable (non-terse) writing style.</p>
<p>Enjoy!</p>
<hr />
<p><a href="https://jmgilman.github.io/std-book/">The Standard Book</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p><a href="https://github.com/divnix/std">Standard</a> features a special project structure
that brings some awesome innovation
to this often overlooked (but important) part of your project.
With the default <strong>Cell Blocks</strong>, an <code>apps.nix</code> file tells <a href="https://github.com/divnix/std">Standard</a>
that we are creating an Application.
<code>flake.nix</code> is in charge
of explicitly defining
the inputs of your project.</p>
<blockquote>
<p><em>Btw, you can can copy * the following files from <a href="https://github.com/divnix/std/tree/main/docs/tutorials/hello-world">here</a>.</em></p>
<p>* <em>don't just clone the <code>std</code> repo: flakes in subfolders don't work that way.</em></p>
</blockquote>
<h4 id="tmpplay-with-stdhello-worldflakenix"><a class="header" href="#tmpplay-with-stdhello-worldflakenix"><code>/tmp/play-with-std/hello-world/flake.nix</code></a></h4>
<pre><code class="language-nix">{
  inputs.std.url = "github:divnix/std";
  inputs.nixpkgs.url = "nixpkgs";

  outputs = {std, ...} @ inputs:
    std.grow {
      inherit inputs;
      cellsFrom = ./cells;
    };
}
</code></pre>
<h4 id="tmpplay-with-stdhello-worldcellshelloappsnix"><a class="header" href="#tmpplay-with-stdhello-worldcellshelloappsnix"><code>/tmp/play-with-std/hello-world/cells/hello/apps.nix</code></a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: {
  default = inputs.nixpkgs.stdenv.mkDerivation rec {
    pname = "hello";
    version = "2.10";
    src = inputs.nixpkgs.fetchurl {
      url = "mirror://gnu/hello/${pname}-${version}.tar.gz";
      sha256 = "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i";
    };
  };
}
</code></pre>
<pre><code class="language-bash">$ cd /tmp/play-with-std/hello-world/
$ git init &amp;&amp; git add . &amp;&amp; git commit -m"nix flakes only can see files under version control"
# fetch `std`
$ nix shell github:divnix/std
$ std //hello/apps/default:run
Hello, world!
</code></pre>
<p>You see? from nothing
to running your first application
in just a few seconds ✨</p>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<p>This example consumes the following defaults or builtins:</p>
<h3 id="default-cellblocksgrow-nix-default-cellblocks"><a class="header" href="#default-cellblocksgrow-nix-default-cellblocks">[Default <code>cellBlocks</code>][grow-nix-default-cellblocks]</a></h3>
<pre><code class="language-nix">{
  cellBlocks ? [
    (blockTypes.functions "library")
    (blockTypes.runnables "apps")
    (blockTypes.installables "packages")
  ],
  ...
} @ args:
</code></pre>
<h3 id="default-systemsgrow-nix-default-systems"><a class="header" href="#default-systemsgrow-nix-default-systems">[Default <code>systems</code>][grow-nix-default-systems]</a></h3>
<pre><code class="language-nix">{
  systems ? [
    "x86_64-linux"
    "aarch64-linux"
    "x86_64-darwin"
    "aarch64-darwin"
  ],
  ...
} @ cfg:
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-moon"><a class="header" href="#hello-moon">Hello Moon</a></h1>
<p><em>A slightly more complete <a href="tutorials/hello-moon/../hello-world">hello world</a> tutorial.</em></p>
<p>This tutorial implements a very typical <code>local</code> Cell and its Cell Blocks for a somewhat bigger project.
It also makes use of more advanced functions of <code>std</code>.
Namely:</p>
<ul>
<li><code>std.growOn</code> instead of <code>std.grow</code></li>
<li><code>std.harvest</code> to provide compatibility layers of "soil"</li>
<li>non-default Cell Block definitions</li>
<li>the input debug facility</li>
</ul>
<p>The terms <em>"Block Type"</em>, <em>"Cell"</em>, <em>"Cell Block"</em>, <em>"Target"</em> and <em>"Action"</em> have special meaning within the context of <code>std</code>.
With these clear definitions, we navigate and communicate the code structure much more easily.
In order to familiarize yourself with them, please have a quick glance at the <a href="tutorials/hello-moon/../../glossary.html">glossary</a>.</p>
<h2 id="file-layout"><a class="header" href="#file-layout">File Layout</a></h2>
<p>Let's start again with a flake:</p>
<h4 id="flakenix"><a class="header" href="#flakenix"><code>./flake.nix</code></a></h4>
<pre><code class="language-nix">{
  inputs.std.url = "github:divnix/std";
  inputs.nixpkgs.url = "nixpkgs";

  outputs = {std, ...} @ inputs:
  /*
  brings std attributes into scope
  namely used here: `growOn`, `harvest` &amp; `blockTypes`
  */
    with std;
    /*
    grows a flake "from cells" on "soil"; see below...
    */
      growOn {
        /*
        we always inherit inputs and expose a deSystemized version
        via {inputs, cell} during import of Cell Blocks.
        */
        inherit inputs;

        /*
        from where to "grow" cells?
        */
        cellsFrom = ./nix;

        /*
        custom Cell Blocks (i.e. "typed outputs")
        */
        cellBlocks = [
          (blockTypes.devshells "shells")
          (blockTypes.nixago "nixago")
        ];

        /*
        This debug facility helps you to explore what attributes are available
        for a given input until you get more familiar with `std`.
        */
        debug = ["inputs" "std"];
      }
      /*

      Soil is an idiom to refer to compatibility layers that are recursively
      merged onto the outputs of the `std.grow` function.

      */
      # Soil ...
      # 1) layer for compat with the nix CLI
      {
        devShells = harvest inputs.self ["local" "shells"];
      }
      # 2) there can be various layers; `growOn` is a variadic function
      {};
}
</code></pre>
<p>This time we specified <code>cellsFrom = ./nix;</code>.
This is gentle so that our colleagues know immediately which files to either look or never look at depending on where they stand.</p>
<p>We also used <code>std.growOn</code> instead of <code>std.grow</code> so that we can add compatibility layers of "soil".</p>
<p>Furthermore, we only defined two Cell Blocks: <code>nixago</code> &amp; <code>devshells</code>. More on them follows...</p>
<h4 id="nixlocal"><a class="header" href="#nixlocal"><code>./nix/local/*</code></a></h4>
<p>Next, we define a <code>local</code> cell.
Each project will have some amount of automation.
This can be repository automation, such as code generation.
Or it can be a CI/CD specification.
In here, we wire up two tools from the Nix ecosystem: <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code></a> &amp; <a href="https://github.com/nix-community/nixago"><code>nix-community/nixago</code></a>.</p>
<blockquote>
<p><em>Please refer to these links to get yourself a quick overview before continuing this tutorial, in case you don't know them, yet.</em></p>
<p>A <em>very</em> short refresher:</p>
<ul>
<li><strong>Nixago</strong>: Template &amp; render repository (dot-)files with nix. <a href="tutorials/hello-moon/../../explain/why-nix.html">Why nix?</a></li>
<li><strong>Devshell</strong>: Friendly &amp; reproducible development shells — the original ™.</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Some semantic background:</strong></p>
<p>Both, Nixago &amp; Devshell are <em>Component Tools</em>.</p>
<p><em>(Vertical) Component Tools</em> are distinct from <em>(Horizontal) Integration Tools</em> — such as <code>std</code> — in that they provide a specific capability in a minimal linux style: <em>"Do one thing and do it well."</em></p>
<p>Integration Tools however combine them into a polished user story and experience.</p>
<p>The Nix ecosystem is very rich in <em>component tools</em>, however only few <em>integration tools</em> exist at the time of writing.</p>
</blockquote>
<h4 id="nixlocalshellsnix"><a class="header" href="#nixlocalshellsnix"><code>./nix/local/shells.nix</code></a></h4>
<p>Let's start with the <code>cell.devshells</code> Cell Block and work our way backwards to the <code>cell.nixago</code> Cell Block below.</p>
<blockquote>
<p><strong>More semantic background:</strong></p>
<p>I could also reference them as <code>inputs.cells.local.devshells</code> &amp; <code>inputs.cells.local.nixago</code>.</p>
<p>But, because we are sticking with the local Cell context, we don't want to confuse the future code reader.
Instead, we gently hint at the locality by just referring them via the <code>cell</code> context.</p>
</blockquote>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  /*
  I usually just find it very handy to alias all things library onto `l`...
  The distinction between `builtins` and `nixpkgs.lib` has little practical
  relevance, in most scenarios.
  */
  l = nixpkgs.lib // builtins;

  /*
  It is good practice to in-scope:
  - inputs by *name*
  - other Cells by their *Cell names*
  - the local Cell Blocks by their *Block names*.

  However, for `std`, we make an exeption and in-scope, despite being an
  input, its primary Cell with the same name as well as the dev lib.
  */
  inherit (inputs) nixpkgs;
  inherit (inputs.std) std lib;
  inherit (cell) nixago;
in
  # we use Standard's mkShell wrapper for its Nixago integration
  l.mapAttrs (_: lib.dev.mkShell) {
    default = {...}: {
      name = "My Devshell";
      # This `nixago` option is a courtesy of the `std` horizontal
      # integration between Devshell and Nixago
      nixago = [
        # off-the-shelve from `std`
        (lib.cfg.conform {data = {inherit (inputs) cells;};})
        lib.cfg.lefthook
        lib.cfg.adrgen
        # modified from the local Cell
        nixago.treefmt
        nixago.editorconfig
        nixago.mdbook
      ];
      # Devshell handily represents `commands` as part of
      # its Message Of The Day (MOTD) or the built-in `menu` command.
      commands = [
        {
          package = nixpkgs.reuse;
          category = "legal";
          /*
          For display, reuse already has both a `pname` &amp; `meta.description`.
          Hence, we don't need to inline these - they are autodetected:

          name = "reuse";
          description = "Reuse is a tool to manage a project's LICENCES";
          */
        }
      ];
      # Always import the `std` default devshellProfile to also install
      # the `std` CLI/TUI into your Devshell.
      imports = [std.devshellProfiles.default];
    };
  }
</code></pre>
<p>The <code>nixago = [];</code> option in this definition is a special integration provided by the <a href="tutorials/hello-moon/../../reference/lib/dev/mkShell.html">Standard's <code>devshell</code>-wrapper (<code>std.lib.mkShell</code>)</a>.</p>
<p><em>This is how <code>std</code> delivers on its promise of being a (horizontal) integration tool that wraps (vertical) component tools into a polished user story and experience.</em></p>
<p>Because we made use of <code>std.harvest</code> in the flake, you now can actually test out the devshell via the Nix CLI compat layer by just running <code>nix develop -c "$SHELL"</code> in the directory of the flake.
For a more elegant method of entering a development shell read on the <a href="tutorials/hello-moon/index.html#direnv">direnv</a> section below.</p>
<h4 id="nixlocalnixagonix"><a class="header" href="#nixlocalnixagonix"><code>./nix/local/nixago.nix</code></a></h4>
<p>As we have seen above, the <code>nixago</code> option in the <code>cell.devshells</code> Cell Block references Targets from both <code>lib.cfg</code>.
While you can explore <code>lib.cfg</code> <a href="https://github.com/divnix/std/blob/main/cells/lib/cfg.nix">here</a>, let's now have a closer look at <code>cell.nixago</code>:</p>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
  inherit (inputs.std) lib;
  /*
  While these are strictly specializations of the available
  Nixago Pebbles at `lib.cfg.*`, it would be entirely
  possible to define a completely new pebble inline
  */
in {
  /*
  treefmt: https://github.com/numtide/treefmt
  */
  treefmt = lib.cfg.treefmt {
    # we use the data attribute to modify the
    # target data structure via a simple data overlay
    # (`divnix/data-merge` / `std.dmerge`) mechanism.
    data.formatter.go = {
      command = "gofmt";
      options = ["-w"];
      includes = ["*.go"];
    };
    # for the `std.lib.dev.mkShell` integration with nixago,
    # we also hint which packages should be made available
    # in the environment for this "Nixago Pebble"
    packages = [nixpkgs.go];
  };

  /*
  editorconfig: https://editorconfig.org/
  */
  editorconfig = lib.cfg.editorconfig {
    data = {
      # the actual target data structure depends on the
      # Nixago Pebble, and ultimately, on the tool to configure
      "*.xcf" = {
        charset = "unset";
        end_of_line = "unset";
        insert_final_newline = "unset";
        trim_trailing_whitespace = "unset";
        indent_style = "unset";
        indent_size = "unset";
      };
      "{*.go,go.mod}" = {
        indent_style = "tab";
        indent_size = 4;
      };
    };
  };

  /*
  mdbook: https://rust-lang.github.io/mdBook
  */
  mdbook = lib.cfg.mdbook {
    data = {
      book.title = "The Standard Book";
    };
  };
}
</code></pre>
<p>In this Cell Block, we have been modifying some built-in convenience <code>lib.cfg.*</code> pebbles.
The way <code>data</code> is merged upon the existing pebble is via a simple left-hand-side/right-hand-side <code>data-merge</code> (<code>std.dmerge</code>).</p>
<blockquote>
<p><strong>Background on array merge strategies:</strong></p>
<p>If you know how a plain data-merge (does not magically) deal with array merge semantics, you noticed:
We didn't have to annotate our right-hand-side arrays in this example because we where not actually amending or modifying any left-hand-side array type data structure.</p>
<p>Would we have done so, we would have had to annotate:</p>
<ul>
<li>either with <code>std.dmerge.append [/* ... */]</code>;</li>
<li>or with <code>std.dmerge.update [ idx ] [/* ... */]</code>.</li>
</ul>
<p>But lucky us (this time)!</p>
</blockquote>
<h2 id="command-line-synthesis"><a class="header" href="#command-line-synthesis">Command Line Synthesis</a></h2>
<p>With this configuration in place, you have a couple of options on the command line.
Note, that you can access any <code>std</code> cli invocation also via the <code>std</code> TUI by just typing <code>std</code>.
Just in case you forgot exactly how to access one of these repository capabilities.</p>
<blockquote>
<p><strong>Debug Facility:</strong></p>
<p>Since the debug facility is enabled, you will see some trace output while running these commands.
To switch this off, just comment the <code>debug = [ /* ... */ ];</code> attribute in the flake.</p>
<p>It looks something like this:</p>
<pre><code class="language-nix">trace: inputs on x86_64-linux
trace: {
  cells = {…};
  nixpkgs = {…};
  self = {…};
  std = {…};
}
</code></pre>
</blockquote>
<p><strong>Invoke devshell via <code>nix</code></strong></p>
<pre><code class="language-bash">nix develop -c "$SHELL"
</code></pre>
<p>By quirks of the Nix CLI, if you don't specify <code>-c "$SHELL"</code>, you'll be thrown into an unfamiliar bare <code>bash</code> interactive shell.
That's not what you want.</p>
<p><strong>Invoke the devshell via <code>std</code></strong></p>
<p>In this case, invoking <code>$SHELL</code> correctly is taken care for you by the Block Type's <code>enter</code> Action.</p>
<pre><code class="language-bash"># fetch `std`
$ nix shell github:divnix/std
$ std //local/devshells/default:enter
</code></pre>
<p>Since we have declared the devshell Cell Block as a <code>blockTypes.devshells</code>, <code>std</code> augments it's Targets with the Block Type Actions.</p>
<p>See <a href="tutorials/hello-moon/../../reference/blocktypes/devshells-blocktype.html"><code>blockTypes.devshells</code></a> for more details on the available Actions and their implementation.</p>
<p>Thanks to the <code>cell.devshells</code>' <code>nixago</code> option, entering the devshell will also automatically reconcile the repository files under Nixago's management.</p>
<p><strong>Explore a Nixago Pebble via <code>std</code></strong></p>
<p>You can also explore the nixago configuration via the Nixago Block Type's <code>explore</code>-Action.</p>
<pre><code class="language-bash"># fetch `std`
$ nix shell github:divnix/std
$ std //local/nixago/treefmt:explore
</code></pre>
<p>See <a href="tutorials/hello-moon/../../reference/blocktypess/nixago-blocktype.html"><code>blockTypes.nixago</code></a> for more details on the available Actions and their implementation.</p>
<h2 id="direnv"><a class="header" href="#direnv">direnv</a></h2>
<p>Manually entering the devshell is boring.
How about a daemon always does that automatically &amp; efficiently when you <code>cd</code> into a project directory?
Enter <a href="https://direnv.net"><code>direnv</code></a> — the original (again; and even from the same author) 😊.</p>
<p>Before you continue, first install direnv according to it's <a href="https://direnv.net/docs/installation.html">install instructions</a>.
It's super simple &amp; super useful ™ and you should do it <em>right now</em> if you haven't yet.</p>
<p>Please learn how to enable <code>direnv</code> in this project by following the <a href="tutorials/hello-moon/../../guides/envrc.html">direnv how-to</a>.</p>
<p>In this case, you would adapt the relevant line to: <strong><code>use std nix //local/shells:default</code></strong>.</p>
<p>Now, you can simply <code>cd</code> into that directory, and the devshells is being loaded.
The MOTD will be shown, too.</p>
<p>The first time, you need to teach the <code>direnv</code> daemon to trust the <code>.envrc</code> file via <code>direnv allow</code>.
If you want to reload the devshell (e.g. to reconcile Nixago Pebbles), you can just run <code>direnv reload</code>.</p>
<p>Because I use these commands so often, I've set: <code>alias d="direnv"</code> in my shell's RC file.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="growing-cells"><a class="header" href="#growing-cells">Growing Cells</a></h1>
<p>Growing cells can be done via two variants:</p>
<ul>
<li><code>std.grow { cellsFrom = "..."; /* ... */ }</code></li>
<li><code>std.growOn { cellsFrom = "..."; /* ... */ } # soil</code></li>
</ul>
<h2 id="stdgrowon---soil"><a class="header" href="#stdgrowon---soil"><code>std.growOn {} # soil</code></a></h2>
<p>This eases talking and reasoning about a <code>std</code>ized repository, that also needs
some sort of adapters to work together better with external frameworks.</p>
<p>Typically, you'd arrange those adapters in numbered layers of soil, just
so that it's easier to conceptually reference them when talking / chatting.</p>
<p>It's a variadic function and takes an unlimited number of "soil layers".</p>
<pre><code class="language-nix">{
  inputs.std.url = "github:divnix/std";

  outputs = {std, ...} @ inputs:
    std.growOn {
      inherit inputs;
      cellsFrom = ./cells;
    }
    # soil
    () # first layer
    () # second layer
    () # ... nth layer
    ;
}
</code></pre>
<p>These layers get recursively merged onto the output of <code>std.grow</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="include-filter"><a class="header" href="#include-filter">Include Filter</a></h1>
<p>It is very common that you want to filter your source code in order
to avoid unnecessary rebuilds and increase your cache hits.</p>
<p>This is so common that <code>std</code> includes a tool for this:</p>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
  inherit (inputs) std;
in {
  backend = nixpkgs.mkYarnPackage {
    name = "backend";
    src = std.incl (inputs.self + /src/backend) [
      (inputs.self + /src/backend/app.js)
      (inputs.self + /src/backend/config/config.js)
      /* ... */
    ];
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-envrc"><a class="header" href="#setup-envrc">Setup <code>.envrc</code></a></h1>
<p>Standard provides an extension to the <code>stdlib</code> via <code>direnv_lib.sh</code>.</p>
<p>The integrity hash below ensures it is downloaded only once and cached
from there on.</p>
<pre><code class="language-bash">#!/bin/sh

# first time
if [[ ! -d $(nix store add-path --name source --dry-run .) ]]; then
  nix store add-path --name source .
  (cd ./src/local &amp;&amp; nix flake lock --update-input std)
  (cd ./src/tests &amp;&amp; nix flake lock --update-input std)
fi

# shellcheck disable=SC1090
. "$(fetchurl "https://raw.githubusercontent.com/paisano-nix/direnv/main/lib" "sha256-IgQhKK7UHL1AfCUntJO2KCaIDJQotRnK2qC4Daxk+wI=")"

use envreload //local/shells/default //local/configs
</code></pre>
<blockquote>
<p><strong>NOTE:</strong>
In the above code <code>use std</code> <strong><code>cells</code></strong> <code>//std/...</code> refers to the
folder where <strong>Cells</strong> are grown from. If your folder is e.g. <code>nix</code>, adapt
to <code>use std</code> <strong><code>nix</code></strong> <code>//...</code> and so forth.</p>
</blockquote>
<p>It is used to automatically set up file watches on files that could modify the
current devshell, discoverable through these or similar logs during loading:</p>
<pre><code class="language-console">direnv: loading https://raw.githubusercontent.com/divnix/std/...
direnv: using std cells //local/shells:default
direnv: Watching: cells/local/shells.nix
direnv: Watching: cells/local/shells (recursively)
</code></pre>
<p>For reference, the above example loads the <code>default</code> devshell from:</p>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs namaka;
  inherit (inputs.nixpkgs.lib) mapAttrs optionals;
  inherit (inputs.std) std;
  inherit (inputs.std.lib.dev) mkShell;
  inherit (cell) configs;
in
  mapAttrs (_: mkShell) rec {
    default = {...}: {
      name = "Standard";
      nixago = [
        configs.conform
        configs.treefmt
        configs.editorconfig
        configs.githubsettings
        configs.lefthook
        configs.adrgen
        configs.cog
      ];
      commands =
        [
          {
            package = nixpkgs.reuse;
            category = "legal";
          }
          {
            package = nixpkgs.delve;
            category = "cli-dev";
            name = "dlv";
          }
          {
            package = nixpkgs.go;
            category = "cli-dev";
          }
          {
            package = nixpkgs.gotools;
            category = "cli-dev";
          }
          {
            package = nixpkgs.gopls;
            category = "cli-dev";
          }
          {
            package = namaka.packages.default;
            category = "nix-testing";
          }
        ]
        ++ optionals nixpkgs.stdenv.isLinux [
          {
            package = nixpkgs.golangci-lint;
            category = "cli-dev";
          }
        ];
      imports = [std.devshellProfiles.default book];
    };

    book = {...}: {
      nixago = [configs.mdbook];
    };
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-nix"><a class="header" href="#why-nix">Why <code>nix</code>?</a></h1>
<p>A lot of people write a lot of confusing stuff about nix.</p>
<p>So here, we'll try to break it down, instead.</p>
<h2 id="nix-is-json-on-steroids"><a class="header" href="#nix-is-json-on-steroids"><code>nix</code> is "<code>json</code> on steroids"</a></h2>
<p>In configuration management, you have a choice: data vs. language.</p>
<p>On stackoverflow, you'll be taught the "data" stance, because it's simple.</p>
<p>And all of a sudden you hit reality. Outside of a "lab" environment, you suddenly
need to manage a varying degree of complexity.</p>
<p>So you need configuration combinators, or in other words a full blown language
to efficiently render your configurations.</p>
<p>There are a couple of options, that you'll recognize if you've gotten serious about
the configuration challenge, like:</p>
<ul>
<li><a href="https://dhall-lang.org/"><code>dhall</code></a></li>
<li><a href="https://cuelang.org/"><code>cue</code></a></li>
<li><a href="https://jsonnet.org/"><code>jsonnet</code></a></li>
<li><a href="https://nickel-lang.org/"><code>nickel</code></a></li>
</ul>
<p>And there is <a href="https://nixos.org/"><code>nix</code></a>, the language. In most aspects, it isn't hugely distinct from the others,
but it has superpowers. Read on!</p>
<h2 id="nix-superpowers"><a class="header" href="#nix-superpowers"><code>nix</code>' superpowers</a></h2>
<p>You know the concept of string interpolation.</p>
<p>Every time <code>nix</code> interpolates an identifier, there is something that
you don't immediately see: it keeps a so called "string context" right
at the site of interpolation. That string context holds a directed acyclic
graph of all the dependencies that are required to make that string.</p>
<p>"Well, it's just a string; what on earth should I need to make a string?", you may say.</p>
<p>There is a special category of strings, so called "Nix store paths"
(strings that start with <code>/nix/store/...</code>). These store paths represent
build artifacts that are content addressed ahead-of-time through
the inputs of an otherwise pure build function, called <a href="https://nixos.org/manual/nix/stable/expressions/derivations.html"><code>derivation</code></a>.</p>
<p>When you finally reify (i.e. "build") your string interpolation, then all these Nix store
paths get build as well.</p>
<p>This might be a bit of a mind-boggling angle, but after a while, you may realize:</p>
<ul>
<li>Nix is a massive build pipeline that tracks all things to their source.</li>
<li>In their capacity as <em>pure</em> build functions, <a href="https://nixos.org/manual/nix/stable/expressions/derivations.html"><code>derviation</code>s</a> build <em>reproducibly</em>.</li>
<li>Reproducible builds are the future of software supply chain security, among other things.</li>
<li>You'll start asking: "who the heck invented all that insecure nonsense of opaque binary registries?
Shouldn't have those smart people have known better?"</li>
<li>And from this realization, there's no coming back.</li>
<li>And you'll have joined the <a href="https://discourse.nixos.org/t/nixos-foundation-participating-in-eus-next-generation-internet-initiative/2011">European Union</a>, <a href="https://discourse.nixos.org/t/mercury-bank-nix-engineers/13784">banks</a> and <a href="https://github.com/input-output-hk/cardano-world">blockchain companies</a> who also realized:
we need to fix our utterly broken and insecure build systems!</li>
<li>By that time, you'll have already assimilated the legendary <a href="http://users.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf">Ken Thompson's "Reflections on Trusting Trust"</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-std"><a class="header" href="#why-std">Why std?</a></h1>
<h2 id="problem"><a class="header" href="#problem">Problem</a></h2>
<p>Nix is marvel to ones and cruelty to others.</p>
<p>Much of this professional schism is due to two fundamental issues:</p>
<ul>
<li>Nix is a functional language without typing</li>
<li>Therefore, Nix-enthusiast seem to freaking love writing the most elegant and novel boilerplate all over again the next day.</li>
</ul>
<p>The amount of domain specific knowledge required to untangle those most elegant and novel boilerplate patterns prevent
the other side of the schism, very understandably, to see through the smoke the true beauty and benefits of <code>nix</code> as a
build and configuration language.</p>
<p>Lack of typing adds to the problem by forcing <code>nix</code>-practitioners to go out of their way (e.g. via <a href="https://github.com/divnix/yants"><code>divnix/yants</code></a>) to
add some internal boundaries and contracts to an ever morphing global context.</p>
<p>As a consequence, few actually <em>do</em> that. And contracts across internal code boundaries are either absent or rudimentary or — yet again —
"elegant and novel". Neither of which satisfactorily settles the issue.</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p><code>std</code> doesn't add language-level typing. But a well-balanced folder layout cut at 3 layers of conceptual
nesting provides the fundamentals for establishing internal boundaries.</p>
<blockquote>
<p><strong>Cell → Cell Block → Target → [Action]</strong></p>
<p>Where ...</p>
<ul>
<li><strong>Cells</strong> group functionality.</li>
<li><strong>Cell Blocks</strong> type outputs and implement <strong>Actions</strong>.</li>
<li><strong>Targets</strong> name outputs.</li>
</ul>
</blockquote>
<p>Programmers are really good at pattern-abstraction when looking at two similar but slightly
different things: <em><strong>Cells</strong> and <strong>Cell Blocks</strong> set the stage for code readability.</em></p>
<p><strong>Cell Blocks</strong> only allow one possible interface: <code>{inputs, cell}</code>:</p>
<ul>
<li><code>cell</code> the local <strong>Cell</strong>, promoting separation of concern</li>
<li><code>inputs</code> the <code>deSystemize</code>ed flake inputs — plus:
<ul>
<li><code>inputs.self = self.sourceInfo;</code> reference source code in <code>nix</code>; filter with <code>std.incl</code>; don't misuse the global <code>self</code>.</li>
<li><code>inputs.cells</code>: the other cells by name; code that documents its boundaries.</li>
<li><code>inputs.nixpkgs</code>: an <em>instantiated</em> <code>nixpkgs</code> for the current system;</li>
</ul>
</li>
</ul>
<p>Now, we have <em>organized</em> <code>nix</code> code. Still, <code>nix</code> is not for everybody.
And for everybody else the <code>std</code> TUI/CLI companion answers a single question to perfection:</p>
<blockquote>
<p><strong>The GitOps Question:</strong></p>
<center><i>What can I actually <b>do</b> with this <code>std</code>-ized repository?</i></center>
&emsp;
</blockquote>
<blockquote>
<p><strong>The Standard Answer:</strong></p>
<center><i><code>std</code> breaks down GitOps into a single UX-optimized TUI/CLI entrypoint.</i></center>
&emsp;
</blockquote>
<h2 id="benefit"><a class="header" href="#benefit">Benefit</a></h2>
<p>Not everybody is going to love <code>nix</code> now.</p>
<p>But the ones, who know its secrets, now have an effective tool
to more empathically spark the joy.</p>
<p>Or simply: 💔 → 🧙 → 🔧 → ✨→ 🏖️</p>
<p>The smallest common denominator, in any case:</p>
<blockquote>
<p>Only ever install a single dependency (<code>nix</code>) and reach <em>any</em> repository target. Reproducibly.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-decision-record"><a class="header" href="#architecture-decision-record">Architecture Decision Record</a></h1>
<p>An architecture decision record (ADR) is a document that captures an
important architectural decision made along with its context and consequences.</p>
<p>The <a href="explain/architecture-decision-records/template.html">template</a> has all the info.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To interact with this ADR, enter the devshell and interact though the <code>adrgen</code> tool.</p>
<hr />
<h1 id="1-adopt-semi-conventional-file-locations"><a class="header" href="#1-adopt-semi-conventional-file-locations">1. Adopt semi-conventional file locations</a></h1>
<p>Date: 2022-03-01</p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>accepted</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Repository navigation is among the first activities to build a mental model of any given repository.
The Nix Ecosystem has come up with some weak conventions: these are variations that are mainly informed by the <code>nixpkgs</code> repository, itself.
Despite that, users find it difficult to quickly "wrap their head" around a new project.
This is often times a result of an organically grown file organization that has trouble keeping up with growing project semantics.
As a result, onboading onto a "new" nix project even within the same organizational context, sometimes can be a very frustrating and time-consuming activity.</p>
<h2 id="decision"><a class="header" href="#decision">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>A semi-conventional folder structure shall be adopted.</p>
<p>That folder structure shall have an abstract organization concept.</p>
<p>At the same time, it shall leave the user maximum freedom of semantics and naming.</p>
<p>Hence, 3 levels of organization are adopted.
These levels correspond to the abstract organizational concepts of:</p>
<ul>
<li>consistent collection of functionality ("what makes sense to group together?")</li>
<li>repository output type ("what types of gitops artifacts are produced?")</li>
<li>named outputs ("what are the actual outputs?")</li>
</ul>
<h2 id="consequences"><a class="header" href="#consequences">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>With this design and despite complete freedom of concrete semantics, a prototypical mental model can be reused across different projects.</p>
<p>That same prototypical mental model also speeds up scaffolding of new content and code.</p>
<p>At the expense of nested folders, it may still be further expanded, if additional organization is required.
All the while that the primary meta-information about a project is properly communicated through these first three levels via the file system api, itself (think <code>ls</code> / <code>rg</code> / <code>fd</code>).</p>
<p>On the other hand, this rigidity is sometimes overkill and users may resort to filler names such as "<code>default</code>", because a given semantic only produces singletons.
This is acceptable, however, because this parallellity in addressing even these singleton values trades for very easy expansion or refactoring, as the meta-models of code organization already align.</p>
<hr />
<h1 id="2-restrict-the-calling-interface"><a class="header" href="#2-restrict-the-calling-interface">2. Restrict the calling interface</a></h1>
<p>Date: 2022-03-01</p>
<h2 id="status-1"><a class="header" href="#status-1">Status</a></h2>
<p>accepted</p>
<h2 id="context-1"><a class="header" href="#context-1">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>The Nix Ecosystem has optimized for contributor efficiency at the expense of local code readibility and local reasoning.
Over time, the <code>callPackage</code> idiom was developed that destructures arbitrary attributes of an 80k <em>upstream</em> attributeset provided by <code>nixpkgs</code>.
A complicating side condition is added, where overlays modify that original upstream packages set in arbitrary ways.
This is not a problem for people, who know nixpkgs by heart and it is not a problem for the author either.
It is a problem for the future code reader, Nix expert or less so, who needs to grasp the essence of "what's going on" under a productivity side condition.</p>
<p>Local reasoning is a tried and tested strategy to help mitigate those issues.</p>
<p>In a variant of this problem, we observe only somewhat convergent, but still largely diverging styles of passing arguments in general across the repository context.</p>
<h2 id="decision-1"><a class="header" href="#decision-1">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Encourage local reasoning by always fully qualifing identifiers within the scope of a single file.</p>
<p>In order to do so, the entry level nix files of this framework have exactly one possible interface: <code>{inputs, cell}</code>.</p>
<p><code>inputs</code> represent the global inputs, whereas <code>cell</code> keeps reference to the local context.
<em>A Cell is the first ordering priciple for "consistent collection of functionality".</em></p>
<h2 id="consequences-1"><a class="header" href="#consequences-1">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>This restricts up to the prescribed 3 layers of organization the notion of "how files can communicate with each other".</p>
<p>That inter-files-interface is the <em>only</em> global context to really grasp, and it is structurally aligned across all Standard projects.</p>
<p>By virtue of this meta model of a global context and inter-file-communications, for a somewhat familiarized code reader the barriers to local reasoning are greatly reduced.</p>
<p>The two context references are well known (flake inputs &amp; cell-local blocks) and easily discoverable.</p>
<p>For authors, this schema takes away any delay that might arise out of the consideration of how to best structure that inter-file-communication schema.</p>
<p>Out of experience, a significant and low value (and ad-hoc) design process can be leap-frogged via this guidance.</p>
<hr />
<h1 id="3-hide-system-for-mortals"><a class="header" href="#3-hide-system-for-mortals">3. Hide system for mortals</a></h1>
<p>Date: 2022-04-01</p>
<h2 id="status-2"><a class="header" href="#status-2">Status</a></h2>
<p>accepted</p>
<h2 id="context-2"><a class="header" href="#context-2">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>In the context of DevOps (Standard is a DevOps framework), cross compilation is a significatly lesser concern, than what it is for packagers.</p>
<p>The pervasive use of <code>system</code> in the current Nix (and foremost Flakes) Ecosystem is an optimization (and in part education) choice for these packagers.</p>
<p>However, in the context of DevOps, while not being irrelevant, it accounts for a fair share of distraction potential.</p>
<p>This ultimately diminishes code-readibility and reasoning; and consequentially adoption. Especially in those code paths, where <code>system</code> is a secondary concern.</p>
<h2 id="decision-2"><a class="header" href="#decision-2">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>De-systemize everything to the "current" system and effectively hiding the explict manipulation from plain sight in most cases.</p>
<p>An attribute set, that differentiates for systems on any given level of its tree, is <code>deSystemized</code>.</p>
<p>This means that all child attributes of the "current" system are lifted onto the "system"-level as siblings to the system attributes.</p>
<p>That also means, if explicit reference to <code>system</code> is necessary, it is still there among the siblings.</p>
<p>The "current" system is brought into scope automatically, however.</p>
<p>What "current" means, is an early selector ("select early and forget"), usually determined by the user's operating system.</p>
<h2 id="consequences-2"><a class="header" href="#consequences-2">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>The explicit handling of <code>system</code> in foreign contexts, where <code>system</code> is not a primary concern is largely eliminated.</p>
<p>This makes using this framework a little easier for everybody, including packaging experts.</p>
<p>Since <code>nixpkgs</code>, itself, exposes <code>nixpkgs.system</code> and packaging without <code>nixpkgs</code> is hardly imaginably, power-users still enjoy easy access to the "current" system, in case it's needed.</p>
<hr />
<h1 id="4-early-select-system-for-conceptual-untangling"><a class="header" href="#4-early-select-system-for-conceptual-untangling">4. Early select system for conceptual untangling</a></h1>
<p>Date: 2022-04-01</p>
<h2 id="status-3"><a class="header" href="#status-3">Status</a></h2>
<p>accepted</p>
<h2 id="context-3"><a class="header" href="#context-3">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Building on the previous ADR, we saw why we hide <code>system</code> from plain sight.</p>
<p>In that ADR, we mention "select early and forget" as a strategy to scope the current system consistently across the project.</p>
<p>The current best practices for flakes postulate <code>system</code> as the second level selector of an output attribute.</p>
<p>For current flakes, type primes over system.</p>
<p>However, this design choice makes the lema "select early and forget" across multiple code-paths a pain to work with.</p>
<p>This handling is exacerbated by the distinction between "systemized" and "non-systemized" (e.g. <code>lib</code>) output attributes.</p>
<p>In the overall set of optimization goals of this framework, this distinction is of extraordinarily poor value, more so, that function
calls are memoized during a single evaluation, which renders the system selector computationally irrelevant where not used.</p>
<h2 id="decision-3"><a class="header" href="#decision-3">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<ul>
<li>Move the <code>system</code> selector from the second level to the first level.</li>
<li>Apply the <code>system</code> selector regardless and without exception.</li>
</ul>
<h2 id="consequences-3"><a class="header" href="#consequences-3">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>The motto "select early and forget" makes various code-paths easier to reason about and maintain.</p>
<p>The Nix CLI completion won't respond gracefully to these changes.
However, the Nix CLI is explicitly <em>not</em> a primary target of this framework.
The reason for this is that the use cases for the Nix CLI are somewhat skewed towards the packager use case, but in any case are (currently) not purpose built for the DevOps use case.</p>
<p>A simple patch to the Nix binary, can mitigate this for people whose muscle memory prefers the Nix CLI regardless.
If you've already got that level of muscle memory, its meandering scope is probably anyways not an issue for you anymore.</p>
<hr />
<h1 id="5-nixpkgs-is-still-special-but-not-too-much"><a class="header" href="#5-nixpkgs-is-still-special-but-not-too-much">5. Nixpkgs is still special, but not too much</a></h1>
<p>Date: 2022-05-01</p>
<h2 id="status-4"><a class="header" href="#status-4">Status</a></h2>
<p>accepted</p>
<h2 id="context-4"><a class="header" href="#context-4">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>In general, Standard wouldn't treat any intput as special.
However, no project that requires source distributions of one of the 80k+ packages available in <code>nixpkgs</code> can practically do without it.</p>
<p>Now, <code>nixpkgs</code> has this weird and counter-intuitive mouthful of <code>legacyPackages</code>, which was originally intended to ring an alarm bell and, for the non-nix-historians, still does.</p>
<p>Also, not very many other package collections adopt this idiom which makes it pretty much a singularity of the Nix package collection (<code>nixpkgs</code>).</p>
<h2 id="decision-4"><a class="header" href="#decision-4">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>If <code>inputs.nixpkgs</code> is provided, in-scope <code>legacyPackages</code> onto <code>inputs.nixpkgs</code>, directly.</p>
<h2 id="consequences-4"><a class="header" href="#consequences-4">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Users of Standard access packages as <code>nixpkgs.&lt;package-name&gt;</code>.</p>
<p>Users that want to interact with nixos, do so by loading <code>nixos = import (inputs.nixpkgs + "/nixos");</code> or similar.
The close coupling of the Nix Package Collection and NixOS now is broken.
This suites well the DevOps use case, which is not <em>primarily</em> concerned with the unseparable union of the Nix Packages Collection and NixOS.
It rather presents a plethora of use cases that content with the Nix Package Collection, alone, and where NixOS would present as a distraction.
Now, this separation is more <em>explicit</em>.</p>
<p>As another consequence of not treating <code>nixpkgs</code> (or even the packaging use case) special is that Standard does not implement primary support for <code>overlays</code>.</p>
<hr />
<h1 id="6-avoid-fix-point-logic-such-as-overlays"><a class="header" href="#6-avoid-fix-point-logic-such-as-overlays">6. Avoid fix-point logic, such as overlays</a></h1>
<p>Date: 2022-05-01</p>
<h2 id="status-5"><a class="header" href="#status-5">Status</a></h2>
<p>accepted</p>
<h2 id="context-5"><a class="header" href="#context-5">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Fix point logic is marvelously magic and also very practical.
A lot of people love the concept of <code>nixpkgs</code>'s <code>overlays</code>.</p>
<p>However, we've all been suckers in the early days, and fix point logic wasn't probably one of the concepts that we grasped intuitivly and right at the beginning of our Nix journey.</p>
<p>The concept of recursivity all in itself is already demanding to reason about, where the concept of recourse-until-not-more-possible is even more mind-boggling.</p>
<p>Fix points are also clear instances of overloading global context.</p>
<p>And global context is a double edged sword between high-productivity for that one who has a good mental model of it and nightmare for that one who has to resort to local reasoning.</p>
<h2 id="decision-5"><a class="header" href="#decision-5">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>In the interest of balancing productivity (for the veteran) and ease-of-onboarding (for the novice), we do not implement a prime support for fix-point logic, such as <code>overlays</code> at the framework level.</p>
<h2 id="consequences-5"><a class="header" href="#consequences-5">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Users who depend on it, need to scope its use to a particular Cell Block.
For the Nix package collection, users can do, for example: <code>nixpkgs.appendOverlays [ /* ... */ ]</code>.
There is a small penalty in evaluating <code>nixpkgs</code> a second time, since every moving of the fix point retriggers a complete evalutation.
But since this decision is made in the interest of <em>balancing</em> enacting trade-offs, this appears to be cost-effective in accordance with the overall optimization goals of Standard.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><em>Beware: This is an opinionated pattern.</em></p>
<p><em>However, it helps to structure collaboration on micro-services with Standard.</em></p>
</blockquote>
<h1 id="the-4-layers-of-packaging"><a class="header" href="#the-4-layers-of-packaging">The 4 Layers of Packaging</a></h1>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>We have coded our application and now we want to package and run it.</p>
<p>So, let's just dockerfile the application, dockercompose it into a running thing and celebrate with pizza and beer.</p>
<p>But not so fast!</p>
<p>The statistics about supply chain attacks are alarming. Here are some references:</p>
<ul>
<li>Argon, an Aqua Security company, has found that software supply chain attacks grew by <a href="https://www.helpnetsecurity.com/2022/01/20/software-supply-chain-attacks-2021/">over 300% in 2021</a>.</li>
<li><a href="https://apiiro.com/blog/gartner-continues-the-push-for-software-supply-chain-security/">Gartner predicts</a> that by 2025, 45% of organizations would have experienced a software supply chain attack.</li>
<li>The <a href="https://fortune.com/2021/09/03/fbi-warns-of-ransomware-attacks-labor-day-2021/#:~:text=As%20of%20July%2031%2C%20the,same%20time%20frame%20in%202020.">FBI has reported</a> a 62% increase in ransomware attacks from 2020 to 2021.</li>
<li>A <a href="https://www.darkreading.com/application-security/6-eye-opening-statistics-about-software-supply-chain-security?slide=3">Cloudbees survey</a> showed that 45% of enterprises have admitted that they’ve secured only half of their software supply chain.</li>
</ul>
<p>So is the party over, before it even started?</p>
<p>Aggregating articles from <a href="https://learn.microsoft.com/en-us/microsoft-365/security/intelligence/supply-chain-malware?view=o365-worldwide#types-of-supply-chain-attacks">Microsoft</a> and <a href="https://arstechnica.com/gadgets/2021/03/more-top-tier-companies-targeted-by-new-type-of-potentially-serious-attack/">ArsTechnica</a>, we can find three broad doors of entry for supply chain attacks:</p>
<ul>
<li>Compromised build tools or update infrastructure</li>
<li>Compromised dependencies through well (i.e. source) or cache (i.e. binary) poisoning</li>
<li>Compromised identity signing a malicious app to bypass certificate-backed provenance checks</li>
</ul>
<p>In this pattern piece, we employ a 20 year old, unique approach to packaging to shut close some of these doors of entry.
This battle-tested approach denies a supply chain attacker their ability to compromise build tools and update infrastructure or to poison a cache.
Alongside, we explore ways how teams can structure their collaboration on packaging a micro-service architecture with that technology.</p>
<h2 id="the-team"><a class="header" href="#the-team">The Team</a></h2>
<h3 id="operator"><a class="header" href="#operator">Operator</a></h3>
<p>The operator brings the application to production.</p>
<p>Production is a place, where she cannot allow an attacker to gain access to.</p>
<p>Therefore,</p>
<ul>
<li>she clears and protects the perimeter via "perimeter security" tactics,</li>
<li>she secures transport via "zero trust",</li>
<li>she encrypts secrets at rest and in flight,</li>
<li>but, what if the very artifact that is being deployed is a trojan horse?</li>
</ul>
<p>Many times, we've turned our eyes away from that big luring security hole because we thought it was practically impossible to mitigate it across a decently large software bill of material.</p>
<p>But, since 20 years, we actually can!</p>
<p>In order to prevent an attacker entering in such a way, the operator has to secure her supply chain in close collaboration with our other participant.</p>
<h3 id="developer"><a class="header" href="#developer">Developer</a></h3>
<p>The developer incrementally modifies the source code.</p>
<p>From time to time, these modifications need to be shipped to that production place.</p>
<p>Locally, on the developer machine, everything looks good and also the CI doesn't complain.</p>
<p>So, off we go!</p>
<p>However, there are a couple of guarantees that she struggles to give with confidence, such as:</p>
<ul>
<li>Have you verified all base images and analyzed them for their potential attack surface?</li>
<li>Can you guarantee stable base images that will never change, once verified?</li>
<li>Have you properly validated all upstream binary-distributed blobs yourself?</li>
<li>Can you guarantee that all dependencies, system &amp; language level, are verified and stable?</li>
</ul>
<h2 id="the-layers"><a class="header" href="#the-layers">The Layers</a></h2>
<p>The Standard layers of packaging are designed to bring both participants together around a framework that holds software supply chain security dear and attackers out.</p>
<p>By providing a shared mental model for flexible, yet structured collaboration, it successfully circumnavigates some of the pitfalls of the underlying technology.</p>
<pre><code class="language-mermaid">flowchart TD
    packaging([Packaging])
    operable([Operable])
    image([OCI-Image])
    scheduler([Scheduler Chart])
    packaging --&gt; operable
    operable --&gt; image
    image --&gt; scheduler

    click packaging href "#packaging-layer" "Jump to the packaging layer section"
    click operable href "#operable-layer" "Jump to the operable layer section"
    click image href "#oci-image-layer" "Jump to the OCI image layer section"
    click scheduler href "#scheduler-chart-layer" "Jump to the scheduler chart layer section"
</code></pre>
<h3 id="packaging-layer"><a class="header" href="#packaging-layer">Packaging Layer</a></h3>
<p>This layer builds the pristine executable application as written by the developer with the building tools of the developer.</p>
<p>However, to ensure the software supply chain requirements, these build instructions are run in the context of a very restricted build environment provided by Nix.</p>
<p>Nix has a vast ecosystem, which makes embedding these build instructions for most languages straight forward.</p>
<p>For many languages, the Nix ecosystem has already developped and vested golden packaging paths.</p>
<p>That means, that in most cases, we simply can put those ecosystem libraries to work.</p>
<h3 id="operable-layer"><a class="header" href="#operable-layer">Operable Layer</a></h3>
<p>More often than not, born in the heat of chasing features, some aspects of the binary are not quite to liking and necessity of the operator.</p>
<p>We need a buffer zone to accommodate for that, yet with a clear perspective to backlog and polish it off later.</p>
<p>The operable layer is that buffer zone. It is a typically scripted wrapper around the binary which instruments the application for operation.</p>
<p>It is written in a language that both, developer and operator, are comfortable with.</p>
<p>The only viable perspective for this operable wrapper is to become as thin as possible.</p>
<p>Should unmet operational scenarios fatten it up, our participants would schedule a backlog grooming session to address the issue.
In order to put that wrapper on diet, they would refactor missing capabilities from the operable into the binary.</p>
<h3 id="oci-image-layer"><a class="header" href="#oci-image-layer">OCI-Image Layer</a></h3>
<p>But we wouldn't send a script over the wire to our production place, right?!?</p>
<p>Right. To distribute our artifacts, we adopt the OCI Container Specification.</p>
<p>In simple terms, it's a docker image, but that would be misleading terminology.
And to mislead you here for the sake of convenience, doesn't fit our reinvigorated software supply chain mindset.</p>
<p>The OCI Distribution Specification, ensures that distribution, for all intents and purposes of the runtime, is an atomic transaction.</p>
<p>This is convenient, because there is little possibility to end up with a partial and corrupt, but technically executable target state.</p>
<p>It is also convenient, because it is the current de-facto industry standard.</p>
<p>This industry, however, presently discusses its well-understood toil on startup times.
Such is the common practice, that very frequently a non-trivial amount of stale artifacts are shipped.
Through time spent on transport, decompression, extraction and layer re-assembly, they contribute to a noticeable runtime setup latency.</p>
<p>Nix ensures, that only the bare minimum runtime dependencies are included in every OCI image.
Optionally, static builds can be turned on to further dramatically reduce the effective size of the container archive.</p>
<p>And last but not least, recent initiatives at the intersection of both ecosystems strive to further develop cross-pollination of concepts and ideas.</p>
<p>For example, in the Nix ecosystem, massive dependency reuse through global build trees for 50k+ packages is the norm.
This technique is also a promising approach to increase the effectiveness of the OCI layer deduplication by significant margin.</p>
<h3 id="scheduler-chart-layer"><a class="header" href="#scheduler-chart-layer">Scheduler Chart Layer</a></h3>
<p>The final runtime configuration is data.</p>
<p>The scheduler chart layer provides example data that also satisfies the requirements of operational readiness.</p>
<p>This data may be amended according to the concrete operational scenario before being rendered and submitted to the scheduler for reconciliation.</p>
<p>This pattern piece does not proffer any particular tooling to do so.</p>
<p>Any configuration wrangler that has good support for functions and overrides is probably fair game.</p>
<p>One may use Nix, however, as the glue code that provides a globally homologous interface on the command line.</p>
<p>While Standard offers its TUI to that end, many operators may be also already familiar with the vanilla Nix CLI tooling.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><em>Beware: This is an opinionated analysis.</em></p>
<p><em>However, it helps to reason about CI/CD with Standard.
Standard developed the concept of self-configuring CI through the Standard Registry.</em></p>
</blockquote>
<h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>Let's look at Continuous Integration (CI) and Continuous Delivery (CD) from a 10000 feet flight height.</p>
<p>For our visual analysis, we use the Business Process Modeling Notation (<a href="https://www.omg.org/spec/BPMN/2.0/">BPMN 2.0</a>).</p>
<p>For an overview of the notation follow this <a href="https://camunda.com/bpmn/reference/">link</a>.
But don't worry, we'll also walk you through the diagram.</p>
<a href="patterns/ci-cd-10000-feet.svg" target="_blank">
<img
  alt="CI-CD BPMN Model"
  title="Open the CI-CD BPMN Model in a new tab"
  src="ci-cd-10000-feet.svg"
  width="100%"
>
</a>
<h2 id="general-phases"><a class="header" href="#general-phases">General Phases</a></h2>
<p>There are four phases that further structure the process.</p>
<pre><code class="language-mermaid">flowchart TD
    linting([Linting])
    building([Building])
    deployment([Deployment])
    probing([Probing &amp; Attestation])

    linting --&gt; building
    building --&gt; deployment
    deployment --&gt; probing

    click linting href "#linting-phase" "Jump to the linting phase section"
    click building href "#building-phase" "Jump to the building phase section"
    click deployment href "#deployment-phase" "Jump to the deployment phase section"
    click probing href "#probing-attestation-phase" "Jump to the probing &amp; attestation phase section"
</code></pre>
<p>To automate these, we make use of the [Standard Registry][glossary-registry] that holds all data needed to build the pipeline.
Its is data JSON-serializable so that any CI tool or helper library can auto-generate the pipeline from it.</p>
<h3 id="linting-phase"><a class="header" href="#linting-phase">Linting Phase</a></h3>
<p>The linting phase ensures that the code base is in good shape.
This can involve verification of formatting, style and auto-generated code.</p>
<p>Typically, these are simple repository tasks that call tools to get the job done.</p>
<p>In the local development environment, you invoke these with your task runner of choice or even configure them in a pre-commit or pre-push hook.</p>
<p>In addition, a Standard-ready CI, runs them first to ensure a short time-to-first-feedback.</p>
<h3 id="building-phase"><a class="header" href="#building-phase">Building Phase</a></h3>
<p>We rely on Nix's declarative build and dependency trees to set up an efficient, intelligently scheduled and reproducible build pipeline.</p>
<p>The Nix cache ensures that no single build is done twice, as long as the build inputs, for example source code or dependencies, do not change.</p>
<p>Since the full dependency tree is known beforehand, intelligent scheduling ensures that shared dependencies are built and cached first before dependent builds are enqueued.</p>
<p>These properties lay on the foundation of reproducible builds.
Thereby, an evaluator predicts expected output hashes ahead-of-time by recursively hashing over all dependencies' own output hashes.
Since that evaluation is cheap when compared to a full build, it is calculated before even starting the first build and is exploited for smart scheduling of the build queue.</p>
<p>An optimized build farm can make particular use of that ahead-of-time evaluation to further optimize overall build times.</p>
<p>The Standard Registry holds all the data in machine readable format that is required by such build farms.</p>
<h3 id="deployment-phase"><a class="header" href="#deployment-phase">Deployment Phase</a></h3>
<p>The deployment phase renders service runtime configuration into manifests and pushes them to the API of a platform scheduler, such as Kubernetes.</p>
<p>All reconciliation of the desired application runtime state is then the responsibility of a control loop built or plugged into that scheduler.</p>
<h4 id="push-vs-pull-workflows"><a class="header" href="#push-vs-pull-workflows">Push vs Pull Workflows</a></h4>
<p>The industry has diverging opinions about whether a deployment should be pull or push based.</p>
<p>A pull based workflow is initiated by the target infrastructure polling for changes to the manifest source in regular intervals.</p>
<p>The advantages of a pull based workflow include a reduced intrusion surface since any network connection will be strictly outgoing from the target infrastructure.</p>
<p>A push based workflow, on the other hand, starts with CI which triggers deployment based on a particular precondition being met.</p>
<p>Having the target infrastructure listening for incoming connections from the orchestrating CI is also the main disadvantage of the push based workflow, as it increases the intrusion surface.
However, orchestrated workflows, as opposed to the pull-based choreographed ones, are usually easier to reason about and, thus, easier to maintain.</p>
<p>A Standard-ready CI can typically cover simple deployments that follow a trivial render-and-push logic.</p>
<p>For more advanced workflows and roll-out conditions, a suitable state machine is required.</p>
<h3 id="probing--attestation-phase"><a class="header" href="#probing--attestation-phase">Probing &amp; Attestation Phase</a></h3>
<p>The probing and attestation phase is highly situation specific.
It cannot be adequately represented through Standard and requires an entirely different control loop.</p>
<p>During this phase a mix of short- &amp; long-lived testing suites are run against a particular target environment, usually called "testing" or "staging".</p>
<p>Some of these suites can be automated in proper test scheduling frameworks, others are inherently manual.</p>
<p>Test suites may include the likes of:</p>
<ul>
<li>Penetration Testing</li>
<li>Property-Based Testing and Fuzzing</li>
<li>Monkey Testing</li>
<li>Load and Soak Testing</li>
<li>End2End Testing</li>
<li>Benchmarking</li>
<li>Smoke Testing</li>
<li>Runtime and Code Auditing</li>
</ul>
<hr />
<p>In this pattern piece, we didn't cover the release process.
But we'll follow up with a dedicated pattern piece shortly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-minimal-project-template-with-docs"><a class="header" href="#a-minimal-project-template-with-docs">A minimal project template with docs!</a></h1>
<h2 id="included-configuration"><a class="header" href="#included-configuration">Included Configuration</a></h2>
<ul>
<li><a href="https://numtide.github.io/devshell/"><code>devshell</code></a> for your contribution environments!</li>
<li><a href="https://numtide.github.io/treefmt/"><code>treefmt</code></a> for formatting all the things!</li>
<li><a href="https://rust-lang.github.io/mdBook/"><code>mdbook</code></a> for making documentation part of your workflow!</li>
<li><a href="https://github.com/evilmartians/lefthook"><code>lefthook</code></a> for commit discipline and a clean history!</li>
<li><a href="https://github.com/apps/settings">GitHub Setting App</a> for configuring GitHub declaratively!</li>
</ul>
<h2 id="bootstrap"><a class="header" href="#bootstrap">Bootstrap</a></h2>
<pre><code class="language-bash"># make a new empty project dir
mkdir my-project
cd my-project

# grab the template
nix flake init -t github:divnix/std#minimal

# see which values to change
grep -r --include=\*.nix 'CONFIGURE-ME' .

# do some inititialization
git init &amp;&amp; git add .

# enter the devshell and effectuate repo configuration
direnv allow

git add . &amp;&amp; git commit -m "feat: initial commit"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-and-nix-and-rust-oh-my"><a class="header" href="#standard-and-nix-and-rust-oh-my">Standard, and Nix and Rust, oh my!</a></h1>
<p>This template uses <a href="https://nixos.org">Nix</a> to create a sane development shell for
Rust projects, <a href="https://github.com/divnix/std#readme">Standard</a> for keeping your Nix code well organized,
<a href="https://github.com/nix-community/fenix#readme">Fenix</a> for pulling the latest rust binaries via Nix, and
<a href="https://github.com/ipetkov/crane#readme">Crane</a> for building Rust projects in Nix incrementally, making
quick iteration a breeze.</p>
<p>Rust Analyzer is also wired up properly for immediate use from a
terminal based editor with language server support. Need one with
stellar Nix and Rust support? Try <a href="https://github.com/helix-editor/helix#readme">Helix</a>!</p>
<h2 id="bootstrap-1"><a class="header" href="#bootstrap-1">Bootstrap</a></h2>
<pre><code class="language-bash"># make a new empty project dir
mkdir my-project
cd my-project

# grab the template
nix flake init -t github:divnix/std#rust

# do some inititialization
git init &amp;&amp; git add .

# enter the devshell
direnv allow || nix develop

# continue some inititialization
cargo init # pass --lib for library projects
cargo build # to generate Cargo.lock

git add . &amp;&amp; git commit -m "init"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuicli"><a class="header" href="#tuicli">TUI/CLI</a></h1>
<h4 id="tuicli-1"><a class="header" href="#tuicli-1">TUI/CLI:</a></h4>
<pre><code class="language-console"># TUI
std

# CLI
std //&lt;TAB&gt;
std re-cache # refresh the CLI cache
std list     # show a list of all targets

# Version
std -v
</code></pre>
<h4 id="help"><a class="header" href="#help">Help:</a></h4>
<pre><code class="language-console">❯ std -h
std is the CLI / TUI companion for Standard.

- Invoke without any arguments to start the TUI.
- Invoke with a target spec and action to run a known target's action directly.

Usage:
  std //[cell]/[block]/[target]:[action] [args...]
  std [command]

Available Commands:
  list        List available targets.
  re-cache    Refresh the CLI cache.

Flags:
  -h, --help      help for std
  -v, --version   version for std

Use "std [command] --help" for more information about a command.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conventions-in-std"><a class="header" href="#conventions-in-std">Conventions in <code>std</code></a></h1>
<p>In principle, we all want to be able to read code with local reasoning.</p>
<p>However, these few conventions are pure quality of life and
help us to keep our nix code organized.</p>
<h2 id="nix-file-locations"><a class="header" href="#nix-file-locations">Nix File Locations</a></h2>
<p>Nix files are imported from either of these two locations, if present, in this order of precedence:</p>
<pre><code>${cellsFrom}/${cell}/${block}.nix
${cellsFrom}/${cell}/${block}/default.nix
</code></pre>
<h2 id="readme-file-locations"><a class="header" href="#readme-file-locations">Readme File Locations</a></h2>
<p>Readme files are picked up by the TUI in the following places:</p>
<pre><code>${cellsFrom}/${cell}/Readme.md
${cellsFrom}/${cell}/${block}.md
${cellsFrom}/${cell}/${block}/Readme.md
${cellsFrom}/${cell}/${block}/${target}.md
</code></pre>
<h2 id="cell-block-file-arguments"><a class="header" href="#cell-block-file-arguments">Cell Block File Arguments</a></h2>
<p>Each Cell Block is a function and expects the following standardized interface for interoperability:</p>
<pre><code class="language-nix">{ inputs, cell }: {}
</code></pre>
<h2 id="the-inputs-argument"><a class="header" href="#the-inputs-argument">The <code>inputs</code> argument</a></h2>
<p>The <code>inputs</code> argument holds all the de-systemized flake inputs plus a few special inputs:</p>
<pre><code class="language-nix">{
  inputs = {
    self = {}; # sourceInfo of the current repository
    nixpkgs = {}; # an _instantiated_ nixpkgs
    cells = {}; # the other cells in this repo
  };
}
</code></pre>
<h2 id="the-cell-argument"><a class="header" href="#the-cell-argument">The <code>cell</code> argument</a></h2>
<p>The <code>cell</code> argument holds all the different Cell Block targets of the current cell.
This is the main mechanism by which code organization and separation of concern is enabled.</p>
<h2 id="the-desytemized-inputs"><a class="header" href="#the-desytemized-inputs">The <code>deSytemize</code>d inputs</a></h2>
<p>All inputs are scoped for the <em>current</em> system, that is derived from the <code>systems</code> input list to <code>std.grow</code>.
That means contrary to the usual nix-UX, in most cases, you don't need to worry about <code>system</code>.</p>
<p>The current system will be "lifted up" one level, while still providing full access to all <code>systems</code> for
cross-compilation scenarios.</p>
<pre><code class="language-nix"># inputs.a.packages.${system}
{
  inputs.a.packages.pkg1 = {};
  inputs.a.packages.pkg2 = {};
  /* ... */
  inputs.a.packages.${system}.pkgs1 = {};
  inputs.a.packages.${system}.pkgs2 = {};
  /* ... */
}
</code></pre>
<h2 id="top-level-system-scoping-of-outputs"><a class="header" href="#top-level-system-scoping-of-outputs">Top-level <code>system</code>-scoping of outputs</a></h2>
<p>Contrary to the upstream flake schema, all outputs are <code>system</code> spaced at the top-level.
This allows us to uniformly select on the <em>current</em> system and forget about it for most
of the time.</p>
<p>Sometimes <code>nix</code> evaluations don't strictly depend on a particular <code>system</code>, and scoping
them seems counter-intuitive. But due to the fact that function calls are memoized, there
is never a penalty in actually scoping them. So for the sake of uniformity, we scope them
anyways.</p>
<p>The outputs therefore abide by the following "schema":</p>
<pre><code class="language-nix">{
  ${system}.${cell}.${block}.${target} = {};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deprecations"><a class="header" href="#deprecations">Deprecations</a></h1>
<pre><code class="language-nix">{inputs}: time: body: let
  l = inputs.nixpkgs.lib // builtins;
  ansi = import ./ansi.nix;
  pad = s: let
    n = 17;
    prefix = l.concatStringsSep "" (l.genList (_: " ") (n - (l.stringLength s)));
  in
    prefix + s;
  indent = s: let
    n = 5;
    prefix = l.concatStringsSep "" (l.genList (_: " ") n);
    lines = l.splitString "\n" s;
  in
    "  📝 │ " + (l.concatStringsSep "\n${prefix}│ " lines);
  warn = let
    apply =
      l.replaceStrings
      (map (key: "{${key}}") (l.attrNames ansi))
      (l.attrValues ansi);
  in
    msg:
      l.trace (apply "🔥 {bold}{196}Standard Deprecation Notices - {220}run `std check' to show!{reset}")
      l.traceVerbose (apply "\n{202}${msg}{reset}");
in
  warn ''
    ─────┬─────────────────────────────────────────────────────────────────────────
      💪 │ {bold}Action Required !{un-bold}
    ─────┼─────────────────────────────────────────────────────────────────────────
    {italic}${indent body}{un-italic}
    ─────┼─────────────────────────────────────────────────────────────────────────
      📅 │ {bold}Scheduled Removal: ${pad time}{un-bold}
    ─────┴─────────────────────────────────────────────────────────────────────────
  ''
</code></pre>
<p>Please observe the following deprecations and their deprecation schedule:</p>
<pre><code class="language-nix">inputs: let
  removeBy = import ./cells/std/errors/removeBy.nix {inherit inputs;};
in {
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="sidetoc"><nav class="pagetoc"></nav></div>
<h1 id="builtin-block-types"><a class="header" href="#builtin-block-types">Builtin Block Types</a></h1>
<p>A few Block Types are packaged with <code>std</code>.</p>
<p>In practical terms, Block Types distinguish themselves through the
actions they provide to a particular Cell Block.</p>
<p>It is entirely possible to define custom Block Types with custom
Actions according to the needs of your project.</p>
<h2 id="arion"><a class="header" href="#arion">Arion</a></h2>
<pre><code class="language-nix">{root}:
/*
Use the arion for arionCompose Jobs - https://docs.hercules-ci.com/arion/

Available actions:
  - up
  - ps
  - stop
  - rm
  - config
  - arion
*/
let
  inherit (root) mkCommand;
in
  name: {
    inherit name;
    type = "arion";
    actions = {
      currentSystem,
      fragment,
      fragmentRelPath,
      target,
      inputs,
    }: let
      pkgs = inputs.nixpkgs.${currentSystem};
      cmd = "arion --prebuilt-file ${target.config.out.dockerComposeYaml}";
    in [
      (mkCommand currentSystem "up" "arion up" [pkgs.arion] ''${cmd} up "$@" '' {})
      (mkCommand currentSystem "ps" "exec this arion task to ps" [pkgs.arion] ''${cmd} ps "$@" '' {})
      (mkCommand currentSystem "stop" "arion stop" [pkgs.arion] ''${cmd} stop "$@" '' {})
      (mkCommand currentSystem "rm" "arion rm" [pkgs.arion] ''${cmd} rm "$@" '' {})
      (mkCommand currentSystem "config" "check the docker-compose yaml file" [pkgs.arion] ''${cmd} config "$@" '' {})
      (mkCommand currentSystem "arion" "pass any command to arion" [pkgs.arion] ''${cmd} "$@" '' {})
    ];
  }
</code></pre>
<h2 id="runnables-todo-vs-installables"><a class="header" href="#runnables-todo-vs-installables">Runnables (todo: vs installables)</a></h2>
<pre><code class="language-nix">{
  root,
  super,
}:
/*
Use the Runnables Blocktype for targets that you want to
make accessible with a 'run' action on the TUI.
*/
let
  inherit (root) mkCommand actions;
  inherit (super) addSelectorFunctor;
in
  name: {
    __functor = addSelectorFunctor;
    inherit name;
    type = "runnables";
    actions = {
      currentSystem,
      fragment,
      fragmentRelPath,
      target,
      inputs,
    }: [
      (actions.build currentSystem target)
      (actions.run currentSystem target)
    ];
  }
</code></pre>
<h2 id="installables-todo-vs-runnables"><a class="header" href="#installables-todo-vs-runnables">Installables (todo: vs runnables)</a></h2>
<pre><code class="language-nix">{
  root,
  super,
  nixpkgs,
}:
/*
Use the Installables Blocktype for targets that you want to
make availabe for installation into the user's nix profile.

Available actions:
  - install
  - upgrade
  - remove
  - build
  - bundle
  - bundleImage
  - bundleAppImage
*/
let
  inherit (root) mkCommand actions;
  inherit (super) addSelectorFunctor;
  l = nixpkgs.lib // builtins;
in
  name: {
    __functor = addSelectorFunctor;
    inherit name;
    type = "installables";
    actions = {
      currentSystem,
      fragment,
      fragmentRelPath,
      target,
      inputs,
    }: let
      escapedFragment = l.escapeShellArg fragment;
    in [
      (actions.build currentSystem target)
      # profile commands require a flake ref
      (mkCommand currentSystem "install" "install this target" [] ''
        # ${target}
        set -x
        nix profile install "$PRJ_ROOT#"${escapedFragment}
      '' {})
      (mkCommand currentSystem "upgrade" "upgrade this target" [] ''
        # ${target}
        set -x
        nix profile upgrade "$PRJ_ROOT#"${escapedFragment}
      '' {})
      (mkCommand currentSystem "remove" "remove this target" [] ''
        # ${target}
        set -x
        nix profile remove "$PRJ_ROOT#"${escapedFragment}
      '' {})
      # TODO: use target. `nix bundle` requires a flake ref, but we may be able to use nix-bundle instead as a workaround
      (mkCommand currentSystem "bundle" "bundle this target" [] ''
        # ${target}
        set -x
        nix bundle --bundler github:Ninlives/relocatable.nix --refresh "$PRJ_ROOT#"${escapedFragment}
      '' {})
      (mkCommand currentSystem "bundleImage" "bundle this target to image" [] ''
        # ${target}
        set -x
        nix bundle --bundler github:NixOS/bundlers#toDockerImage --refresh "$PRJ_ROOT#"${escapedFragment}
      '' {})
      (mkCommand currentSystem "bundleAppImage" "bundle this target to AppImage" [] ''
        # ${target}
        set -x
        nix bundle --bundler github:ralismark/nix-appimage --refresh "$PRJ_ROOT#"${escapedFragment}
      '' {})
    ];
  }
</code></pre>
<h2 id="pkgs"><a class="header" href="#pkgs">Pkgs</a></h2>
<pre><code class="language-nix">_:
/*
Use the Pkgs Blocktype if you need to construct your custom
variant of nixpkgs with overlays.

Targets will be excluded from the CLI / TUI  and thus not
slow them down.
*/
name: {
  inherit name;
  type = "pkgs";
  cli = false; # its special power
}
</code></pre>
<h2 id="devshells"><a class="header" href="#devshells">Devshells</a></h2>
<pre><code class="language-nix">{  
  root,
  super,
}:
/*
Use the Devshells Blocktype for devShells.

Available actions:
  - build
  - enter
*/
let
  inherit (root) mkCommand actions devshellDrv;
  inherit (super) addSelectorFunctor;
  inherit (builtins) unsafeDiscardStringContext;
in
  name: {
    __functor = addSelectorFunctor;
    inherit name;
    type = "devshells";
    actions = {
      currentSystem,
      fragment,
      fragmentRelPath,
      target,
      inputs,
    }: let
      developDrv = devshellDrv target;
    in [
      (actions.build currentSystem target)
      (mkCommand currentSystem "enter" "enter this devshell" [] ''
        profile_path="$PRJ_DATA_HOME/${fragmentRelPath}"
        mkdir -p "$profile_path"
        # ${developDrv}
        nix_args=(
          "${unsafeDiscardStringContext developDrv.drvPath}"
          "--no-update-lock-file"
          "--no-write-lock-file"
          "--no-warn-dirty"
          "--accept-flake-config"
          "--no-link"
          "--build-poll-interval" "0"
          "--builders-use-substitutes"
        )
        nix build "''${nix_args[@]}" --profile "$profile_path/shell-profile"
        _SHELL="$SHELL"
        eval "$(nix print-dev-env ${developDrv})"
        SHELL="$_SHELL"
        if ! [[ -v STD_DIRENV ]]; then
          if declare -F __devshell-motd &amp;&gt;/dev/null; then
            __devshell-motd
          fi
          exec $SHELL -i
        fi
      '' {})
    ];
  }
</code></pre>
<h2 id="nixago"><a class="header" href="#nixago">Nixago</a></h2>
<pre><code class="language-nix">{root}:
/*
Use the Nixago Blocktype for nixago pebbles.

Use Nixago pebbles to ensure files are present
or symlinked into your repository. You may typically
use this for repo dotfiles.

For more information, see: https://github.com/nix-community/nixago.

Available actions:
  - ensure
  - explore
*/
let
  inherit (root) mkCommand;
in
  name: {
    inherit name;
    type = "nixago";
    actions = {
      currentSystem,
      fragment,
      fragmentRelPath,
      target,
      inputs,
    }: let
      pkgs = inputs.nixpkgs.${currentSystem};
    in [
      (mkCommand currentSystem "populate" "populate this nixago file into the repo" [] ''
        ${target.install}/bin/nixago_shell_hook
      '' {})
      (mkCommand currentSystem "explore" "interactively explore the nixago file" [pkgs.bat] ''
        bat "${target.configFile}"
      '' {})
    ];
  }
</code></pre>
<h2 id="containers"><a class="header" href="#containers">Containers</a></h2>
<pre><code class="language-nix">{
  trivial,
  root,
  super,
}:
/*
Use the Containers Blocktype for OCI-images built with nix2container.

Available actions:
  - print-image
  - publish
  - load
*/
let
  inherit (root) mkCommand actions;
  inherit (super) addSelectorFunctor;
  inherit (builtins) readFile toFile;
in
  name: {
    __functor = addSelectorFunctor;
    inherit name;
    type = "containers";
    actions = {
      currentSystem,
      fragment,
      fragmentRelPath,
      target,
      inputs,
    }: let
      inherit (inputs.n2c.packages.${currentSystem}) skopeo-nix2container;
      triv = trivial.${currentSystem};
      proviso = ./containers-proviso.sh;

      tags' =
        builtins.toFile "${target.name}-tags.json" (builtins.concatStringsSep "\n" target.image.tags);
      copyFn = ''
        copy() {
          local uri prev_tag
          uri=$1
          shift

          for tag in $(&lt;${tags'}); do
            if ! [[ -v prev_tag ]]; then
              skopeo --insecure-policy copy nix:${target} "$uri:$tag" "$@"
            else
              # speedup: copy from the previous tag to avoid superflous network bandwidth
              skopeo --insecure-policy copy "$uri:$prev_tag" "$uri:$tag" "$@"
            fi
            echo "Done: $uri:$tag"

            prev_tag="$tag"
          done
        }
      '';
    in [
      (actions.build currentSystem target)
      (mkCommand currentSystem "print-image" "print out the image.repo with all tags" [] ''
        echo
        for tag in $(&lt;${tags'}); do
          echo "${target.image.repo}:$tag"
        done
      '' {})
      (mkCommand currentSystem "publish" "copy the image to its remote registry" [skopeo-nix2container] ''
          ${copyFn}
          copy docker://${target.image.repo}
        '' {
          meta.image = target.image.name;
          inherit proviso;
        })
      (mkCommand currentSystem "load" "load image to the local docker daemon" [skopeo-nix2container] ''
        ${copyFn}
        if command -v podman &amp;&gt; /dev/null; then
           echo "Podman detected: copy to local podman"
           copy containers-storage:${target.image.repo} "$@"
        fi
        if command -v docker &amp;&gt; /dev/null; then
           echo "Docker detected: copy to local docker"
           copy docker-daemon:${target.image.repo} "$@"
        fi
      '' {})
    ];
  }
</code></pre>
<h2 id="terra"><a class="header" href="#terra">Terra</a></h2>
<p>Block type for managing <a href="https://terranix.org/">Terranix</a> configuration for <a href="https://www.terraform.io/">Terraform</a>.</p>
<pre><code class="language-nix">{
  root,
  super,
}:
/*
Use the Terra Blocktype for terraform configurations managed by terranix.

Important! You need to specify the state repo on the blocktype, e.g.:

[
  (terra "infra" "git@github.com:myorg/myrepo.git")
]

Available actions:
  - init
  - plan
  - apply
  - state
  - refresh
  - destroy
*/
let
  inherit (root) mkCommand;
  inherit (super) addSelectorFunctor postDiffToGitHubSnippet;
in
  name: repo: {
    inherit name;
    __functor = addSelectorFunctor;
    type = "terra";
    actions = {
      currentSystem,
      fragment,
      fragmentRelPath,
      target,
      inputs,
    }: let
      inherit (inputs) terranix;
      pkgs = inputs.nixpkgs.${currentSystem};

      git = {
        inherit repo;
        ref = "main";
        state = fragmentRelPath + "/state.json";
      };

      terraEval = import (terranix + /core/default.nix);
      terraformConfiguration = builtins.toFile "config.tf.json" (builtins.toJSON
        (terraEval {
          inherit pkgs; # only effectively required for `pkgs.lib`
          terranix_config = {
            _file = fragmentRelPath;
            imports = [target];
          };
          strip_nulls = true;
        })
        .config);

      setup = ''
        export TF_VAR_fragment=${pkgs.lib.strings.escapeShellArg fragment}
        export TF_VAR_fragmentRelPath=${fragmentRelPath}
        export TF_IN_AUTOMATION=1
        export TF_DATA_DIR="$PRJ_DATA_HOME/${fragmentRelPath}"
        export TF_PLUGIN_CACHE_DIR="$PRJ_CACHE_HOME/tf-plugin-cache"
        mkdir -p "$TF_DATA_DIR"
        mkdir -p "$TF_PLUGIN_CACHE_DIR"
        dir="$PRJ_ROOT/.tf/${fragmentRelPath}/.tf"
        mkdir -p "$dir"
        cat &lt;&lt; MESSAGE &gt; "$dir/readme.md"
        This is a tf staging area.
        It is motivated by the terraform CLI requiring to be executed in a staging area.
        MESSAGE

        if [[ -e "$dir/config.tf.json" ]]; then rm -f "$dir/config.tf.json"; fi
        jq '.' ${terraformConfiguration} &gt; "$dir/config.tf.json"
      '';
      wrap = cmd: ''
        ${setup}

        # Run the command and capture output
        terraform-backend-git git \
           --dir "$dir" \
           --repository ${git.repo} \
           --ref ${git.ref} \
           --state ${git.state} \
           terraform ${cmd} "$@" \
           ${pkgs.lib.optionalString (cmd == "plan") ''
             -lock=false -no-color | tee "$PRJ_CACHE_HOME/tf.console.txt"
           ''}

        # Pass output to the snippet
        ${pkgs.lib.optionalString (cmd == "plan") ''
          output=$(cat "$PRJ_CACHE_HOME/tf.console.txt")
          summary_plan=$(tac "$PRJ_CACHE_HOME/tf.console.txt" | grep -m 1 -E '^(Error:|Plan:|Apply complete!|No changes.|Success)' | tac || echo "View output.")
          summary="&lt;code&gt;std ${fragmentRelPath}:${cmd}&lt;/code&gt;: $summary_plan" 
          ${postDiffToGitHubSnippet "${fragmentRelPath}:${cmd}" "$output" "$summary"}
        ''}
      '';
      
    in [
      (mkCommand currentSystem "init" "tf init" [pkgs.jq pkgs.terraform pkgs.terraform-backend-git] (wrap "init") {})
      (mkCommand currentSystem "plan" "tf plan" [pkgs.jq pkgs.terraform pkgs.terraform-backend-git] (wrap "plan") {})
      (mkCommand currentSystem "apply" "tf apply" [pkgs.jq pkgs.terraform pkgs.terraform-backend-git] (wrap "apply") {})
      (mkCommand currentSystem "state" "tf state" [pkgs.jq pkgs.terraform pkgs.terraform-backend-git] (wrap "state") {})
      (mkCommand currentSystem "refresh" "tf refresh" [pkgs.jq pkgs.terraform pkgs.terraform-backend-git] (wrap "refresh") {})
      (mkCommand currentSystem "destroy" "tf destroy" [pkgs.jq pkgs.terraform pkgs.terraform-backend-git] (wrap "destroy") {})
      (mkCommand currentSystem "terraform" "pass any command to terraform" [pkgs.jq pkgs.terraform pkgs.terraform-backend-git] (wrap "") {})
    ];
  }
</code></pre>
<h2 id="data"><a class="header" href="#data">Data</a></h2>
<pre><code class="language-nix">{
  trivial,
  root,
}:
/*
Use the Data Blocktype for json serializable data.

Available actions:
  - write
  - explore

For all actions is true:
  Nix-proper 'stringContext'-carried dependency will be realized
  to the store, if present.
*/
let
  inherit (root) mkCommand;
  inherit (builtins) toJSON concatStringsSep;
in
  name: {
    inherit name;
    type = "data";
    actions = {
      currentSystem,
      fragment,
      fragmentRelPath,
      target,
      inputs,
    }: let
      inherit (inputs.nixpkgs.${currentSystem}) pkgs;
      triv = trivial.${currentSystem};

      # if target ? __std_data_wrapper, then we need to unpack from `.data`
      json = triv.writeTextFile {
        name = "data.json";
        text = toJSON (
          if target ? __std_data_wrapper
          then target.data
          else target
        );
      };
    in [
      (mkCommand currentSystem "write" "write to file" [] "echo ${json}" {})
      (mkCommand currentSystem "explore" "interactively explore" [pkgs.fx] (
        concatStringsSep "\t" ["fx" json]
      ) {})
    ];
  }
</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<pre><code class="language-nix">_:
/*
Use the Functions Blocktype for reusable nix functions that you would
call elswhere in the code.

Also use this for all types of modules and profiles, since they are
implemented as functions.

Consequently, there are no actions available for functions.
*/
name: {
  inherit name;
  type = "functions";
}
</code></pre>
<h2 id="anything"><a class="header" href="#anything">Anything</a></h2>
<p><em>Note: while the implementation is the same as <code>functions</code>, the semantics are different. Implementations may diverge in the future.</em></p>
<pre><code class="language-nix">_:
/*
Use the Anything Blocktype as a fallback.

It doesn't have actions.
*/
name: {
  inherit name;
  type = "anything";
}
</code></pre>
<h2 id="kubectl"><a class="header" href="#kubectl">Kubectl</a></h2>
<p>Block type for rendering deployment manifests for the <a href="https://kubernetes.io">Kubernetes</a> Cluster scheduler.
Each named attribtute-set under the block contains a set of deployment manifests.</p>
<pre><code class="language-nix">{
  trivial,
  root,
  super,
  dmerge,
}:
/*
Use the `kubectl` Blocktype for rendering deployment manifests
for the Kubernetes Cluster scheduler. Each named attribtute-set under the
block contains a set of deployment manifests.

Available actions:
  - render
  - deploy
  - explore
*/
let
  inherit (root) mkCommand;
  inherit (super) addSelectorFunctor askUserToProceedSnippet postDiffToGitHubSnippet;
in
  name: {
    __functor = addSelectorFunctor;
    inherit name;
    type = "kubectl";

    actions = {
      currentSystem,
      fragment,
      fragmentRelPath,
      target,
      inputs,
    }: let
      inherit (inputs.nixpkgs) lib;
      pkgs = inputs.nixpkgs.${currentSystem};
      triv = trivial.${currentSystem};

      manifest_path = fragmentRelPath;

      checkedRev = inputs.std.std.errors.bailOnDirty ''
        Will not render manifests from a dirty tree.
        Otherwise we cannot keep good track of deployment history.''
      inputs.self.rev;

      usesKustomize = target ? kustomization || target ? Kustomization;

      augment = let
        amendIfExists = path: rhs: manifest:
          if true == lib.hasAttrByPath path manifest
          then amendAlways rhs manifest
          else manifest;

        amendAlways = rhs: manifest: dmerge manifest rhs;
      in
        target:
          lib.mapAttrs (
            key:
              lib.flip lib.pipe [
                # metadata
                (
                  manifest:
                    if manifest ? metadata.labels &amp;&amp; manifest.metadata.labels == null
                    then lib.recursiveUpdate manifest {metadata.labels = {};}
                    else manifest
                )
                (
                  amendIfExists ["metadata"]
                  {
                    metadata.labels."app.kubernetes.io/version" = checkedRev;
                    metadata.labels."app.kubernetes.io/managed-by" = "std-kubectl";
                  }
                )
                (
                  if usesKustomize &amp;&amp; (key == "kustomization" || key == "Kustomization")
                  # ensure a kustomization picks up the preprocessed resources
                  then
                    (manifest:
                      manifest
                      // {
                        resources =
                          map
                          (n: "${n}.json")
                          (builtins.attrNames (builtins.removeAttrs target ["meta" "Kustomization" "kustomization"]));
                      })
                  else lib.id
                )
              ]
          ) (builtins.removeAttrs target ["meta"]);

      generateManifests = target: let
        writeManifest = name: manifest:
          builtins.toFile name (builtins.unsafeDiscardStringContext (builtins.toJSON manifest));

        renderManifests = lib.mapAttrsToList (name: manifest: ''
          cp ${writeManifest name manifest} ${
            if name == "kustomization" || name == "Kustomization"
            then "Kustomization"
            else "${name}.json"
          }
        '');
      in
        triv.runCommandLocal "generate-k8s-manifests" {} ''
          mkdir -p $out
          cd $out
          ${lib.concatStrings (renderManifests (augment target))}
        '';

      build = ''
        declare manifest_path="$PRJ_DATA_HOME/${manifest_path}"
        build() {
          echo "Buiding manifests..."
          echo
          rm -rf "$manifest_path"
          mkdir -p "$(dirname "$manifest_path")"
          ln -s "${generateManifests target}" "$manifest_path"
          echo "Manifests built in: $manifest_path"
        }
      '';
    in [
      /*
      The `render` action will take this Nix manifest descrition, convert it to JSON,
      inject the git revision validate the manifest, after which it can be run or
      planned with the kubectl cli or the `deploy` action.
      */
      (mkCommand currentSystem "render" "Build the JSON manifests" [] ''
        ${build}
        build
      '' {})
      (mkCommand currentSystem "diff" "Diff the manifests against the cluster" [pkgs.kubectl pkgs.icdiff] ''
        ${build}
        build

        diff() {
          kubectl diff ${
          if usesKustomize
          then "--kustomize"
          else "--recursive --filename"
        } "$manifest_path/";
        }

        ${postDiffToGitHubSnippet "${fragmentRelPath}:diff" "$(diff || true)" "&lt;code&gt;std ${fragmentRelPath}:diff&lt;/code&gt;"}

        KUBECTL_EXTERNAL_DIFF="icdiff -N -r"
        export KUBECTL_EXTERNAL_DIFF
        diff
      '' {})
      (mkCommand currentSystem "apply" "Apply the manifests to K8s" [pkgs.kubectl pkgs.icdiff] ''
        ${build}
        build

        KUBECTL_EXTERNAL_DIFF="icdiff -N -r"
        export KUBECTL_EXTERNAL_DIFF

        diff() {
          kubectl diff --server-side=true --field-manager="std-action-$(whoami)" ${
          if usesKustomize
          then "--kustomize"
          else "--recursive --filename"
        } "$manifest_path/";

          return $?;
        }

        run() {
          kubectl apply --server-side=true --field-manager="std-action-$(whoami)" ${
          if usesKustomize
          then "--kustomize"
          else "--recursive --filename"
        } "$manifest_path/";
        }

        set +o errexit
        diff
        ret=$?
        set -o errexit
        if [[ $ret == 0 ]] || [[ $ret == 1 ]]; then
          ${askUserToProceedSnippet "apply" "run"}
        fi
      '' {})
      (mkCommand currentSystem "explore" "Interactively explore the manifests" [pkgs.fx] ''
        fx ${
          builtins.toFile "explore-k8s-manifests.json"
          (builtins.unsafeDiscardStringContext (builtins.toJSON (augment target)))
        }
      '' {})
    ];
  }
</code></pre>
<h2 id="files-todo-vs-data"><a class="header" href="#files-todo-vs-data">Files (todo: vs data)</a></h2>
<pre><code class="language-nix">{root}:
/*
Use the Files Blocktype for any text data.

Available actions:
  - explore
*/
let
  inherit (root) mkCommand;
in
  name: {
    inherit name;
    type = "files";
    actions = {
      currentSystem,
      fragment,
      fragmentRelPath,
      target,
      inputs,
    }: let
      file = toString target;
      pkgs = inputs.nixpkgs.${currentSystem};
    in [
      (mkCommand currentSystem "explore" "interactively explore with bat" [pkgs.bat] ''
        bat ${file}
      '' {})
    ];
  }
</code></pre>
<h2 id="microvms"><a class="header" href="#microvms">Microvms</a></h2>
<p>Block type for managing <a href="https://astro.github.io/microvm.nix">microvm.nix</a> configuration for declaring lightweight NixOS virtual machines.</p>
<pre><code class="language-nix">{root}:
/*
Use the Microvms Blocktype for Microvm.nix - https://github.com/astro/microvm.nix

Available actions:
  - run
  - console
  - microvm
*/
let
  inherit (root) mkCommand;
in
  name: {
    inherit name;
    type = "microvms";
    actions = {
      currentSystem,
      fragment,
      fragmentRelPath,
      target,
      inputs,
    }: [
      (mkCommand currentSystem "run" "run the microvm" [] ''
        ${target.config.microvm.runner.${target.config.microvm.hypervisor}}/bin/microvm-run
      '' {})
      (mkCommand currentSystem "console" "enter the microvm console" [] ''
        ${target.config.microvm.runner.${target.config.microvm.hypervisor}}/bin/microvm-console
      '' {})
      (mkCommand currentSystem "microvm" "pass any command to microvm" [] ''
        ${target.config.microvm.runner.${target.config.microvm.hypervisor}}/bin/microvm-"$@"
      '' {})
    ];
  }
</code></pre>
<h2 id="namaka"><a class="header" href="#namaka">Namaka</a></h2>
<p>Block type for declaring <a href="https://github.com/nix-community/namaka">Namaka</a> snapshot tests.</p>
<pre><code class="language-nix">{
  root,
  super,
}: let
  inherit (root) mkCommand;
  inherit (super) addSelectorFunctor;
in
  name: {
    __functor = addSelectorFunctor;
    inherit name;
    type = "namaka";
    actions = {
      currentSystem,
      fragment,
      fragmentRelPath,
      target,
      inputs,
    }: let
      pkg = inputs.namaka.packages.${currentSystem}.default;
      subdir = target.snap-dir or "";
    in [
      (mkCommand currentSystem "eval" "use transparently with namaka cli" [] ''
        nix eval '.#${fragment}'
      '' {})
      (mkCommand currentSystem "check" "run namaka tests against snapshots" [pkg] ''
        namaka ${subdir} check -c nix eval '.#${fragment}'
      '' {})
      (mkCommand currentSystem "review" "review pending namaka checks" [pkg] ''
        namaka ${subdir} review -c nix eval '.#${fragment}'
      '' {})
      (mkCommand currentSystem "clean" "clean up pending namaka checks" [pkg] ''
        namaka ${subdir} clean -c nix eval '.#${fragment}'
      '' {})
    ];
  }
</code></pre>
<h2 id="nixostests"><a class="header" href="#nixostests">Nixostests</a></h2>
<p>Block type for declaring VM-based tests for NixOS.</p>
<pre><code class="language-nix">{
  root,
  super,
}:
/*
Use the NixosTests Blocktype in order to instrucement nixos
vm-based test inside your reporisory.

Available actions:
  - run
  - run-vm
  - audit-script
  - run-vm-+
*/
let
  inherit (root) mkCommand actions;
  inherit (super) addSelectorFunctor;
in
  name: {
    __functor = addSelectorFunctor;
    inherit name;
    type = "nixostests";
    actions = {
      currentSystem,
      fragment,
      fragmentRelPath,
      target,
      inputs,
    }: let
      pkgs = inputs.nixpkgs.${currentSystem};
      inherit (pkgs) lib;
      inherit (pkgs.stdenv) isLinux;
    in
      [
        (mkCommand currentSystem "run" "run tests in headless vm" [] ''
          # ${target.driver}
          ${target.driver}/bin/nixos-test-driver
        '' {})
        (mkCommand currentSystem "audit-script" "audit the test script" [pkgs.bat] ''
          # ${target.driver}
          bat --language py ${target.driver}/test-script
        '' {})
        (mkCommand currentSystem "run-vm" "run tests interactively in vm" [] ''
          # ${target.driverInteractive}
          ${target.driverInteractive}/bin/nixos-test-driver
        '' {})
        (mkCommand currentSystem "run-vm+" "run tests with state from last run" [] ''
          # ${target.driverInteractive}
          ${target.driverInteractive}/bin/nixos-test-driver --keep-vm-state
        '' {})
      ]
      ++ lib.optionals isLinux [
        (mkCommand currentSystem "iptables+" "setup nat redirect 80-&gt;8080 &amp; 443-&gt;4433" [pkgs.iptables] ''
          sudo iptables \
            --table nat \
            --insert OUTPUT \
            --proto tcp \
            --destination 127.0.0.1 \
            --dport 443 \
            --jump REDIRECT \
            --to-ports 4433
          sudo iptables \
            --table nat \
            --insert OUTPUT \
            --proto tcp \
            --destination 127.0.0.1 \
            --dport 80 \
            --jump REDIRECT \
            --to-ports 8080
        '' {})
        (mkCommand currentSystem "iptables-" "remove nat redirect 80-&gt;8080 &amp; 443-&gt;4433" [pkgs.iptables] ''
          sudo iptables \
            --table nat \
            --delete OUTPUT -d 127.0.0.1/32 -p tcp -m tcp --dport 443 -j REDIRECT --to-ports 4433
          sudo iptables \
            --table nat \
            --delete OUTPUT -d 127.0.0.1/32 -p tcp -m tcp --dport 80 -j REDIRECT --to-ports 8080
        '' {})
      ];
  }
</code></pre>
<h2 id="nomad"><a class="header" href="#nomad">Nomad</a></h2>
<p>Block type for rendering job descriptions for the <a href="https://www.nomadproject.io/">Nomad</a> Cluster scheduler.</p>
<pre><code class="language-nix">{
  nixpkgs,
  root,
  super,
}:
/*
Use the `nomad` Block Type for rendering job descriptions
for the Nomad Cluster scheduler. Each named attribtute-set under the
block contains a valid Nomad job description, written in Nix.

Available actions:
  - render
  - deploy
  - explore
*/
let
  inherit (root) mkCommand;
  inherit (super) addSelectorFunctor askUserToProceedSnippet;
in
  name: {
    __functor = addSelectorFunctor;
    inherit name;
    type = "nomadJobManifests";

    actions = {
      currentSystem,
      fragment,
      fragmentRelPath,
      target,
      inputs,
    }: let
      inherit (nixpkgs) lib;
      pkgs = inputs.nixpkgs.${currentSystem};

      job_name = baseNameOf fragmentRelPath;
      job_path = "${dirOf fragmentRelPath}/${job_name}.json";

      jobWithGitRevision = target: let
        checkedRev = inputs.std.std.errors.bailOnDirty ''
          Will not render jobs from a dirty tree.
          Otherwise we cannot keep good track of deployment history.''
        inputs.self.rev;
        job = builtins.mapAttrs (_: v: lib.recursiveUpdate v {meta.rev = checkedRev;}) target.job;
      in
        builtins.toFile "${job_name}.json" (builtins.unsafeDiscardStringContext (builtins.toJSON {inherit job;}));
      render = ''
        declare job_path="$PRJ_DATA_HOME/${job_path}"
        render() {
          echo "Rendering to $job_path..."
          mkdir -p "$PRJ_DATA_HOME/${dirOf fragmentRelPath}"
          rm -rf "$job_path"
          ln -s "${jobWithGitRevision target}" "$job_path"
          if status=$(nomad validate "$job_path"); then
            echo "$status for $job_path"
          fi
        }
      '';
    in [
      /*
      The `render` action will take this Nix job descrition, convert it to JSON,
      inject the git revision validate the manifest, after which it can be run or
      planned with the Nomad cli or the `deploy` action.
      */
      (mkCommand currentSystem "render" "build the JSON job description" [pkgs.nomad] ''
        ${render}
        render
      '' {})
      (mkCommand currentSystem "deploy" "Deploy the job to Nomad" [pkgs.nomad pkgs.jq] ''
        ${render}
        render
        if ! plan_results=$(nomad plan -force-color "$job_path"); then
          echo "$plan_results"
          run() { eval "$(echo "$plan_results" | grep 'nomad job run -check-index')"; }
          ${askUserToProceedSnippet "deploy" "run"}
        else
          echo "Job hasn't changed since last deployment, nothing to deploy"
        fi
      '' {})
      (mkCommand currentSystem "explore" "interactively explore the Job defintion" [pkgs.nomad pkgs.fx] ''
        ${render}
        render
        fx "$job_path"
      '' {})
    ];
  }
</code></pre>
<h2 id="nvfetcher"><a class="header" href="#nvfetcher">Nvfetcher</a></h2>
<p>Block type for managing <a href="https://github.com/berberman/nvfetcher">nvfetcher</a> configuration for updating package definition sources.</p>
<pre><code class="language-nix">{
  root,
  super,
}:
/*
Use the nvfetcher Blocktype in order to generate package sources
with nvfetcher. See its docs for more details.

Available actions:
  - fetch
*/
let
  inherit (root) mkCommand actions;
  inherit (super) addSelectorFunctor;
in
  name: {
    __functor = addSelectorFunctor;
    inherit name;
    type = "nvfetcher";
    actions = {
      currentSystem,
      fragment,
      fragmentRelPath,
      target,
      inputs,
    }: let
      pkgs = inputs.nixpkgs.${currentSystem};
      inherit (pkgs) lib;
      inherit (pkgs.stdenv) isLinux;
    in [
      (mkCommand currentSystem "fetch" "update source" [pkgs.nvfetcher] ''
         targetname="$(basename ${fragmentRelPath})"
         blockpath="$(dirname ${fragmentRelPath})"
         cellpath="$(dirname "$blockpath")"
         tmpfile="$(mktemp)"
         updates="$PRJ_ROOT/${fragmentRelPath}.md"
         nvfetcher \
           --config "$PRJ_ROOT/$cellpath/nvfetcher.toml" \
           --build-dir "$PRJ_ROOT/$blockpath" \
           --changelog "$tmpfile" \
           --filter "^$targetname$"

        sed -i ''' -e "s|^|- \`$(date --iso-8601=m)\` |" "$tmpfile"
        cat "$tmpfile" &gt;&gt; "$updates"
      '' {})
    ];
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="sidetoc"><nav class="pagetoc"></nav></div>
<p><em>Autogenerated documentation from <code>./src/lib/*</code>.</em></p>
<div class="std-cell">
<h1 id="cells-lib">
<a class="header" href="reference/lib.html#cells-lib">Cell: <code>lib</code></a>
</h1>
<div class="std-readme-md">
<h2 id="the-standard-library"><a class="header" href="#the-standard-library">The Standard Library</a></h2>
<p>This library intends to cover the Software Delivery Life Cycle in the Standard way.</p>
<p>Each Cell Block covers a specific SDLC topic.</p>
</div>
</div>
<div class="std-block">
<h2 id="blocks-dev">
<a class="header" href="reference/lib.html#blocks-dev">Block: <code>dev</code></a>
</h2>
<div class="std-readme-md">
<h4 id="the-dev-library"><a class="header" href="#the-dev-library">The Dev Library</a></h4>
<p>This library covers <em>development</em> aspects of the SDLC.</p>
</div>
</div>
<div class="std-target">
<h3 id="targets-mkArion">
<a class="header" href="reference/lib.html#targets-mkArion">Target: <code>mkArion</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="mkarion"><a class="header" href="#mkarion"><code>mkArion</code></a></h6>
<p>This is a transparent convenience proxy for <a href="https://github.com/hercules-ci/arion"><code>hercules-ci/arion</code>’s</a> <code>lib.build</code> function.</p>
<p>However, the arion’s <code>nixos</code> config option was removed.</p>
<p>As Standard claims to be the integration layer it will not delegate integration via a foreign
interface to commissioned tools, such as arion.</p>
<p>This is a bridge towards and from docker-compose users. Making nixos part of the interface would
likely alienate that bridge for those users.</p>
<p>If you need a nixos-based container image, please check out the arion source code on how it’s done.</p>
</div>
</div>
<div class="std-target">
<h3 id="targets-mkMakes">
<a class="header" href="reference/lib.html#targets-mkMakes">Target: <code>mkMakes</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="mkmakes"><a class="header" href="#mkmakes"><code>mkMakes</code></a></h6>
<p>… provides an interface to <code>makes</code> tasks</p>
<p>This is an integration for <a href="https://github.com/fluidattacks/makes"><code>fluidattacks/makes</code></a>.</p>
<p>A version that has this <a href="https://github.com/fluidattacks/makes/commit/cd8c4eda69e2ce8dc6f811973ba0d80070b4628a">patch</a> is a prerequisite.</p>
<h6 id="usage-example"><a class="header" href="#usage-example">Usage example</a></h6>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs.std.lib) dev;
in {
  task = ops.mkMakes ./path/to/make/task//main.nix {};
}
</code></pre>
<p><em>Some refactoring of the tasks may be necessary. Let the error messages be your friend.</em></p>
<hr />
</div>
</div>
<div class="std-target">
<h3 id="targets-mkNixago">
<a class="header" href="reference/lib.html#targets-mkNixago">Target: <code>mkNixago</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="mknixago"><a class="header" href="#mknixago"><code>mkNixago</code></a></h6>
<p>This is a transparent convenience proxy for <a href="https://github.com/nix-community/nixago"><code>nix-community/nixago</code>’s</a> <code>lib.${system}.make</code> function.</p>
<p>It is enriched with a forward contract towards <code>std</code> enriched <code>mkShell</code> implementation.</p>
<p>In order to define <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code>’s</a> <code>commands</code> &amp; <code>packages</code> alongside the Nixago pebble,
just add the following attrset to the Nixago spec. It will be picked up automatically by <code>mkShell</code> when that pebble
is used inside its <code>config.nixago</code>-option.</p>
<pre><code class="language-nix">{ inputs, cell }: {
  foo = inputs.std.lib.dev.mkNixago {
    /* ... */
    packages = [ /* ... */ ];
    commands = [ /* ... */ ];
    devshell = { /* ... */ }; # e.g. for startup hooks
  };
}
</code></pre>
</div>
</div>
<div class="std-target">
<h3 id="targets-mkShell">
<a class="header" href="reference/lib.html#targets-mkShell">Target: <code>mkShell</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="mkshell"><a class="header" href="#mkshell"><code>mkShell</code></a></h6>
<p>This is a transparent convenience proxy for <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code>’s</a> <code>mkShell</code> function.</p>
<p>It is enriched with a tight integration for <code>std</code> <a href="https://github.com/nix-community/nixago">Nixago</a> pebbles:</p>
<pre><code class="language-nix">{ inputs, cell}: {
  default = inputs.std.lib.dev.mkShell {
    /* ... */
    nixago = [
      (cell.nixago.foo {
        data.qux = "xyz";
        packages = [ pkgs.additional-package ];
      })
      cell.nixago.bar
      cell.nixago.quz
    ];
  };
}
</code></pre>
<p><em>Note, that you can extend any Nixago Pebble at the calling site
via a built-in functor like in the example above.</em></p>
</div>
</div>
<div class="std-block">
<h2 id="blocks-ops">
<a class="header" href="reference/lib.html#blocks-ops">Block: <code>ops</code></a>
</h2>
<div class="std-readme-md">
<h4 id="the-ops-library"><a class="header" href="#the-ops-library">The Ops Library</a></h4>
<p>This library covers <em>operational</em> aspects of the SDLC.</p>
</div>
</div>
<div class="std-target">
<h3 id="targets-mkMicrovm">
<a class="header" href="reference/lib.html#targets-mkMicrovm">Target: <code>mkMicrovm</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="mkmicrovm"><a class="header" href="#mkmicrovm"><code>mkMicrovm</code></a></h6>
<p>… provides an interface to <code>microvm</code> tasks</p>
<p>This is an integration for <a href="https://github.com/astro/microvm.nix"><code>astro/microvm.nix</code></a>.</p>
<h6 id="usage-example-1"><a class="header" href="#usage-example-1">Usage example</a></h6>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs.std.lib) ops;
in {
  # microvm &lt;module&gt;
  myhost = ops.mkMicrovm ({ pkgs, lib, ... }: { networking.hostName = "microvms-host";});
}
</code></pre>
<hr />
</div>
</div>
<div class="std-target">
<h3 id="targets-mkOCI">
<a class="header" href="reference/lib.html#targets-mkOCI">Target: <code>mkOCI</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="mkoci"><a class="header" href="#mkoci"><code>mkOCI</code></a></h6>
<p>… is a function to generate an OCI Image via <a href="https://github.com/nlewo/nix2container"><code>nix2container</code></a>.</p>
<p>The function signature is as follows:</p>
<pre><code class="language-nix">  Creates an OCI container image

  Args:
  name: The name of the image.
  entrypoint: The entrypoint of the image. Must be a derivation.
  tag: Optional tag of the image (defaults to output hash)
  setup: A list of setup tasks to run to configure the container.
  uid: The user ID to run the container as.
  gid: The group ID to run the container as.
  perms: A list of permissions to set for the container.
  labels: An attribute set of labels to set for the container. The keys are
  automatically prefixed with "org.opencontainers.image".
  config: Additional options to pass to nix2container.buildImage's config.
  options: Additional options to pass to nix2container.buildImage.

  Returns:
  An OCI container image (created with nix2container).
  */
</code></pre>
</div>
</div>
<div class="std-target">
<h3 id="targets-mkOperable">
<a class="header" href="reference/lib.html#targets-mkOperable">Target: <code>mkOperable</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="mkoperable"><a class="header" href="#mkoperable"><code>mkOperable</code></a></h6>
<p>… is a function interface into the <a href="reference//patterns/four-packaging-layers.html#operable-layer">second layer of packaging</a> of the Standard SDLC Packaging pattern.</p>
<p>It’s purpose is to provide an easy way to enrich a “package” into an “operable”.</p>
<p>The function signature is as follows:</p>
<pre><code class="language-nix">  Args:
  package: The package to wrap.
  runtimeScript: A bash script to run at runtime.
  runtimeEnv: An attribute set of environment variables to set at runtime.
  runtimeInputs: A list of packages to add to the runtime environment.
  runtimeShell: The runtime shell. Defaults to bash.
  debugInputs: A list of packages available in the debug shell.
  livenessProbe: An optional derivation to run to check if the program is alive.
  readinessProbe: An optional derivation to run to check if the program is ready.

  Returns:
  An operable for the given package.
  */
  {
    package,
</code></pre>
</div>
</div>
<div class="std-target">
<h3 id="targets-mkStandardOCI">
<a class="header" href="reference/lib.html#targets-mkStandardOCI">Target: <code>mkStandardOCI</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="mkstandardoci"><a class="header" href="#mkstandardoci"><code>mkStandardOCI</code></a></h6>
<p>… is a function interface into the <a href="reference//patterns/four-packaging-layers.html#oci-image-layer">third layer of packaging</a> of the Standard SDLC Packaging pattern.</p>
<p>It produces a Standard OCI Image from an <a href="reference/./mkOperable.html">“operable”</a>.</p>
<p>The function signature is as follows:</p>
<pre><code class="language-nix">  Creates an OCI container image using the given operable.

  Args:
  name: The name of the image.
  operable: The operable to wrap in the image.
  tag: Optional tag of the image (defaults to output hash)
  setup: A list of setup tasks to run to configure the container.
  uid: The user ID to run the container as.
  gid: The group ID to run the container as.
  perms: A list of permissions to set for the container.
  labels: An attribute set of labels to set for the container. The keys are
  automatically prefixed with "org.opencontainers.image".
  debug: Whether to include debug tools in the container (coreutils).
  config: Additional options to pass to nix2container.buildImage's config.
  options: Additional options to pass to nix2container.

  Returns:
  An OCI container image (created with nix2container).
  */
</code></pre>
<h6 id="the-standard-image"><a class="header" href="#the-standard-image">The Standard Image</a></h6>
<p>Standard images are minimal and hardened. They only contain required dependencies.</p>
<h6 id="contracts"><a class="header" href="#contracts">Contracts</a></h6>
<p>The following contracts can be consumed:</p>
<pre><code>/bin/entrypoint # always present
/bin/runtime    # always present, drops into the runtime environment
/bin/live       # if livenessProbe was set
/bin/ready      # if readinessProbe was set
</code></pre>
<p>That’s it. There is nothing more to see.</p>
<p>All other dependencies are contained in <code>/nix/store/...</code>.</p>
<h6 id="the-debug-image"><a class="header" href="#the-debug-image">The Debug Image</a></h6>
<p>Debug Images wrap the standard images and provide additional debugging packages.</p>
<p>Hence, they are neither minimal, nor hardened because of the debugging packages’ added surface.</p>
<h6 id="contracts-1"><a class="header" href="#contracts-1">Contracts</a></h6>
<p>The following contracts can be consumed:</p>
<pre><code>/bin/entrypoint # always present
/bin/runtime    # always present, drops into the runtime environment
/bin/debug      # always present, drops into the debugging environment
/bin/live       # if livenessProbe was set
/bin/ready      # if readinessProbe was set
</code></pre>
<h6 id="how-to-extend"><a class="header" href="#how-to-extend">How to extend?</a></h6>
<p>A Standard or Debug Image doesn’t have a package manager available in the environment.</p>
<p>Hence, to extend the image you have two options:</p>
<h6 id="nix-based-extension"><a class="header" href="#nix-based-extension">Nix-based extension</a></h6>
<pre><code class="language-nix">rec {
  upstream = n2c.pullImage {
    imageName = "docker.io/my-upstream-image";
    imageDigest = "sha256:fffff.....";
    sha256 = "sha256-ffffff...";
  };
  modified = n2c.buildImage {
    name = "docker.io/my-modified-image";
    fromImage = upstream;
    contents = [nixpkgs.bashInteractive];
  };
}
</code></pre>
<h6 id="dockerfile-based-extension"><a class="header" href="#dockerfile-based-extension">Dockerfile-based extension</a></h6>
<pre><code class="language-Dockerfile">FROM alpine AS builder
RUN apk --no-cache curl

FROM docker.io/my-upstream-image
COPY --from=builder /... /

</code></pre>
<p><em>Please refer to the official dockerfile documentation for more details.</em></p>
</div>
</div>
<div class="std-target">
<h3 id="targets-readYAML">
<a class="header" href="reference/lib.html#targets-readYAML">Target: <code>readYAML</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="readyaml"><a class="header" href="#readyaml"><code>readYAML</code></a></h6>
<p>… is a function that parses YAML into Nix.</p>
<p>The only argument is a <code>path</code>.</p>
</div>
</div>
<div class="std-block">
<h2 id="blocks-cfg">
<a class="header" href="reference/lib.html#blocks-cfg">Block: <code>cfg</code></a>
</h2>
<div class="std-readme-md">
<h4 id="the-cfg-library"><a class="header" href="#the-cfg-library">The Cfg Library</a></h4>
<p>Standard comes packages with some <a href="https://github.com/nix-community/nixago">Nixago</a> Pebbles for easy
downstream re-use.</p>
<p>Some Pebbles may have a special integration for <code>std</code>.</p>
<p>For example, the <code>conform</code> Pebble can undestand <code>inputs.cells</code>
and add each Cell as a so called “scope” to its
<a href="https://www.conventionalcommits.org/">Conventional Commit</a> configuration.</p>
<hr />
<p>If you’re rather looking for Nixago Presets (i.e. pebbles that already have an opinionated default), please refer to the <a href="reference/../../../reference/presets/nixago"><em>nixago presets</em></a>, instead.</p>
</div>
</div>
<div class="std-target">
<h3 id="targets-adrgen">
<a class="header" href="reference/lib.html#targets-adrgen">Target: <code>adrgen</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="adrgen"><a class="header" href="#adrgen"><code>adrgen</code></a></h6>
<p><a href="https://github.com/asiermarques/adrgen"><code>adrgen</code></a> is a great tool to manage Architecture Decision Records.</p>
<hr />
<h6 id="definition"><a class="header" href="#definition">Definition:</a></h6>
<pre><code class="language-nix">let
  inherit (inputs) nixpkgs;
in {
  data = {};
  output = "adrgen.config.yml";
  format = "yaml";
  commands = [{package = nixpkgs.adrgen;}];
}
</code></pre>
</div>
</div>
<div class="std-target">
<h3 id="targets-conform">
<a class="header" href="reference/lib.html#targets-conform">Target: <code>conform</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="conform"><a class="header" href="#conform"><code>conform</code></a></h6>
<p><a href="https://github.com/siderolabs/conform">Conform</a> your code to policies, e.g. in a pre-commit hook.</p>
<p>This version is wrapped, it can auto-enhance the conventional
commit scopes with your <code>cells</code> as follows:</p>
<pre><code class="language-nix">{ inputs, cell}: let
  inherit (inputs.std) lib;
in {

  default = lib.dev.mkShell {
    /* ... */
    nixago = [
      (lib.cfg.conform {data = {inherit (inputs) cells;};})
    ];
  };
}
</code></pre>
<hr />
<h6 id="definition-1"><a class="header" href="#definition-1">Definition:</a></h6>
<pre><code class="language-nix">let
  l = nixpkgs.lib // builtins;
  inherit (inputs) nixpkgs;
in {
  data = {};
  format = "yaml";
  output = ".conform.yaml";
  packages = [nixpkgs.conform];
  apply = d: {
    policies =
      []
      ++ (l.optional (d ? commit) {
        type = "commit";
        spec =
          d.commit
          // l.optionalAttrs (d ? cells) {
            conventional =
              d.commit.conventional
              // {
                scopes =
                  d.commit.conventional.scopes
                  ++ (l.subtractLists l.systems.doubles.all (l.attrNames d.cells));
              };
          };
      })
      ++ (l.optional (d ? license) {
        type = "license";
        spec = d.license;
      });
  };
}
</code></pre>
</div>
</div>
<div class="std-target">
<h3 id="targets-editorconfig">
<a class="header" href="reference/lib.html#targets-editorconfig">Target: <code>editorconfig</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="editorconfig"><a class="header" href="#editorconfig"><code>editorconfig</code></a></h6>
<p>Most editors understand the <a href="https://github.com/editorconfig/"><code>.editorconfig</code></a> file and autoconfigure themselves accordingly.</p>
<hr />
<h6 id="definition-2"><a class="header" href="#definition-2">Definition:</a></h6>
<pre><code class="language-nix">let
  l = nixpkgs.lib // builtins;
  inherit (inputs) nixpkgs;
in {
  data = {};
  output = ".editorconfig";
  engine = request: let
    inherit (request) data output;
    name = l.baseNameOf output;
    value = {
      globalSection = {root = data.root or true;};
      sections = l.removeAttrs data ["root"];
    };
  in
    nixpkgs.writeText name (l.generators.toINIWithGlobalSection {} value);
  packages = [nixpkgs.editorconfig-checker];
}
</code></pre>
</div>
</div>
<div class="std-target">
<h3 id="targets-githubsettings">
<a class="header" href="reference/lib.html#targets-githubsettings">Target: <code>githubsettings</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="githubsettings"><a class="header" href="#githubsettings"><code>githubsettings</code></a></h6>
<p>Syncs repository settings defined in <code>.github/settings.yml</code> to GitHub, enabling Pull Requests for repository settings.</p>
<p>In order to use this, you also need to install <a href="https://github.com/apps/settings">Github Settings App</a>.
Please see the App’s Homepage for the configuration schema.</p>
<hr />
<h6 id="definition-3"><a class="header" href="#definition-3">Definition:</a></h6>
<pre><code class="language-nix">{
  data = {};
  output = ".github/settings.yml";
  format = "yaml";
  hook.mode = "copy"; # let the Github Settings action pick it up outside of devshell
}
</code></pre>
</div>
</div>
<div class="std-target">
<h3 id="targets-just">
<a class="header" href="reference/lib.html#targets-just">Target: <code>just</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="just"><a class="header" href="#just"><code>just</code></a></h6>
<p><a href="https://github.com/casey/just">Just</a> is a general purpose command runner with syntax inspired by <code>make</code>.</p>
<p>Tasks are configured via an attribute set where the name is the name of the task
(i.e. <code>just &lt;task&gt;</code>) and the value is the task definition (see below for an
example). The generated <code>Justfile</code> should be committed to allow non-Nix users to
on-ramp without needing access to Nix.</p>
<p>Task dependencies (i.e. <code>treefmt</code> below) should be included in <code>packages</code> and
will automatically be picked up in the devshell.</p>
<pre><code class="language-nix">{ inputs, cell }:
let
  inherit (inputs) nixpkgs;
  inherit (inputs.std) lib;
in
{

  default = lib.dev.mkShell {
    /* ... */
    nixago = [
      (lib.cfg.just {
        packages = [ nixpkgs.treefmt ];
        data = {
          tasks = {
            fmt = {
              description = "Formats all changed source files";
              content = ''
                treefmt $(git diff --name-only --cached)
              '';
            };
          };
        };
      })
    ];
  };
}
</code></pre>
<p>It’s also possible to override the interpreter for a task:</p>
<pre><code class="language-nix">{
# ...
  hello = {
    description = "Prints hello world";
    interpreter = nixpkgs.python3;
    content = ''
      print("Hello, world!")
    '';
  };
}
# ...
</code></pre>
<hr />
<h6 id="definition-4"><a class="header" href="#definition-4">Definition:</a></h6>
<pre><code class="language-nix">let
  inherit (inputs) nixpkgs;
  l = nixpkgs.lib // builtins;
in {
  data = {};
  apply = d: let
    # Transforms interpreter attribute if present
    # nixpkgs.pkgname -&gt; nixpkgs.pkgname + '/bin/&lt;name&gt;'
    getExe = x: "${l.getBin x}/bin/${x.meta.mainProgram or (l.getName x)}";
    final =
      d
      // {
        tasks =
          l.mapAttrs
          (n: v:
            v // l.optionalAttrs (v ? interpreter) {interpreter = getExe v.interpreter;})
          d.tasks;
      };
  in {
    data = final; # CUE expects structure to be wrapped with "data"
  };
  format = "text";
  output = "Justfile";
  packages = [nixpkgs.just];
  hook = {
    mode = "copy";
  };
  engine = inputs.nixago.engines.cue {
    files = [./just.cue];
    flags = {
      expression = "rendered";
      out = "text";
    };
    postHook = ''
      ${l.getExe nixpkgs.just} --unstable --fmt -f $out
    '';
  };
}
</code></pre>
</div>
</div>
<div class="std-target">
<h3 id="targets-lefthook">
<a class="header" href="reference/lib.html#targets-lefthook">Target: <code>lefthook</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="lefthook"><a class="header" href="#lefthook"><code>lefthook</code></a></h6>
<p><a href="https://github.com/evilmartians/lefthook">Lefthook</a> is a fast (parallel execution) and elegant git hook manager.</p>
<hr />
<h6 id="definition-5"><a class="header" href="#definition-5">Definition:</a></h6>
<pre><code class="language-nix">let
  inherit (inputs) nixpkgs;
  lib = nixpkgs.lib // builtins;

  mkScript = stage:
    nixpkgs.writeScript "lefthook-${stage}" ''
      #!${nixpkgs.runtimeShell}
      [ "$LEFTHOOK" == "0" ] || ${lib.getExe nixpkgs.lefthook} run "${stage}" "$@"
    '';

  toStagesConfig = config:
    lib.removeAttrs config [
      "colors"
      "extends"
      "skip_output"
      "source_dir"
      "source_dir_local"
    ];
in {
  data = {};
  format = "yaml";
  output = "lefthook.yml";
  packages = [nixpkgs.lefthook];
  # Add an extra hook for adding required stages whenever the file changes
  hook.extra = config:
    lib.pipe config [
      toStagesConfig
      lib.attrNames
      (lib.map (stage: ''ln -sf "${mkScript stage}" ".git/hooks/${stage}"''))
      (stages:
        lib.optional (stages != []) "mkdir -p .git/hooks"
        ++ stages)
      (lib.concatStringsSep "\n")
    ];
}
</code></pre>
</div>
</div>
<div class="std-target">
<h3 id="targets-mdbook">
<a class="header" href="reference/lib.html#targets-mdbook">Target: <code>mdbook</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="mdbook"><a class="header" href="#mdbook"><code>mdbook</code></a></h6>
<p>Write clean docs for humans with <a href="https://github.com/rust-lang/mdBook"><code>mdbook</code></a>.</p>
<p>This version comes preset with this gem to make any
Solution Architect extra happy: <a href="https://github.com/joelcourtney/mdbook-kroki-preprocessor"><code>mdbook-kroki-preprocessor</code></a></p>
<hr />
<h6 id="definition-6"><a class="header" href="#definition-6">Definition:</a></h6>
<pre><code class="language-nix">let
  inherit (inputs) nixpkgs;
in {
  data = {};
  output = "book.toml";
  format = "toml";
  hook.extra = d: let
    sentinel = "nixago-auto-created: mdbook-build-folder";
    file = ".gitignore";
    str = ''
      # ${sentinel}
      ${d.build.build-dir or "book"}/**
    '';
  in ''
    # Configure gitignore
    create() {
      echo -n "${str}" &gt; "${file}"
    }
    append() {
      echo -en "\n${str}" &gt;&gt; "${file}"
    }
    if ! test -f "${file}"; then
      create
    elif ! grep -qF "${sentinel}" "${file}"; then
      append
    fi
  '';
  commands = [{package = nixpkgs.mdbook;}];
}
</code></pre>
</div>
</div>
<div class="std-target">
<h3 id="targets-treefmt">
<a class="header" href="reference/lib.html#targets-treefmt">Target: <code>treefmt</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="treefmt"><a class="header" href="#treefmt"><code>treefmt</code></a></h6>
<p>A <a href="https://github.com/numtide/treefmt">code-tree formatter</a> to fromat the entire code tree extremly fast (in parallel and with a smart cache).</p>
<hr />
<h6 id="definition-7"><a class="header" href="#definition-7">Definition:</a></h6>
<pre><code class="language-nix">let
  inherit (inputs) nixpkgs;
in {
  data = {};
  output = "treefmt.toml";
  format = "toml";
  commands = [{package = nixpkgs.treefmt;}];
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div class="sidetoc"><nav class="pagetoc"></nav></div>
<p><em>Autogenerated documentation from <code>./src/std/*</code>.</em></p>
<div class="std-cell">
<h1 id="cells-std">
<a class="header" href="reference/std.html#cells-std">Cell: <code>std</code></a>
</h1>
<div class="std-readme-md">
<h2 id="the-std-cell"><a class="header" href="#the-std-cell">The <code>std</code> Cell</a></h2>
<p>… is the only cell in <code>divnix/std</code> and provides only very limited functionality.</p>
<ul>
<li>It contains the TUI, in <code>./cli</code>.</li>
<li>It contains a <code>devshellProfile</code> in <code>./devshellProfiles</code>.</li>
<li>It contains a growing number of second level library functions in <code>./lib</code>.</li>
<li>Packages that are used in std devshells are proxied in <code>./packages</code>.</li>
</ul>
<p>That’s it.</p>
</div>
</div>
<div class="std-blockstd-no-readme">
<h2 id="blocks-cli">
<a class="header" href="reference/std.html#blocks-cli">Block: <code>cli</code></a>
</h2>
<div class="std-readme-md">
<small><i>No documentation</i></small>
</div>
</div>
<div class="std-block">
<h2 id="blocks-devshellProfiles">
<a class="header" href="reference/std.html#blocks-devshellProfiles">Block: <code>devshellProfiles</code></a>
</h2>
<div class="std-readme-md">
<h3 id="stds-devshellprofiles"><a class="header" href="#stds-devshellprofiles"><code>std</code>’s <code>devshellProfiles</code></a></h3>
<p>This Cell Block only exports a single <code>default</code> devshellProfile.</p>
<p>Any <code>std</code>ized repository should include this into its <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code></a>
in order to provide any visitor with the fully pre-configured <code>std</code> TUI.</p>
<p>It also wires &amp; instantiates a decent ADR tool. Or were you planning to hack away
without some minimal conscious effort of decision making and recording? 😅</p>
<h3 id="usage-example-2"><a class="header" href="#usage-example-2">Usage Example</a></h3>
<pre><code class="language-nix"># ./nix/local/shells.nix
{
  inputs,
  cell,
}: let
  l = nixpkgs.lib // builtins;
  inherit (inputs) nixpkgs;
  inherit (inputs.std) std;
in
  l.mapAttrs (_: std.lib.mkShell) {
    # `default` is a special target in newer nix versions
    # see: harvesting below
    default = {
      name = "My Devshell";
      # make `std` available in the numtide/devshell
      imports = [ std.devshellProfiles.default ];
    };
  }
</code></pre>
<pre><code class="language-nix"># ./flake.nix
{
  inputs.std.url = "github:divnix/std";

  outputs = inputs:
    inputs.std.growOn {
      inherit inputs;
      cellsFrom = ./nix;
      cellBlocks = [
        /* ... */
        (inputs.std.blockTypes.devshells "shells")
      ];
    }
    # soil for compatiblity ...
    {
      # ... with `nix develop` - `default` is a special target for `nix develop`
      devShells = inputs.std.harvest inputs.self ["local" "shells"];
    };
}
</code></pre>
<hr />
</div>
</div>
<div class="std-block">
<h2 id="blocks-errors">
<a class="header" href="reference/std.html#blocks-errors">Block: <code>errors</code></a>
</h2>
<div class="std-readme-md">
<h4 id="error-message-functions"><a class="header" href="#error-message-functions">Error Message Functions</a></h4>
<p>This Cell Block comprises several error message functions that can be used in different situations.</p>
</div>
</div>
<div class="std-target">
<h3 id="targets-removeBy">
<a class="header" href="reference/std.html#targets-removeBy">Target: <code>removeBy</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="removeby"><a class="header" href="#removeby"><code>removeBy</code></a></h6>
<pre><code class="language-nix">{inputs}: time: body: let
  l = inputs.nixpkgs.lib // builtins;
  ansi = import ./ansi.nix;
  pad = s: let
    n = 17;
    prefix = l.concatStringsSep "" (l.genList (_: " ") (n - (l.stringLength s)));
  in
    prefix + s;
  indent = s: let
    n = 5;
    prefix = l.concatStringsSep "" (l.genList (_: " ") n);
    lines = l.splitString "\n" s;
  in
    "  📝 │ " + (l.concatStringsSep "\n${prefix}│ " lines);
  warn = let
    apply =
      l.replaceStrings
      (map (key: "{${key}}") (l.attrNames ansi))
      (l.attrValues ansi);
  in
    msg:
      l.trace (apply "🔥 {bold}{196}Standard Deprecation Notices - {220}run `std check' to show!{reset}")
      l.traceVerbose (apply "\n{202}${msg}{reset}");
in
  warn ''
    ─────┬─────────────────────────────────────────────────────────────────────────
      💪 │ {bold}Action Required !{un-bold}
    ─────┼─────────────────────────────────────────────────────────────────────────
    {italic}${indent body}{un-italic}
    ─────┼─────────────────────────────────────────────────────────────────────────
      📅 │ {bold}Scheduled Removal: ${pad time}{un-bold}
    ─────┴─────────────────────────────────────────────────────────────────────────
  ''
</code></pre>
</div>
</div>
<div class="std-target">
<h3 id="targets-requireInput">
<a class="header" href="reference/std.html#targets-requireInput">Target: <code>requireInput</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h6 id="requireinput"><a class="header" href="#requireinput"><code>requireInput</code></a></h6>
<pre><code class="language-nix">{inputs}: input: url: target: let
  l = inputs.nixpkgs.lib // builtins;

  # other than `divnix/blank`
  isBlank = input: inputs.${input}.narHash == "sha256-O8/MWsPBGhhyPoPLHZAuoZiiHo9q6FLlEeIDEXuj6T4=";

  ansi = import ./ansi.nix;

  pad = n: s: let
    prefix = l.concatStringsSep "" (l.genList (_: " ") n);
  in
    prefix + s;

  indent = s: let
    n = 5;
    prefix = l.concatStringsSep "" (l.genList (_: " ") n);
    lines = l.splitString "\n" s;
  in
    l.concatStringsSep "\n${prefix}│ " lines;

  warn = let
    apply =
      l.replaceStrings
      (map (key: "{${key}}") (l.attrNames ansi))
      (l.attrValues ansi);
  in
    msg: l.trace (apply "🚀 {bold}{200}Standard Input Overloading{reset}${msg}") "";

  body = ''
    In order to use ${target}, add to {bold}flake.nix{un-bold}:

      inputs.std.inputs.${input}.url = "${url}";
  '';

  inputs' = let
    names = l.attrNames (l.removeAttrs inputs ["self" "cells" "blank" "nixpkgs"]);
    nameLengths = map l.stringLength names;
    maxNameLength =
      l.foldl'
      (max: v:
        if v &gt; max
        then v
        else max)
      0
      nameLengths;

    lines =
      l.map (
        name: "- ${name}${
          if isBlank name
          then pad (maxNameLength - (l.stringLength name)) " | blanked out"
          else ""
        }"
      )
      names;
  in
    "Declared Inputs:\n" + (l.concatStringsSep "\n" lines);
in
  assert l.assertMsg (! (isBlank input)) (warn ''

    ─────┬─────────────────────────────────────────────────────────────────────────
      🏗️  │ {bold}Input Overloading for ${target}{un-bold}
    ─────┼─────────────────────────────────────────────────────────────────────────
      📝 │ {italic}${indent body}{un-italic}
    ─────┼─────────────────────────────────────────────────────────────────────────
      🙋 │ ${indent inputs'}
    ─────┴─────────────────────────────────────────────────────────────────────────
  ''); inputs
</code></pre>
</div>
</div>
<div class="std-block">
<h2 id="blocks-templates">
<a class="header" href="reference/std.html#blocks-templates">Block: <code>templates</code></a>
</h2>
<div class="std-readme-md">
<h3 id="nix-templates"><a class="header" href="#nix-templates">Nix Templates</a></h3>
<p>These are opinionated template projects designed to get you kick-started.</p>
<p>You can make use of them through the Nix CLI, via:</p>
<pre><code class="language-bash">cd my-new-project
nix flake init -t github:divnix/std#&lt;template-name&gt;
</code></pre>
<p>Please consult the template section in the <a href="https://std.divnix.com/">docs</a> for an overview.</p>
</div>
</div>
<div class="std-target">
<h3 id="targets-minimal">
<a class="header" href="reference/std.html#targets-minimal">Target: <code>minimal</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h4 id="a-minimal-project-template-with-docs-1"><a class="header" href="#a-minimal-project-template-with-docs-1">A minimal project template with docs!</a></h4>
<h5 id="included-configuration-1"><a class="header" href="#included-configuration-1">Included Configuration</a></h5>
<ul>
<li><a href="https://numtide.github.io/devshell/"><code>devshell</code></a> for your contribution environments!</li>
<li><a href="https://numtide.github.io/treefmt/"><code>treefmt</code></a> for formatting all the things!</li>
<li><a href="https://rust-lang.github.io/mdBook/"><code>mdbook</code></a> for making documentation part of your workflow!</li>
<li><a href="https://github.com/evilmartians/lefthook"><code>lefthook</code></a> for commit discipline and a clean history!</li>
<li><a href="https://github.com/apps/settings">GitHub Setting App</a> for configuring GitHub declaratively!</li>
</ul>
<h5 id="bootstrap-2"><a class="header" href="#bootstrap-2">Bootstrap</a></h5>
<pre><code class="language-bash"># make a new empty project dir
mkdir my-project
cd my-project

# grab the template
nix flake init -t github:divnix/std#minimal

# see which values to change
grep -r --include=\*.nix 'CONFIGURE-ME' .

# do some inititialization
git init &amp;&amp; git add .

# enter the devshell and effectuate repo configuration
direnv allow

git add . &amp;&amp; git commit -m "feat: initial commit"
</code></pre>
</div>
</div>
<div class="std-target">
<h3 id="targets-rust">
<a class="header" href="reference/std.html#targets-rust">Target: <code>rust</code></a>
</h3>
<small class="std-description"><i>
No description
<p></i></small></p>
<div class="std-readme-md">
<h4 id="standard-and-nix-and-rust-oh-my-1"><a class="header" href="#standard-and-nix-and-rust-oh-my-1">Standard, and Nix and Rust, oh my!</a></h4>
<p>This template uses <a href="https://nixos.org">Nix</a> to create a sane development shell for
Rust projects, <a href="https://github.com/divnix/std#readme">Standard</a> for keeping your Nix code well organized,
<a href="https://github.com/nix-community/fenix#readme">Fenix</a> for pulling the latest rust binaries via Nix, and
<a href="https://github.com/ipetkov/crane#readme">Crane</a> for building Rust projects in Nix incrementally, making
quick iteration a breeze.</p>
<p>Rust Analyzer is also wired up properly for immediate use from a
terminal based editor with language server support. Need one with
stellar Nix and Rust support? Try <a href="https://github.com/helix-editor/helix#readme">Helix</a>!</p>
<h5 id="bootstrap-3"><a class="header" href="#bootstrap-3">Bootstrap</a></h5>
<pre><code class="language-bash"># make a new empty project dir
mkdir my-project
cd my-project

# grab the template
nix flake init -t github:divnix/std#rust

# do some inititialization
git init &amp;&amp; git add .

# enter the devshell
direnv allow || nix develop

# continue some inititialization
cargo init # pass --lib for library projects
cargo build # to generate Cargo.lock

git add . &amp;&amp; git commit -m "init"
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p><strong>Cell</strong></p>
<p>: A Cell is the folder name of the first level under <code>${cellsFrom}</code>. They represent a coherent semantic collection of functionality.</p>
<p><strong>Cell Block</strong></p>
<p>: A Cell Block is the specific <em>named type</em> of a Standard (and hence: Flake) output.</p>
<p><strong>Block Type</strong></p>
<p>: A Block Type is the unnamed generic type of a Cell Block and may or may not implement Block Type Actions.</p>
<p><strong>Target</strong></p>
<p>: A Target is the actual output of a Cell Block. If there is only one intended output, it is called <code>default</code> by convention.</p>
<p><strong>Action</strong></p>
<p>: An Action is a runnable procedure implemented on the generic Block Type type. These are abstract procedures that are valuable in any concrete Cell Block of such Block Type.</p>
<p><strong>The Registry</strong></p>
<p>: The Registry, in the context of Standard and if it doesn't refer to a well-known external concept, means the <code>.#__std</code> flake output. This Registry holds different Registers that serve different discovery purposes. For example, the CLI can discover relevant metadata or a CI can discover desired pipeline targets.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="docs/theme/pagetoc.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
