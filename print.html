<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Standard Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="ARCHITECTURE.html">Design & Architecture</a></li><li class="chapter-item expanded affix "><a href="PITCH.html">Sales Pitch</a></li><li class="chapter-item expanded affix "><a href="COMPARE.html">Comparisions</a></li><li class="chapter-item expanded affix "><a href="ROADMAP.html">Roadmap</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="tutorials/walk-in-the-park.html"><strong aria-hidden="true">1.</strong> A walk in the park</a></li><li class="chapter-item expanded "><a href="tutorials/hello-world/index.html"><strong aria-hidden="true">2.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="tutorials/hello-moon/index.html"><strong aria-hidden="true">3.</strong> Hello Moon</a></li><li class="chapter-item expanded affix "><li class="part-title">How-To Guides</li><li class="chapter-item expanded "><a href="guides/growing-cells.html"><strong aria-hidden="true">4.</strong> Growing Cells</a></li><li class="chapter-item expanded "><a href="guides/incl.html"><strong aria-hidden="true">5.</strong> Include Filter</a></li><li class="chapter-item expanded "><a href="guides/envrc.html"><strong aria-hidden="true">6.</strong> Setup .envrc</a></li><li class="chapter-item expanded affix "><li class="part-title">Explanation</li><li class="chapter-item expanded "><a href="explain/why-nix.html"><strong aria-hidden="true">7.</strong> Why nix?</a></li><li class="chapter-item expanded "><a href="explain/why-std.html"><strong aria-hidden="true">8.</strong> Why std?</a></li><li class="chapter-item expanded "><a href="explain/architecture-decision-records/index.html"><strong aria-hidden="true">9.</strong> Architecture Decisions</a></li><li class="chapter-item expanded affix "><li class="part-title">Patterns</li><li class="chapter-item expanded "><a href="patterns/four-packaging-layers.html"><strong aria-hidden="true">10.</strong> The 4 Packaging Layers</a></li><li class="chapter-item expanded affix "><li class="part-title">Templates</li><li class="chapter-item expanded "><a href="templates/minimal.html"><strong aria-hidden="true">11.</strong> Minimal</a></li><li class="chapter-item expanded "><a href="templates/rust.html"><strong aria-hidden="true">12.</strong> Rust</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/cli.html"><strong aria-hidden="true">13.</strong> TUI/CLI</a></li><li class="chapter-item expanded "><a href="reference/conventions.html"><strong aria-hidden="true">14.</strong> Conventions</a></li><li class="chapter-item expanded "><a href="reference/deprecations.html"><strong aria-hidden="true">15.</strong> Deprecations</a></li><li class="chapter-item expanded "><a href="reference/blocktypes.html"><strong aria-hidden="true">16.</strong> Builtin Block Types</a></li><li class="chapter-item expanded "><a href="reference/lib.html"><strong aria-hidden="true">17.</strong> Cell: lib</a></li><li class="chapter-item expanded "><a href="reference/std.html"><strong aria-hidden="true">18.</strong> Cell: std</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">19.</strong> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Standard Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
SPDX-FileCopyrightText: 2022 The Standard Authors
SPDX-FileCopyrightText: 2022 Kevin Amado <kamadorueda@gmail.com>

SPDX-License-Identifier: Unlicense
-->
<div align="center">
  <img src="https://github.com/divnix/std/raw/main/artwork/logo.png" width="250" />
  <h1 id="standard"><a class="header" href="#standard">Standard</a></h1>
  <p>Ship today.</span>
</div>
<!--
_By [Kevin Amado](https://github.com/kamadorueda),
with contributions from [David Arnold](https://github.com/blaggacao),
[Timothy DeHerrera](https://github.com/nrdxp)
and many more amazing people (see end of file for a full list)._
-->
<hr />
<p><a href="https://github.com/divnix/std">Standard</a> is a nifty DevOps framework that
enables an efficient Software Development Life Cycle (SDLC) with the power of <a href="https://nixos.org/manual/nix/unstable">Nix</a> via <a href="https://nixos.wiki/wiki/Flakes">Flakes</a>.</p>
<p>It organizes and disciplines your Nix and thereby speeds you up.
It also comes with great horizontal integrations of high
quality vertical DevOps tooling crafted by the <a href="https://discourse.nixos.org">Nix Ecosystem</a>.</p>
<hr />
<p><a href="https://matrix.to/#/#std-nix:matrix.org"><img src="https://img.shields.io/matrix/std-nix:matrix.org?server_fqdn=matrix.org&amp;style=for-the-badge" alt="Support room on Matrix" /></a></p>
<h6 id="stack"><a class="header" href="#stack">Stack</a></h6>
<p><a href="https://github.com/divnix/yants"><img src="https://img.shields.io/badge/DivNix-Yants-green?style=for-the-badge&amp;logo=NixOS" alt="Yants" /></a>
<a href="https://github.com/divnix/data-merge"><img src="https://img.shields.io/badge/DivNix-DMerge-yellow?style=for-the-badge&amp;logo=NixOS" alt="DMerge" /></a>
<a href="https://github.com/divnix/nosys"><img src="https://img.shields.io/badge/DivNix-NoSys-orange?style=for-the-badge&amp;logo=NixOS" alt="NoSys" /></a>
<a href="https://github.com/divnix/blank"><img src="https://img.shields.io/badge/DivNix-Blank-grey?style=for-the-badge&amp;logo=NixOS" alt="Blank" /></a>
<a href="https://github.com/divnix/incl"><img src="https://img.shields.io/badge/DivNix-Incl-blue?style=for-the-badge&amp;logo=NixOS" alt="Incl" /></a>
<a href="https://github.com/divnix/paisano"><img src="https://img.shields.io/badge/DivNix-Paisano-red?style=for-the-badge&amp;logo=NixOS" alt="Paisano" /></a></p>
<h6 id="integrations"><a class="header" href="#integrations">Integrations</a></h6>
<p><a href="https://github.com/numtide/devshell"><img src="https://img.shields.io/badge/Numtide-Devshell-yellowgreen?style=for-the-badge&amp;logo=NixOS" alt="Numtide Devshell" /></a>
<a href="https://github.com/numtide/treefmt"><img src="https://img.shields.io/badge/Numtide-Treefmt-yellow?style=for-the-badge&amp;logo=NixOS" alt="Numtide Treefmt" /></a>
<a href="https://github.com/nlewo/nix2container"><img src="https://img.shields.io/badge/Nlewo-Nix2Container-blue?style=for-the-badge&amp;logo=NixOS" alt="Nlewo Nix2Container" /></a>
<a href="https://github.com/fluidattacks/makes"><img src="https://img.shields.io/badge/Fluidattacks-Makes-blue?style=for-the-badge&amp;logo=NixOS" alt="Fluidattacks Makes" /></a>
<a href="https://github.com/astro/microvm.nix"><img src="https://img.shields.io/badge/Astro-MicroVM-blue?style=for-the-badge&amp;logo=NixOS" alt="Astro MicroVM" /></a>
<a href="https://github.com/hercules-ci/flake-parts"><img src="https://img.shields.io/badge/HerculesCI-FlakeParts-lightgrey?style=for-the-badge&amp;logo=NixOS" alt="HerculesCI FlakeParts" /></a>
<a href="https://github.com/cachix"><img src="https://img.shields.io/badge/Cachix-Cache-blue?style=for-the-badge&amp;logo=NixOS" alt="Cachix Cache" /></a>
<a href="https://github.com/nix-community/nixago"><img src="https://img.shields.io/badge/NixCommunity-Nixago-yellow?style=for-the-badge&amp;logo=NixOS" alt="Nix-Community Nixago" /></a></p>
<h6 id="the-standard-story"><a class="header" href="#the-standard-story">The Standard Story</a></h6>
<p><em>Once</em> your <code>nix</code> code has evolved into a giant
ball of spaghetti and nobody else except a few
select members of your tribe can still read it
with ease; and <em>once</em> to the rest of your colleagues
it has grown into an impertinence, <em>then</em> <code>std</code>
brings the overdue order to your piece of art
through a well-defined folder structure and
disciplining generic interfaces.</p>
<p>With <code>std</code>, you'll learn how to organize your <code>nix</code>
flake outputs ('<strong>Targets</strong>') into <strong>Cells</strong> and
<strong>Cell Blocks</strong> — folded into a useful
<strong>CLI &amp; TUI</strong> to also make the lives of your
colleagues easier.</p>
<p>Through more intuition and less documentation,
your team and community will finally find a
<em>canonical</em> answer to the everlasting question:
<em>What can I <strong>do</strong> with this repository?</em></p>
<h6 id="the-standard-nixos-story-in-case-you-wondered"><a class="header" href="#the-standard-nixos-story-in-case-you-wondered">The Standard NixOS Story (in case you wondered)</a></h6>
<p><em>Once</em> you got fed up with <code>divnix/digga</code>
or a disorganized personal configuration,
please head straight over to <a href="https://github.com/divnix/hive"><code>divnix/hive</code></a>
and join the chat, there. It's work in progress.
But hey! It means: we can progress together!</p>
<hr />
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<pre><code class="language-nix"># flake.nix
{
  description = &quot;Description for the project&quot;;

  inputs = {
    std.url = &quot;github:divnix/std&quot;;
    nixpkgs.follows = &quot;std/nixpkgs&quot;;
  };

  outputs = { std, self, ...} @ inputs: std.growOn {
    inherit inputs;
    # 1. Each folder inside `cellsFrom` becomes a &quot;Cell&quot;
    #    Run for example: 'mkdir nix/mycell'
    # 2. Each &lt;block&gt;.nix or &lt;block&gt;/default.nix within it becomes a &quot;Cell Block&quot;
    #    Run for example: '$EDITOR nix/mycell/packages.nix' - see example content below
    cellsFrom = ./nix;
    # 3. Only blocks with these names [here: &quot;packages&quot; &amp; &quot;devshells&quot;] are picked up by Standard
    #    It's a bit like the output type system of your flake project (hint: CLI &amp; TUI!!)
    cellBlocks = with std.blockTypes; [
      (installables &quot;packages&quot; {ci.build = true;})
      (devshells &quot;devshells&quot; {ci.build = true;})
    ];
  }
  # 4. Run 'nix run github:divnix/std'
  # 'growOn' ... Soil:
  #  - here, compat for the Nix CLI
  #  - but can use anything that produces flake outputs (e.g. flake-parts or flake-utils)
  # 5. Run: nix run .
  {
    devShells = std.harvest self [&quot;mycell&quot; &quot;devshells&quot;];
    packages = std.harvest self [&quot;mycell&quot; &quot;packages&quot;];
  };
}

# nix/mycell/packages.nix
{inputs, cell}: {
  inherit (inputs.nixpkgs) hello;
  default = cell.packages.hello;
}
</code></pre>
<h2 id="this-repository"><a class="header" href="#this-repository">This Repository</a></h2>
<p>This repository combines the above mentioned stack components into the ready-to-use Standard framework.
It adds a curated collection of <a href="https://github.com/divnix/std/blob/main/src/blocktypes.nix"><strong>Block Types</strong></a> for DevOps use cases.
It further dogfoods itself and implements utilities in its own <a href="https://github.com/divnix/std/tree/main/cells"><strong>Cells</strong></a>.</p>
<h6 id="dogfooding"><a class="header" href="#dogfooding">Dogfooding</a></h6>
<p><sub>Only renders in the <a href="https://std.divnix.com">Documentation</a>.</sub></p>
<pre><code class="language-nix">{
  growOn,
  inputs,
  blockTypes,
  pick,
  harvest,
}:
growOn {
  inherit inputs;
  cellsFrom = ./cells;
  cellBlocks = [
    ## For downstream use

    # std
    (blockTypes.runnables &quot;cli&quot; {ci.build = true;})
    (blockTypes.functions &quot;devshellProfiles&quot;)
    (blockTypes.functions &quot;errors&quot;)
    (blockTypes.nixago &quot;nixago&quot;)
    (blockTypes.installables &quot;packages&quot; {ci.build = true;})

    # lib
    (blockTypes.functions &quot;dev&quot;)
    (blockTypes.functions &quot;ops&quot;)
    (blockTypes.nixago &quot;cfg&quot;)

    # presets
    (blockTypes.data &quot;templates&quot;)
    (blockTypes.nixago &quot;nixago&quot;)

    ## For local use in the Standard repository

    # _automation
    (blockTypes.devshells &quot;devshells&quot; {ci.build = true;})
    (blockTypes.nixago &quot;configs&quot;)
    (blockTypes.containers &quot;containers&quot;)
    # (blockTypes.tasks &quot;tasks&quot;) # TODO: implement properly

    # _tests
    (blockTypes.data &quot;data&quot;)
    (blockTypes.files &quot;files&quot;)
  ];
}
# Soil (&quot;compatibile with the entire world&quot;)
{
  devShells = harvest inputs.self [&quot;_automation&quot; &quot;devshells&quot;];
  packages = harvest inputs.self [[&quot;std&quot; &quot;cli&quot;] [&quot;std&quot; &quot;packages&quot;]];
  templates = pick inputs.self [&quot;presets&quot; &quot;templates&quot;];
}
</code></pre>
<p><em>That's it. <code>std.grow</code> is a &quot;smart&quot; importer of your <code>nix</code> code and is designed to keep boilerplate at bay. In the so called &quot;Soil&quot; compatibility layer, you can do whatever your heart desires. For example put <code>flake-utils</code> or <code>flake-parts</code> patterns here. Or, as in the above example, just make your stuff play nicely with the Nix CLI.</em></p>
<blockquote>
<p><strong>TIP:</strong></p>
<ol>
<li>Clone this repo <code>git clone https://github.com/divnix/std.git</code></li>
<li>Install <code>direnv</code> &amp; inside the repo, do: <code>direnv allow</code> (first time takes a little longer)</li>
<li>Run the TUI by entering <code>std</code> (first time takes a little longer)</li>
</ol>
<center><i>What can I <b>do</b> with this repository?</i></center>
&emsp;
</blockquote>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>The <a href="https://std.divnix.com">Documentation</a> is here.</p>
<p>And here is the <a href="https://jmgilman.github.io/std-book/">Book</a>, a very good walk-trough. Start here!</p>
<h6 id="video-series"><a class="header" href="#video-series">Video Series</a></h6>
<ul>
<li><a href="https://www.loom.com/share/cf9d5d1a10514d65bf6b8287f7ddc7d6">Std - Introduction</a></li>
<li><a href="https://www.loom.com/share/04fa1d578fd044059b02c9c052d87b77">Std - Cell Blocks Deep Dive</a></li>
<li><a href="https://www.loom.com/share/27d91aa1eac24bcaaaed18ea6d6d03ca">Std - Operables &amp; OCI</a></li>
<li><a href="https://www.loom.com/share/5c1badd77ab641d3b8e256ddbba69042">Std - Nixago</a></li>
</ul>
<h6 id="examples-in-the-wild"><a class="header" href="#examples-in-the-wild">Examples in the Wild</a></h6>
<p>This <a href="https://github.com/search?p=7&amp;q=%22divnix%2Fstd%22+filename%3Aflake.nix&amp;type=Code">GitHub search query</a> holds a pretty good answer.</p>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<ul>
<li><a href="https://std.divnix.com/explain/why-nix.html">Why <code>nix</code>?</a></li>
<li><a href="https://std.divnix.com/explain/why-std.html">Why <code>std</code>?</a></li>
</ul>
<h2 id="contributions"><a class="header" href="#contributions">Contributions</a></h2>
<p>Please enter the contribution environment:</p>
<pre><code class="language-console">direnv allow || nix develop -c &quot;$SHELL
</code></pre>
<h2 id="licenses"><a class="header" href="#licenses">Licenses</a></h2>
<p><em>What licenses are used? → <a href="https://github.com/divnix/std/blob/main/.reuse/dep5"><code>./.reuse/dep5</code></a>.</em></p>
<p><em>And the usual copies? → <a href="https://github.com/divnix/std/tree/main/LICENSES"><code>./LICENSES</code></a>.</em></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-design-and-architecture"><a class="header" href="#standard-design-and-architecture">Standard Design and Architecture</a></h1>
<p>At the time of writing, almost a year of exploratory and freestyle project history has passed.
Fortunately, it is not necessary for further understanding, so I'll spare you that.
This document, though, lays out the design, architecture and direction of Standard.</p>
<p>If the topics discussed herein are dear to you, please take it as an invitation to get involved.</p>
<p>This design document shall be stable and amendments go through a proper process of consideration.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Standard is a collection of functionality and best practices (<em>&quot;framework&quot;</em>) to bootstrap and sustain the automatable sections of the Software Development Lifecycle (SDLC) <em>efficiently</em> with the power of Nix and Flakes.
In particular, Standard is a <em>Horizontal* Integration Framework</em> which integrates <em>vertical*</em> tooling.</p>
<blockquote>
<p><sub>We occasionally adapt concepts from non-technical contexts. This is one instance.</sub></p>
<p><em>Vertical Tooling</em> does one thing and does it well in a narrow scope (i.e &quot;vertical&quot;).</p>
<p><em>Horizontal Tooling</em> stitches vertical tooling together to a polished whole.</p>
</blockquote>
<p>What is being integrated are the end-to-end automatable sections of the SDLC.
For these we curate a collection of functionality, tools and best practices.</p>
<p>An SDLCs <em>efficiency</em> is characterized by two things.</p>
<p>Firstly, by adequate <em>lead time</em> which is the amount of time it takes to set up an initial version of the software delivery pipeline.
It needs to be <em>adequate</em> rather than <em>just fast</em>, as it takes place in the context of a team.
Rather than for speed, they need optimization for success.
For example, a process needs to be documented &amp; explained and your team needs to be trained on it.
Standard encourages incremental adoption in order to leave enough space for these paramount activities.
If you're in a hurry and your team is onboard, though, you still can jumpstart its adoption.</p>
<p>Secondly, efficient SDLCs are characterized by short <em>cycle times</em> which is the amount of time it takes for a designed feature to be shipped to production.
Along this journey, we encounter our scope (more on it below):</p>
<ul>
<li>aspects of the <em>development</em> environment;</li>
<li>the packaging pipeline that produces artifacts;</li>
<li>and continuous processes integrating the application lifecycle.</li>
</ul>
<p>Hence, the goal of Standard is to:</p>
<ul>
<li>Enable easy and incremental adoption</li>
<li>Optimize the critical path that reduces your SDLC's cycle time.</li>
</ul>
<p>Additionally, unlike similar projects, we harness the power of Nix &amp; Flakes to ensure reproducibility.</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<ul>
<li><em>Complete</em>: Standard should cover the important use cases for setting up and running the automatable sections of the SDLC.</li>
<li><em>Optimized</em>: Standard should optimize both for the needs of the individual developers and the market success of the product.</li>
<li><em>Integrated</em>: Standard should provide the user with a satisfying integration experience across a well-curated assortment of tools and functionality.</li>
<li><em>Extensible</em>: Standard should account for the need to seamlessly modify, swap or extend its functionality when necessary.</li>
</ul>
<p>Please defer to the <a href="./PITCH.html">sales pitch</a>, if you need more context.</p>
<h2 id="ideals"><a class="header" href="#ideals">Ideals</a></h2>
<p>While we aim to improve the SDLC by applying Nix and its ecoysystem's ingenuity to the problem, we also want to build bridges.
In order to bring the powers of store based reproducible packaging to colleagues and friends, we need to maneuver around the ecosystem's pitfalls:</p>
<ul>
<li><em>Use nix only where it is best suited</em> — a Nix maximalist approach may be an innate condition to some of us, but to build bridges we deeply recognize and value other perspectives and don't dismiss them as ignorance.</li>
<li><em>Disrupt where disruption is necessary</em> — the Nix ecosystem has a fairly rigid set of principles and norms that we don't think always apply in every use case.</li>
<li><em>Look left, right, above and beyond</em> — our end-to-end perspective commands us to actively seek and reach out to other projects and ecosystems to compose our value chain; there's no place for the &quot;not invented here&quot;-syndrome.</li>
</ul>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>These are big goals and ideals.
In the interest of practical advancements, we'll narrow down the scope in this section.</p>
<p>We can subdivide (not break up!) our process into roughly three regions with different shapes and characteristics:</p>
<ul>
<li><strong>Development Environment</strong> roughly covers <em>code-to-commit</em>.</li>
<li><strong>Packaging Pipeline</strong> roughly covers <em>commit-to-distribution</em>.</li>
<li><strong>Deployment and Beyond</strong> roughly covers <em>distribution-to-next-rollout</em>.</li>
</ul>
<p>We delegate:</p>
<ul>
<li>The <strong>Development Environment</strong> to a trusted project in the broader Nix Community employing community outreach to promote our cause and ensure it is at least not accidentally sabotaged.</li>
<li>The <strong>Deployment and Beyond</strong> by cultivating outreach and dovetailing with initiatives of, among others, the Cloud Native ecosystem.</li>
</ul>
<p>And we focus on:</p>
<ul>
<li>The <strong>Packaging Pipeline</strong></li>
<li><em>Interfaces</em> and <em>Integration</em> with the other two</li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>With clarity about Standard's general scope and direction, let's procede to get an overview over its architecture.</p>
<h3 id="locating-standard-in-the-sdlc"><a class="header" href="#locating-standard-in-the-sdlc">Locating Standard in the SDLC</a></h3>
<p>Where is Standard located in the big picture?</p>
<p>This graphic locates Standard across the SDLC &amp; Application Lifecycle Management (ALM).</p>
<p>But not only that.
It also explains how automation in itself is implemented as <em>code</em>, just as the application itself.
Therefore, we make a distinction between:</p>
<ul>
<li>first order application code (L1); and</li>
<li>above that, higher order supporting code as exemplified by L2 and L3.</li>
</ul>
<blockquote>
<p>Glossary:</p>
<p><em>L2 &amp; L3</em> have no clearly defined meaning.
They represent that we may observe multiple layers of higher order code when automating.
Examples could be bash scripts, configuration data, platform utility code and more.</p>
</blockquote>
<div align="center"><img src="./artwork/sdlc.svg" width="900" /></div>
<h3 id="standards-components-and-their-value-contribution"><a class="header" href="#standards-components-and-their-value-contribution">Standard's Components and their Value Contribution</a></h3>
<p>What is Standard made of? And how do its components contribute value?</p>
<p>On the left side of the graphic, we show how Standard, like an onion, is build in layers:</p>
<p>Center to Standard is <a href="https://github.com/divnix/paisano"><code>divnix/paisano</code></a>.
This flake (i.e. &quot;Nix library&quot;) implements two main abstractions: Block Types and Cells.</p>
<p><em><strong>Block Types</strong></em> are not unlike Rust's traits or Golang's interfaces.
They are abstract definitions of artifact classes.
Those abstract classes implement <em>shared functionality</em>.</p>
<p>A few examples of artifact classes in our scope are: packages, containers, scripts and manifests, among others.
Examples of shared functionality are (a shared implementation of) <em>push</em> on containers and (a shared implementation of) <em>build</em> on packages.</p>
<p><em><strong>Cells</strong></em>, in turn, organize your code into related units of functionality.
Hence, Cells are a code <em>orgnization principle</em>.</p>
<p>On top of Paisano's abstractions, Standard implements within its scope:</p>
<ul>
<li>a collection of Block Types; and</li>
<li>a collection of library functionality organized in Cells.</li>
</ul>
<p>On the right side of the graphic, we sketch an idea of how these components are put into service for the SDLC.</p>
<div align="center"><img src="./artwork/components.svg" width="900" /></div>
<h3 id="paisano-code-organization"><a class="header" href="#paisano-code-organization">Paisano (Code Organization)</a></h3>
<p>We already learned about Paisano's two main abstractions: Cells &amp; Block Types.</p>
<p>Cells enable and encourage the user to cleanly organize their code into related units of functionality.
The concrete semantics of code layout are completely at her choosing.
For example, she could separate application tiers like frontend and backend into their own cells, each.
Or she could reflect the microservices architecture in the Cells.</p>
<p>Paisano has a first class concept of Cells.
By simply placing a folder in the repository, Paisano will pick it up.
In that regard, Paisano is an automated importer, that spares the user the need to setup and maintain boilerplate plumbing code.</p>
<p>Within a Cell, the user groups artifacts within Blocks of an appropriate Block Type.
When configuring Standard, she names her Blocks using Standard's Block Types so that Paisano's importer can pick them up, too.
By doing that, she also declares the repository's artifact type system to humans and machines.</p>
<p>Machines can make great use of that to interact with the artifact type system in multiple ways.
Paisano exports structured json-serializable data about a repository's <em>typed</em> artifacts in its so-called &quot;Paisano Registry&quot;.
A CLI or TUI, as is bundled with Standard, or even a web user interface can consume, represent and act upon that data.</p>
<p>And so can CI.</p>
<p>In fact, this is an innovation in the SDLC space:
We can devise an implementation of a CI which, by querying Paisano's Registry, autonomously discovers all work that needs to be done.
In order to demonstrate the value of this proposition, we made a reference implementation for GitHub Actions over at <a href="https://github.com/divnix/paisano"><code>divnix/std-action</code></a>.
To our knowledge, this is the first and only &quot;zero config&quot; CI implementation based on the principles of artifact typing and code organization.
By using these principles rather than a rigid opinionated structure, it also remains highly flexible and adapts well to the user's preferences &amp; needs.</p>
<p>In summary, all these organization and typing principles enable:</p>
<ul>
<li>easy refactoring of your repository's devops namespace;</li>
<li>intuitive grouping of functionality that encourages well-defined internal boundaries,
<ul>
<li>allowing for keeping your automation code clean and maintainable;</li>
</ul>
</li>
<li>making use of Block Types and the shared library to implement the DRY principle;</li>
<li>reasoning about the content of your repo through structured data,
<ul>
<li>and, thereby, facilitate interesting user interfaces, such as a CLI, TUI or even a UI,</li>
<li>as well as services like a (close to) zero config, self-updating CI;</li>
</ul>
</li>
<li>similar organizational principles help to lower the cost of context switching between different projects.</li>
</ul>
<h3 id="standards-block-types-devops-type-system"><a class="header" href="#standards-block-types-devops-type-system">Standard's Block Types (DevOps Type System)</a></h3>
<p>As mentioned above, Standard exploits the Block Type abstraction to provide artifact types for the SDLC.
Within the semantics of each Block Type, we implement shared functionality.
This is designed to offer the user an optimized, audited implementation.
Alleviates the burden of devising &quot;yet another&quot; local implementation of otherwise well-understood generic functionality, such as, the building of a package or the pushing of a container image.</p>
<h3 id="standards-cells-function-library"><a class="header" href="#standards-cells-function-library">Standard's Cells (Function Library)</a></h3>
<p>Alongside the <strong>Packaging Pipeline</strong>, Standard provides a curated assortment of library functions and integrations that users can adopt.
While optional, an audited and community maintained function library and its corresponding documentation fulfills the promise of productivity, shared mental models and ease of adoption.</p>
<h2 id="modularity--virality-model"><a class="header" href="#modularity--virality-model">Modularity &amp; Virality Model</a></h2>
<p>We aim to provide a public registry in which we index and aggregate additional Block Types and Cells from the Standard user community that are not maintained in-tree.
To boost its value, aggregate documentation will be part of that registry.
We need to decide on how to deeply integrate documentation concerns, such as structured docstrings &amp; adjacent readmes, into the framework.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-matrix"><a class="header" href="#value-matrix">Value Matrix</a></h1>
<p>This section will explain how Standard intends to create value for different stakeholders.
It is essential to have an idea of who they are, so let's introduce:</p>
<p><strong><em>The Software Sponsor</em></strong>
Makes resources available in return for the expectation of future benefits.</p>
<p><strong><em>The Provider of Automation</em></strong>
Sets up and maintains the automation along the SDLC.
A helpful analogy would be the person who sets up and maintains the conveyor belt which moves features to production.</p>
<p><strong><em>The Consumer of Automation</em></strong>
Consumes and co-maintaines the automation along the SDLC.
A helpful analogy would be that this person not only uses and configures our conveyor belt, but is also capable of occasionally maintaining it.</p>
<p>It is essential to have an understanding of what they value, so let's try to get an overview.
We'll make use of a high level value matrix with simple sentiment scores:</p>
<ul>
<li>:heart_eyes: → <i>&quot;absolutely love it!!!&quot;</i></li>
<li>:smile: → <i>&quot;feels pretty good.&quot;</i></li>
<li>:neutral_face: → <i>&quot;whatever?!?&quot;</i></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th style="text-align: center">Software Sponsor [Principal]</th><th style="text-align: center">Provider of SDLC Automation [Agent]</th><th style="text-align: center">Consumer of SDLC Automation [Agent]</th></tr></thead><tbody>
<tr><td>Productivity</td><td style="text-align: center">:heart_eyes:</td><td style="text-align: center">:heart_eyes:</td><td style="text-align: center">:smiley:</td></tr>
<tr><td>Code Organization</td><td style="text-align: center">:smiley:</td><td style="text-align: center">:heart_eyes:</td><td style="text-align: center">:smiley:</td></tr>
<tr><td>Mental Model &amp; Learning</td><td style="text-align: center">:smiley:</td><td style="text-align: center">:heart_eyes:</td><td style="text-align: center">:smiley:</td></tr>
<tr><td>Batteries Included</td><td style="text-align: center">:neutral_face:</td><td style="text-align: center">:heart_eyes:</td><td style="text-align: center">:neutral_face:</td></tr>
<tr><td>Community and Ecosystem</td><td style="text-align: center">:neutral_face:</td><td style="text-align: center">:heart_eyes:</td><td style="text-align: center">:smiley:</td></tr>
<tr><td>Reproducibility &amp; Software Supply Chain Security</td><td style="text-align: center">:heart_eyes:</td><td style="text-align: center">:heart_eyes:</td><td style="text-align: center">:neutral_face:</td></tr>
<tr><td>Modularity &amp; Incremental Adoption</td><td style="text-align: center">:smiley:</td><td style="text-align: center">:smiley:</td><td style="text-align: center">:heart_eyes:</td></tr>
<tr><td>Developer Experience &amp; Onboarding Story</td><td style="text-align: center">:smiley:</td><td style="text-align: center">:smiley:</td><td style="text-align: center">:heart_eyes:</td></tr>
</tbody></table>
</div>
<p>So, this is for you and your team, if you:</p>
<ul>
<li>Care about reproducibility for more reliablility throughout your software development</li>
<li>Value clean code for keeping a check on techincal debt and increased long-term maintainability</li>
<li>Have a deadline to meet with the help of the includes best practices and batteries</li>
<li>Want to serve an optimized UX to your colleagues via a repo CLI / TUI and (close to) zero-config CI</li>
</ul>
<h1 id="selling-points"><a class="header" href="#selling-points">Selling Points</a></h1>
<p>The main selling points of Standard are:</p>
<ul>
<li>
<p><strong>Efficiency:</strong> Standard automates the software delivery lifecycle, making the process more efficient and streamlined.</p>
</li>
<li>
<p><strong>Reproducibility:</strong> Standard's emphasis on reproducibility ensures that every stage of the SDLC can be easily replicated, leading to a more consistent and reliable software development process.</p>
</li>
<li>
<p><strong>Speed:</strong> Standard optimizes the critical path of the SDLC journey to achieve superior cycle times, which means that your software can be shipped to production faster.</p>
</li>
<li>
<p><strong>Flexibility:</strong> Standard is built to be flexible and adaptable, which allows it to be used in a variety of different contexts and industries.</p>
</li>
<li>
<p><strong>Cost-effective:</strong> Automating the software delivery lifecycle with Standard saves time and resources, making it more cost-effective.</p>
</li>
<li>
<p><strong>Integration:</strong> Standard is a horizontal integration framework that integrates vertical tooling, making it easier to stitch together different tools and processes to create a polished whole.</p>
</li>
<li>
<p><strong>Community Outreach:</strong> Standard is a part of the Nix ecosystem and is committed to community outreach to ensure that its optimization targets are met and that other perspectives are not dismissed.</p>
</li>
</ul>
<p>These points show how Standard can help adopters to improve their software delivery process, and how it can save them time, money and improve the quality of their software.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparing-standard-to-x"><a class="header" href="#comparing-standard-to-x">Comparing Standard to X</a></h1>
<p><em>Where appropriate, we compare with <code>divnix/paisano</code>, instead</em>.</p>
<h2 id="comparison-with-tools-in-the-nix-ecosystem"><a class="header" href="#comparison-with-tools-in-the-nix-ecosystem">Comparison with tools in the Nix ecosystem</a></h2>
<h3 id="flake-utils"><a class="header" href="#flake-utils">flake-utils</a></h3>
<p><code>numtide/flake-utils</code> is a small &amp; lightweight utility with a focus on generating flake file <em>outputs</em> in accordance with the packaging and NixOS use cases built into the Nix CLI tooling.</p>
<p>Paisano, in turn, is an importer with a focus on <em>code organization</em>.</p>
<p>Like Flake Utils, it, too, was designed to be used inside the <code>flake.nix</code> file.
However, <code>flake.nix</code> is a repository's prime estate.
And so Paisano was optimized for keeping that estate as clean as possible and, at the same time, beeing a useful table of content even to a relative nix-layman.</p>
<p>While you <em>can</em> use it to match the schema that Nix CLI expects, it also enables more flexibility as it is not specially optimized for any particular use case.</p>
<h3 id="flake-parts"><a class="header" href="#flake-parts">flake-parts</a></h3>
<p><code>hercules-ci/flake-parts</code> is a component aggregator with a focus on a flake schema that is built into the Nix CLI tooling that makes use of the NixOS module system for composability and aggregation.</p>
<p>Paisano, in turn, is an importer with a focus on <em>code organization</em>; it still plugs well into a <code>flake.nix</code> file, but also preserves its index function by keeping it clean.
While you <em>can</em> use it to match the schema that Nix CLI expects, it also enables more flexibility as it is not specially optimized for any particular use case.</p>
<p>To a lesser extent, Paisano is also a component aggregator for your flake outputs.
However, in that role, it gives you back the freedom to use the output schema that best fits your problem domain.</p>
<p>The core tenet of Flake Parts is domain specific interfaces for each use case.
Flake Parts implements and aggregates these interfaces based on the NixOS module system.</p>
<p>Paisano, in turn, focuses on code organization along high level code boundaries connected by generic interfaces.
The core tenet of Paisano remains Nix's original functional style.</p>
<p>Convergence towards the Flakes output schema is provided via the harvester family of utility functions (<code>winnow</code>, <code>harvest</code> &amp; <code>pick</code>).
Depending on the domain schema, it can be a <em>lossy</em> convergence, though, due the lesser expressivity of the flake output schema.</p>
<details>
<summary>Example usage of harvester functions</summary>
<pre><code class="language-nix">{
  inputs = { /* snip */ };
  outputs = { std, self, ...}:
    growOn {
      /* snip */
    }
    {
      devShells = std.harvest self [&quot;automation&quot; &quot;devshells&quot;];
      packages = std.harvest self [[&quot;std&quot; &quot;cli&quot;] [&quot;std&quot; &quot;packages&quot;]];
      templates = std.pick self [&quot;presets&quot; &quot;templates&quot;];
    };
}
</code></pre>
</details>
<h3 id="devshell"><a class="header" href="#devshell">Devshell</a></h3>
<p>Standard wraps <code>numtide/devshell</code> to improve the developer experience in the early parts of the SDLC via reproducible development shells.</p>
<h2 id="comparison-with-other-tools--frameworks"><a class="header" href="#comparison-with-other-tools--frameworks">Comparison with other tools &amp; frameworks</a></h2>
<h3 id="my-language-build-tool"><a class="header" href="#my-language-build-tool">My language build tool</a></h3>
<p>Nix wraps language level tooling into a sandbox and cross-language build graph to ensure reproducibility.
Most languages are already covered.</p>
<h3 id="bazel"><a class="header" href="#bazel">Bazel</a></h3>
<p>Bazel is similar to Nix in that it creates cross-language build graphs.
However, it does not guarantee reproducibility.
Currently it has more advanced build caching strategies: a gap that the Nix community is very eager to close soon.</p>
<h3 id="my-cicd"><a class="header" href="#my-cicd">My CI/CD</a></h3>
<p>Any CI can leverage Paisano's Registry to discover work.
Implementations can either be native to the CI or provided via CI-specific wrappers, a strategy chosen, for example, by our reference implementation for GitHub Actions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>
<p>The freestyle history of the project was productive during the alpha stage, but as the code stabilizes, so too must our processes.</p>
<p>This roadmap gives an overview of the short and mid term direction that the project aims to take.</p>
<h2 id="deliverable-categories"><a class="header" href="#deliverable-categories">Deliverable Categories</a></h2>
<p>We've identified a couple of deliverable categories in line with the <a href="./ARCHITECTURE.html">architectural overview</a>.</p>
<p>These help us to better understand the work spectrum associated with the project.</p>
<h5 id="process-categories"><a class="header" href="#process-categories">Process Categories</a></h5>
<p>To run <em>automation</em> we have to <em>set it up</em>, first.
We should keep that in mind when working on the backlog and therefore classify:</p>
<ul>
<li>Setup</li>
<li>Automation</li>
</ul>
<p>For setup, besides function libraries, a variety of supporting material is crucial, such as:</p>
<ul>
<li>Documentation &amp; Instructions</li>
<li>Patterns &amp; Shared Mental Models</li>
<li>Quick Start Templates</li>
<li>Onboarding &amp; Learning Content</li>
</ul>
<h5 id="process-regions"><a class="header" href="#process-regions">Process Regions</a></h5>
<p>Per our <a href="./ARCHITECTURE.html">architectural overview</a>, we distinguish these process regions:</p>
<ul>
<li>Development Environment</li>
<li>Build Pipeline</li>
<li>Deployment and Beyond (Application Lifecycle Management)</li>
</ul>
<h5 id="deliverable-types"><a class="header" href="#deliverable-types">Deliverable Types</a></h5>
<ul>
<li>Docs</li>
<li>CLI commands or TUI helpers</li>
<li>Integrations</li>
<li>Library functions</li>
<li>Block Types</li>
<li>Stable interfaces</li>
<li>Community outreach</li>
</ul>
<h2 id="milestone-v1"><a class="header" href="#milestone-v1">Milestone v1</a></h2>
<p>With the above in mind, the <a href="https://github.com/divnix/std/issues">issue backlog</a> will be regularly groomed and prioritized.
This is an aid for the core contributors, but it may also provide the necessary orientation to get new contributors set up.</p>
<p>Welcome!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-walk-in-the-park"><a class="header" href="#a-walk-in-the-park">A walk in the park</a></h1>
<p>This is an excellent tutorial series by Joshua Gilman in the form of The Standard Book.</p>
<p>It is ideal for people with prior Nix and Nix Flakes experience.</p>
<p>They are written in a way that feels like a walk in the park, hence the nickname.</p>
<p>They are also often used to dogfood some new <code>std</code> functionality and document it alongside in a palatable (non-terse) writing style.</p>
<p>Enjoy!</p>
<hr />
<p><a href="https://jmgilman.github.io/std-book/">The Standard Book</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p><a href="https://github.com/divnix/std">Standard</a> features a special project structure
that brings some awesome innovation
to this often overlooked (but important) part of your project.
With the default <strong>Cell Blocks</strong>, an <code>apps.nix</code> file tells <a href="https://github.com/divnix/std">Standard</a>
that we are creating an Application.
<code>flake.nix</code> is in charge
of explicitly defining
the inputs of your project.</p>
<blockquote>
<p><em>Btw, you can can copy * the following files from <a href="https://github.com/divnix/std/tree/main/docs/tutorials/hello-world">here</a>.</em></p>
<p>* <em>don't just clone the <code>std</code> repo: flakes in subfolders don't work that way.</em></p>
</blockquote>
<h4 id="tmpplay-with-stdhello-worldflakenix"><a class="header" href="#tmpplay-with-stdhello-worldflakenix"><code>/tmp/play-with-std/hello-world/flake.nix</code></a></h4>
<pre><code class="language-nix">{
  inputs.std.url = &quot;github:divnix/std&quot;;
  inputs.nixpkgs.url = &quot;nixpkgs&quot;;

  outputs = {std, ...} @ inputs:
    std.grow {
      inherit inputs;
      cellsFrom = ./cells;
    };
}
</code></pre>
<h4 id="tmpplay-with-stdhello-worldcellshelloappsnix"><a class="header" href="#tmpplay-with-stdhello-worldcellshelloappsnix"><code>/tmp/play-with-std/hello-world/cells/hello/apps.nix</code></a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: {
  default = inputs.nixpkgs.stdenv.mkDerivation rec {
    pname = &quot;hello&quot;;
    version = &quot;2.10&quot;;
    src = inputs.nixpkgs.fetchurl {
      url = &quot;mirror://gnu/hello/${pname}-${version}.tar.gz&quot;;
      sha256 = &quot;0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i&quot;;
    };
  };
}
</code></pre>
<pre><code class="language-bash">$ cd /tmp/play-with-std/hello-world/
$ git init &amp;&amp; git add . &amp;&amp; git commit -m&quot;nix flakes only can see files under version control&quot;
# fetch `std`
$ nix shell github:divnix/std
$ std //hello/apps/default:run
Hello, world!
</code></pre>
<p>You see? from nothing
to running your first application
in just a few seconds ✨</p>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<p>This example consumes the following defaults or builtins:</p>
<h3 id="default-cellblocks"><a class="header" href="#default-cellblocks"><a href="https://github.com/divnix/std/blob/main/src/grow.nix#L63-L67">Default <code>cellBlocks</code></a></a></h3>
<pre><code class="language-nix">{{#include ../../../src/grow.nix:64:68}}
</code></pre>
<h3 id="default-systems"><a class="header" href="#default-systems"><a href="https://github.com/divnix/std/blob/main/src/grow.nix#L68-L77">Default <code>systems</code></a></a></h3>
<pre><code class="language-nix">{{#include ../../../src/grow.nix:69:78}}
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-moon"><a class="header" href="#hello-moon">Hello Moon</a></h1>
<p><em>A slightly more complete <a href="tutorials/hello-moon/../hello-world">hello world</a> tutorial.</em></p>
<p>This tutorial implements a very typical <code>_automation</code> Cell and its Cell Blocks for a somewhat bigger project.
It also makes use of more advanced functions of <code>std</code>.
Namely:</p>
<ul>
<li><code>std.growOn</code> instead of <code>std.grow</code></li>
<li><code>std.harvest</code> to provide compatibility layers of &quot;soil&quot;</li>
<li>non-default Cell Block definitions</li>
<li>the input debug facility</li>
</ul>
<p>The terms <em>&quot;Block Type&quot;</em>, <em>&quot;Cell&quot;</em>, <em>&quot;Cell Block&quot;</em>, <em>&quot;Target&quot;</em> and <em>&quot;Action&quot;</em> have special meaning within the context of <code>std</code>.
With these clear definitions, we navigate and communicate the code structure much more easily.
In order to familiarize yourself with them, please have a quick glance at the <a href="tutorials/hello-moon/../../glossary.html">glossary</a>.</p>
<h2 id="file-layout"><a class="header" href="#file-layout">File Layout</a></h2>
<p>Let's start again with a flake:</p>
<h4 id="flakenix"><a class="header" href="#flakenix"><code>./flake.nix</code></a></h4>
<pre><code class="language-nix">{
  inputs.std.url = &quot;github:divnix/std&quot;;
  inputs.nixpkgs.url = &quot;nixpkgs&quot;;

  outputs = {std, ...} @ inputs:
  /*
  brings std attributes into scope
  namely used here: `growOn`, `harvest` &amp; `blockTypes`
  */
    with std;
    /*
    grows a flake &quot;from cells&quot; on &quot;soil&quot;; see below...
    */
      growOn {
        /*
        we always inherit inputs and expose a deSystemized version
        via {inputs, cell} during import of Cell Blocks.
        */
        inherit inputs;

        /*
        from where to &quot;grow&quot; cells?
        */
        cellsFrom = ./nix;

        /*
        custom Cell Blocks (i.e. &quot;typed outputs&quot;)
        */
        cellBlocks = [
          (blockTypes.devshells &quot;devshells&quot;)
          (blockTypes.nixago &quot;nixago&quot;)
        ];

        /*
        This debug facility helps you to explore what attributes are available
        for a given input untill you get more familiar with `std`.
        */
        debug = [&quot;inputs&quot; &quot;std&quot;];
      }
      /*

      Soil is an idiom to refer to compatibility layers that are recursively
      merged onto the outputs of the `std.grow` function.

      */
      # Soil ...
      # 1) layer for compat with the nix CLI
      {
        devShells = harvest inputs.self [&quot;_automation&quot; &quot;devshells&quot;];
      }
      # 2) there can be various layers; `growOn` is a variadic function
      {};
}
</code></pre>
<p>This time we specified <code>cellsFrom = ./nix;</code>.
This is gentle so that our colleagues know immediately which files to either look or never look at depending on where they stand.</p>
<p>We also used <code>std.growOn</code> instead of <code>std.grow</code> so that we can add compatibility layers of &quot;soil&quot;.</p>
<p>Furthermore, we only defined two Cell Blocks: <code>nixago</code> &amp; <code>devshells</code>. More on them follows...</p>
<h4 id="nix_automation"><a class="header" href="#nix_automation"><code>./nix/_automation/*</code></a></h4>
<p>Next, we define a <code>_automation</code> cell.
Each project will have some amount of automation.
This can be repository automation, such as code generation.
Or it can be a CI/CD specification.
In here, we wire up two tools from the Nix ecosystem: <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code></a> &amp; <a href="https://github.com/nix-community/nixago"><code>nix-community/nixago</code></a>.</p>
<blockquote>
<p><em>Please refer to these links to get yourself a quick overview before continuing this tutorial, in case you don't know them, yet.</em></p>
<p>A <em>very</em> short refresher:</p>
<ul>
<li><strong>Nixago</strong>: Template &amp; render repository (dot-)files with nix. <a href="tutorials/hello-moon/../../explain/why-nix.html">Why nix?</a></li>
<li><strong>Devshell</strong>: Friendly &amp; reproducible development shells — the original ™.</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Some semantic background:</strong></p>
<p>Both, Nixago &amp; Devshell are <em>Component Tools</em>.</p>
<p><em>(Vertical) Component Tools</em> are distinct from <em>(Horizontal) Integration Tools</em> — such as <code>std</code> — in that they provide a specific capability in a minimal linux style: <em>&quot;Do one thing and do it well.&quot;</em></p>
<p>Integration Tools however combine them into a polished user story and experience.</p>
<p>The Nix ecosystem is very rich in <em>component tools</em>, however only few <em>integration tools</em> exist at the time of writing.</p>
</blockquote>
<h4 id="nix_automationdevshellsnix"><a class="header" href="#nix_automationdevshellsnix"><code>./nix/_automation/devshells.nix</code></a></h4>
<p>Let's start with the <code>cell.devshells</code> Cell Block and work our way backwards to the <code>cell.nixago</code> Cell Block below.</p>
<blockquote>
<p><strong>More semantic background:</strong></p>
<p>I could also reference them as <code>inputs.cells._automation.devshells</code> &amp; <code>inputs.cells._automation.nixago</code>.</p>
<p>But, because we are sticking with the local Cell context, we don't want to confuse the future code reader.
Instead, we gently hint at the locality by just referring them via the <code>cell</code> context.</p>
</blockquote>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  /*
  I usually just find it very handy to alias all things library onto `l`...
  The distinction between `builtins` and `nixpkgs.lib` has little practical
  relevance, in most scenarios.
  */
  l = nixpkgs.lib // builtins;

  /*
  It is good practice to in-scope:
  - inputs by *name*
  - other Cells by their *Cell names*
  - the local Cell Blocks by their *Block names*.

  However, for `std`, we make an exeption and in-scope, despite being an
  input, its primary Cell with the same name as well as the dev lib.
  */
  inherit (inputs) nixpkgs;
  inherit (inputs.std) std lib;
  inherit (cell) nixago;
in
  # we use Standard's mkShell wrapper for its Nixago integration
  l.mapAttrs (_: lib.dev.mkShell) {
    default = {...}: {
      name = &quot;My Devshell&quot;;
      # This `nixago` option is a courtesy of the `std` horizontal
      # integration between Devshell and Nixago
      nixago = [
        # off-the-shelve from `std`
        (lib.cfg.conform {data = {inherit (inputs) cells;};})
        lib.cfg.lefthook
        lib.cfg.adrgen
        # modified from the local Cell
        nixago.treefmt
        nixago.editorconfig
        nixago.mdbook
      ];
      # Devshell handily represents `commands` as part of
      # its Message Of The Day (MOTD) or the built-in `menu` command.
      commands = [
        {
          package = nixpkgs.reuse;
          category = &quot;legal&quot;;
          /*
          For display, reuse already has both a `pname` &amp; `meta.description`.
          Hence, we don't need to inline these - they are autodetected:

          name = &quot;reuse&quot;;
          description = &quot;Reuse is a tool to manage a project's LICENCES&quot;;
          */
        }
      ];
      # Always import the `std` default devshellProfile to also install
      # the `std` CLI/TUI into your Devshell.
      imports = [std.devshellProfiles.default];
    };
  }
</code></pre>
<p>The <code>nixago = [];</code> option in this definition is a special integration provided by the <a href="tutorials/hello-moon/../../reference/lib/dev/mkShell.html">Standard's <code>devshell</code>-wrapper (<code>std.lib.mkShell</code>)</a>.</p>
<p><em>This is how <code>std</code> delivers on its promise of being a (horizontal) integration tool that wraps (vertical) component tools into a polished user story and experience.</em></p>
<p>Because we made use of <code>std.harvest</code> in the flake, you now can actually test out the devshell via the Nix CLI compat layer by just running <code>nix develop -c &quot;$SHELL&quot;</code> in the directory of the flake.
For a more elegant method of entering a development shell read on the <a href="tutorials/hello-moon/index.html#direnv">direnv</a> section below.</p>
<h4 id="nix_automationnixagonix"><a class="header" href="#nix_automationnixagonix"><code>./nix/_automation/nixago.nix</code></a></h4>
<p>As we have seen above, the <code>nixago</code> option in the <code>cell.devshells</code> Cell Block references Targets from both <code>lib.cfg</code>.
While you can explore <code>lib.cfg</code> <a href="https://github.com/divnix/std/blob/main/cells/lib/cfg.nix">here</a>, let's now have a closer look at <code>cell.nixago</code>:</p>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
  inherit (inputs.std) lib;
  /*
  While these are strictly specializations of the available
  Nixago Pebbles at `lib.cfg.*`, it would be entirely
  possible to define a completely new pebble inline
  */
in {
  /*
  treefmt: https://github.com/numtide/treefmt
  */
  treefmt = lib.cfg.treefmt {
    # we use the data attribute to modify the
    # target data structure via a simple data overlay
    # (`divnix/data-merge` / `std.dmerge`) mechanism.
    data.formatter.go = {
      command = &quot;gofmt&quot;;
      options = [&quot;-w&quot;];
      includes = [&quot;*.go&quot;];
    };
    # for the `std.lib.dev.mkShell` integration with nixago,
    # we also hint which packages should be made available
    # in the environment for this &quot;Nixago Pebble&quot;
    packages = [nixpkgs.go];
  };

  /*
  editorconfig: https://editorconfig.org/
  */
  editorconfig = lib.cfg.editorconfig {
    data = {
      # the actual target data structure depends on the
      # Nixago Pebble, and ultimately, on the tool to configure
      &quot;*.xcf&quot; = {
        charset = &quot;unset&quot;;
        end_of_line = &quot;unset&quot;;
        insert_final_newline = &quot;unset&quot;;
        trim_trailing_whitespace = &quot;unset&quot;;
        indent_style = &quot;unset&quot;;
        indent_size = &quot;unset&quot;;
      };
      &quot;{*.go,go.mod}&quot; = {
        indent_style = &quot;tab&quot;;
        indent_size = 4;
      };
    };
  };

  /*
  mdbook: https://rust-lang.github.io/mdBook
  */
  mdbook = lib.cfg.mdbook {
    data = {
      book.title = &quot;The Standard Book&quot;;
    };
  };
}
</code></pre>
<p>In this Cell Block, we have been modifying some built-in convenience <code>lib.cfg.*</code> pebbles.
The way <code>data</code> is merged upon the existing pebble is via a simple left-hand-side/right-hand-site <code>data-merge</code> (<code>std.dmerge</code>).</p>
<blockquote>
<p><strong>Background on array merge strategies:</strong></p>
<p>If you know how a plain data-merge (does not magically) deal with array merge semantics, you noticed:
We didn't have to annotate our right-hand-side arrays in this example because we where not actually amending or modifying any left-hand-site array type data structure.</p>
<p>Would we have done so, we would have had to annotate:</p>
<ul>
<li>either with <code>std.dmerge.append [/* ... */]</code>;</li>
<li>or with <code>std.dmerge.update [ idx ] [/* ... */]</code>.</li>
</ul>
<p>But lucky us (this time)!</p>
</blockquote>
<h2 id="command-line-synthesis"><a class="header" href="#command-line-synthesis">Command Line Synthesis</a></h2>
<p>With this configuration in place, you have a couple of options on the command line.
Note, that you can accessor any <code>std</code> cli invocation also via the <code>std</code> TUI by just typing <code>std</code>.
Just in case you forgot exactly how to accessor one of these repository capabilities.</p>
<blockquote>
<p><strong>Debug Facility:</strong></p>
<p>Since the debug facility is enabled, you will see some trace output while running these commands.
To switch this off, just comment the <code>debug = [ /* ... */ ];</code> attribute in the flake.</p>
<p>It looks something like this:</p>
<pre><code class="language-nix">trace: inputs on x86_64-linux
trace: {
  cells = {…};
  nixpkgs = {…};
  self = {…};
  std = {…};
}
</code></pre>
</blockquote>
<p><strong>Invoke devshell via <code>nix</code></strong></p>
<pre><code class="language-bash">nix develop -c &quot;$SHELL&quot;
</code></pre>
<p>By quirks of the Nix CLI, if you don't specify <code>-c &quot;$SHELL&quot;</code>, you'll be thrown into an unfamiliar bare <code>bash</code> interactive shell.
That's not what you want.</p>
<p><strong>Invoke the devshell via <code>std</code></strong></p>
<p>In this case, invoking <code>$SHELL</code> correctly is taken care for you by the Block Type's <code>enter</code> Action.</p>
<pre><code class="language-bash"># fetch `std`
$ nix shell github:divnix/std
$ std //_automation/devshells/default:enter
</code></pre>
<p>Since we have declared the devshell Cell Block as a <code>blockTypes.devshells</code>, <code>std</code> auments it's Targets with the Block Type Actions.</p>
<p>See <a href="tutorials/hello-moon/../../reference/blocktypes/devshells-blocktype.html"><code>blockTypes.devshells</code></a> for more details on the available Actions and their implementation.</p>
<p>Thanks to the <code>cell.devshells</code>' <code>nixago</code> option, entering the devshell will also automatically reconcile the repository files under Nixago's management.</p>
<p><strong>Explore a Nixago Pebble via <code>std</code></strong></p>
<p>You can also explore the nixago configuration via the Nixago Block Type's <code>explore</code>-Action.</p>
<pre><code class="language-bash"># fetch `std`
$ nix shell github:divnix/std
$ std //_automation/nixago/treefmt:explore
</code></pre>
<p>See <a href="tutorials/hello-moon/../../reference/blocktypess/nixago-blocktype.html"><code>blockTypes.nixago</code></a> for more details on the available Actions and their implementation.</p>
<h2 id="direnv"><a class="header" href="#direnv">direnv</a></h2>
<p>Manually entering the devshell is boring.
How about a daemon always does that automatically &amp; efficiently when you <code>cd</code> into a project directory?
Enter <a href="https://direnv.net"><code>direnv</code></a> — the original (again; and even from the same author) 😊.</p>
<p>Before you continue, first install direnv according to it's <a href="https://direnv.net/docs/installation.html">install instructions</a>.
It's super simple &amp; super useful ™ and you should do it <em>right now</em> if you haven't yet.</p>
<p>Please learn how to enable <code>direnv</code> in this project by following the <a href="tutorials/hello-moon/../../guides/envrc.html">direnv how-to</a>.</p>
<p>In this case, you would adapt the relevant line to: <strong><code>use std nix //_automation/devshells:default</code></strong>.</p>
<p>Now, you can simply <code>cd</code> into that directory, and the devshells is being loaded.
The MOTD will be shown, too.</p>
<p>The first time, you need to teach the <code>direnv</code> daemon to trust the <code>.envrc</code> file via <code>direnv allow</code>.
If you want to reload the devshell (e.g. to reconcile Nixago Pebbles), you can just run <code>direnv reload</code>.</p>
<p>Because I use these commands so often, I've set: <code>alias d=&quot;direnv&quot;</code> in my shell's RC file.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="growing-cells"><a class="header" href="#growing-cells">Growing Cells</a></h1>
<p>Growing cells can be done via two variants:</p>
<ul>
<li><code>std.grow { cellsFrom = &quot;...&quot;; /* ... */ }</code></li>
<li><code>std.growOn { cellsFrom = &quot;...&quot;; /* ... */ } # soil</code></li>
</ul>
<h2 id="stdgrowon---soil"><a class="header" href="#stdgrowon---soil"><code>std.growOn {} # soil</code></a></h2>
<p>This eases talking and reasoning about a <code>std</code>ized repository, that also needs
some sort of adapters to work together better with external frameworks.</p>
<p>Typically, you'd arrange those adapters in numbered layers of soil, just
so that it's easier to conceptually reference them when talking / chatting.</p>
<p>It's a variadic function and takes an unlimited number of &quot;soil layers&quot;.</p>
<pre><code class="language-nix">{
  inputs.std.url = &quot;github:divnix/std&quot;;

  outputs = {std, ...} @ inputs:
    std.growOn {
      inherit inputs;
      cellsFrom = ./cells;
    }
    # soil
    () # first layer
    () # second layer
    () # ... nth layer
    ;
}
</code></pre>
<p>These layers get recursively merged onto the output of <code>std.grow</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="include-filter"><a class="header" href="#include-filter">Include Filter</a></h1>
<p>It is very common that you want to filter your source code in order
to avoid unnecessary rebuilds and increase your cache hits.</p>
<p>This is so common that <code>std</code> includes a tool for this:</p>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
  inherit (inputs) std;
in {
  backend = nixpkgs.mkYarnPackage {
    name = &quot;backend&quot;;
    src = std.incl (inputs.self + /src/backend) [
      (inputs.self + /src/backend/app.js)
      (inputs.self + /src/backend/config/config.js)
      /* ... */
    ];
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-envrc"><a class="header" href="#setup-envrc">Setup <code>.envrc</code></a></h1>
<p>Standard provides an extension to the <code>stdlib</code> via <code>direnv_lib.sh</code>.</p>
<p>The integrity hash below ensures it is downloaded only once and cached
from there on.</p>
<pre><code class="language-bash">#! /bin/sh

# SPDX-FileCopyrightText: 2022 David Arnold &lt;dgx.arnold@gmail.com&gt;
# SPDX-FileCopyrightText: 2022 Kevin Amado &lt;kamadorueda@gmail.com&gt;
#
# SPDX-License-Identifier: Unlicense

source &quot;$(
  nix eval \
  --no-update-lock-file \
  --no-write-lock-file \
  --no-warn-dirty \
  --accept-flake-config \
  .#__std.direnv_lib 2&gt;/dev/null \
  || nix eval .#__std.direnv_lib # show the errors
)&quot;
use std cells //_automation/devshells:default
</code></pre>
<blockquote>
<p><strong>NOTE:</strong>
In the above code <code>use std</code> <strong><code>cells</code></strong> <code>//std/...</code> refers to the
folder where <strong>Cells</strong> are grown from. If your folder is e.g. <code>nix</code>, adapt
to <code>use std</code> <strong><code>nix</code></strong> <code>//...</code> and so forth.</p>
</blockquote>
<p>It is used to automatically set up file watches on files that could modify the
current devshell, discoverable through these or similar logs during loading:</p>
<pre><code class="language-console">direnv: loading https://raw.githubusercontent.com/divnix/std/...
direnv: using std cells //_automation/devshells:default
direnv: Watching: cells/_automation/devshells.nix
direnv: Watching: cells/_automation/devshells (recursively)
</code></pre>
<p>For reference, the above example loads the <code>default</code> devshell from:</p>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  l = nixpkgs.lib // builtins;
  inherit (inputs) nixpkgs;
  inherit (inputs.cells) std lib;
in
  l.mapAttrs (_: lib.dev.mkShell) rec {
    default = {...}: {
      name = &quot;Standard&quot;;
      nixago = [
        (lib.cfg.conform {data = {inherit (inputs) cells;};})
        (lib.cfg.treefmt cell.configs.treefmt)
        (lib.cfg.editorconfig cell.configs.editorconfig)
        (lib.cfg.just cell.configs.just)
        (lib.cfg.githubsettings cell.configs.githubsettings)
        lib.cfg.lefthook
        lib.cfg.adrgen
      ];
      commands =
        [
          {
            package = nixpkgs.reuse;
            category = &quot;legal&quot;;
          }
          {
            package = nixpkgs.delve;
            category = &quot;cli-dev&quot;;
            name = &quot;dlv&quot;;
          }
          {
            package = nixpkgs.go;
            category = &quot;cli-dev&quot;;
          }
          {
            package = nixpkgs.gotools;
            category = &quot;cli-dev&quot;;
          }
          {
            package = nixpkgs.gopls;
            category = &quot;cli-dev&quot;;
          }
        ]
        ++ l.optionals nixpkgs.stdenv.isLinux [
          {
            package = nixpkgs.golangci-lint;
            category = &quot;cli-dev&quot;;
          }
        ];
      imports = [std.devshellProfiles.default book];
    };

    book = {...}: {
      nixago = [
        (lib.cfg.mdbook cell.configs.mdbook)
      ];
    };

    checks = {...}: {
      name = &quot;checks&quot;;
      imports = [std.devshellProfiles.default];
      commands = [
        {
          name = &quot;blocktype-data&quot;;
          command = &quot;cat $(std //_tests/data/example:write)&quot;;
        }
        {
          name = &quot;blocktype-devshells&quot;;
          command = &quot;std //_automation/devshell/default:enter -- echo OK&quot;;
        }
        {
          name = &quot;blocktype-runnables&quot;;
          command = &quot;std //std/cli/default:run -- std OK&quot;;
        }
      ];
    };
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-nix"><a class="header" href="#why-nix">Why <code>nix</code>?</a></h1>
<p>A lot of people write a lot of confusing stuff about nix.</p>
<p>So here, we'll try to break it down, instead.</p>
<h2 id="nix-is-json-on-steroids"><a class="header" href="#nix-is-json-on-steroids"><code>nix</code> is &quot;<code>json</code> on steroids&quot;</a></h2>
<p>In configuration management, you have a choice: data vs. language.</p>
<p>On stackoverflow, you'll be taught the &quot;data&quot; stance, because it's simple.</p>
<p>And all of a sudden you hit reality. Outside of a &quot;lab&quot; environment, you suddenly
need to manage a varying degree of complexity.</p>
<p>So you need configuration combinators, or in other words a full blown language
to efficiently render your configurations.</p>
<p>There are a couple of options, that you'll recognize if you've gotten serious about
the configuration challenge, like:</p>
<ul>
<li><a href="https://dhall-lang.org/"><code>dhall</code></a></li>
<li><a href="https://cuelang.org/"><code>cue</code></a></li>
<li><a href="https://jsonnet.org/"><code>jsonnet</code></a></li>
<li><a href="https://nickel-lang.org/"><code>nickel</code></a></li>
</ul>
<p>And there is <a href="https://nixos.org/"><code>nix</code></a>, the language. In most aspects, it isn't hugely distinct from the others,
but it has superpowers. Read on!</p>
<h2 id="nix-superpowers"><a class="header" href="#nix-superpowers"><code>nix</code>' superpowers</a></h2>
<p>You know the concept of string interpolation.</p>
<p>Every time <code>nix</code> interpolates an identifier, there is something that
you don't immediately see: it keeps a so called &quot;string context&quot; right
at the site of interpolation. That string context holds a directed acyclic
graph of all the dependencies that are required to make that string.</p>
<p>&quot;Well, it's just a string; what on earth should I need to make a string?&quot;, you may say.</p>
<p>There is a special category of strings, so called &quot;Nix store paths&quot;
(strings that start with <code>/nix/store/...</code>). These store paths represent
build artifacts that are content addressed ahead-of-time through
the inputs of an otherwise pure build function, called <a href="https://nixos.org/manual/nix/stable/expressions/derivations.html"><code>derivation</code></a>.</p>
<p>When you finally reify (i.e. &quot;build&quot;) your string interpolation, then all these Nix store
paths get build as well.</p>
<p>This might be a bit of a mind-boggling angle, but after a while, you may realize:</p>
<ul>
<li>Nix is a massive build pipeline that tracks all things to their source.</li>
<li>In their capacity as <em>pure</em> build functions, <a href="https://nixos.org/manual/nix/stable/expressions/derivations.html"><code>derviation</code>s</a> build <em>reproducibly</em>.</li>
<li>Reproducible builds are the future of software supply chain security, among other things.</li>
<li>You'll start asking: &quot;who the heck invented all that insecure nonsense of opaque binary registries?
Shouldn't have those smart people have known better?&quot;</li>
<li>And from this realization, there's no coming back.</li>
<li>And you'll have joined the <a href="https://discourse.nixos.org/t/nixos-foundation-participating-in-eus-next-generation-internet-initiative/2011">European Union</a>, <a href="https://discourse.nixos.org/t/mercury-bank-nix-engineers/13784">banks</a> and <a href="https://github.com/input-output-hk/cardano-world">blockchain companies</a> who also realized:
we need to fix our utterly broken and insecure build systems!</li>
<li>By that time, you'll have already assimilated the legendary <a href="http://users.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf">Ken Thompson's &quot;Reflections on Trusting Trust&quot;</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-std"><a class="header" href="#why-std">Why std?</a></h1>
<h2 id="problem"><a class="header" href="#problem">Problem</a></h2>
<p>Nix is marvel to ones and cruelty to others.</p>
<p>Much of this professional schism is due to two fundamental issues:</p>
<ul>
<li>Nix is a functional language without typing</li>
<li>Therefore, Nix-enthusiast seem to freaking love writing the most elegant and novel boilerplate all over again the next day.</li>
</ul>
<p>The amount of domain specific knowledge required to untangle those most elegant and novel boilerplate patterns prevent
the other side of the schism, very understandably, to see through the smoke the true beauty and benefits of <code>nix</code> as a
build and configuration language.</p>
<p>Lack of typing adds to the problem by forcing <code>nix</code>-practitioners to go out of their way (e.g. via <a href="https://github.com/divnix/yants"><code>divnix/yants</code></a>) to
add some internal boundaries and contracts to an ever morphing global context.</p>
<p>As a consequence, few actually <em>do</em> that. And contracts across internal code boundaries are either absent or rudimentary or — yet again —
&quot;elegant and novel&quot;. Neither of which satisfactorily settles the issue.</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p><code>std</code> doesn't add language-level typing. But a well-balanced folder layout cut at 3 layers of conceptual
nesting provides the fundamentals for establishing internal boundaries.</p>
<blockquote>
<p><strong>Cell → Cell Block → Target → [Action]</strong></p>
<p>Where ...</p>
<ul>
<li><strong>Cells</strong> group functionality.</li>
<li><strong>Cell Blocks</strong> type outputs and implement <strong>Actions</strong>.</li>
<li><strong>Targets</strong> name outputs.</li>
</ul>
</blockquote>
<p>Programmers are really good at pattern-abstraction when looking at two similar but slightly
different things: <em><strong>Cells</strong> and <strong>Cell Blocks</strong> set the stage for code readability.</em></p>
<p><strong>Cell Blocks</strong> only allow one possible interface: <code>{inputs, cell}</code>:</p>
<ul>
<li><code>cell</code> the local <strong>Cell</strong>, promoting separation of concern</li>
<li><code>inputs</code> the <code>deSystemize</code>ed flake inputs — plus:
<ul>
<li><code>inputs.self = self.sourceInfo;</code> reference source code in <code>nix</code>; filter with <code>std.incl</code>; don't misuse the global <code>self</code>.</li>
<li><code>inputs.cells</code>: the other cells by name; code that documents its boundaries.</li>
<li><code>inputs.nixpkgs</code>: an <em>instantiated</em> <code>nixpkgs</code> for the current system;</li>
</ul>
</li>
</ul>
<p>Now, we have <em>organized</em> <code>nix</code> code. Still, <code>nix</code> is not for everybody.
And for everybody else the <code>std</code> TUI/CLI companion answers a single question to perfection:</p>
<blockquote>
<p><strong>The GitOps Question:</strong></p>
<center><i>What can I actually <b>do</b> with this <code>std</code>-ized repository?</i></center>
&emsp;
</blockquote>
<blockquote>
<p><strong>The Standard Answer:</strong></p>
<center><i><code>std</code> breaks down GitOps into a single UX-optimized TUI/CLI entrypoint.</i></center>
&emsp;
</blockquote>
<h2 id="benefit"><a class="header" href="#benefit">Benefit</a></h2>
<p>Not everybody is going to love <code>nix</code> now.</p>
<p>But the ones, who know its secrets, now have an effective tool
to more empathically spark the joy.</p>
<p>Or simply: 💔 → 🧙 → 🔧 → ✨→ 🏖️</p>
<p>The smallest common denominator, in any case:</p>
<blockquote>
<p>Only ever install a single dependency (<code>nix</code>) and reach <em>any</em> repository target. Reproducibly.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-decision-record"><a class="header" href="#architecture-decision-record">Architecture Decision Record</a></h1>
<p>An architecture decision record (ADR) is a document that captures an
important architectural decision made along with its context and consequences.</p>
<p>The <a href="explain/architecture-decision-records/template.html">template</a> has all the info.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To interact with this ADR, enter the devshell and interact though the <code>adrgen</code> tool.</p>
<hr />
<h1 id="1-adopt-semi-conventional-file-locations"><a class="header" href="#1-adopt-semi-conventional-file-locations">1. Adopt semi-conventional file locations</a></h1>
<p>Date: 2022-03-01</p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>accepted</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Repository navigation is among the first activities to build a mental model of any given repository.
The Nix Ecosystem has come up with some weak conventions: these are variations that are mainly informed by the <code>nixpkgs</code> repository, itself.
Despite that, users find it difficult to quickly &quot;wrap their head&quot; around a new project.
This is often times a result of an organically grown file organization that has trouble keeping up with growing project semantics.
As a result, onboading onto a &quot;new&quot; nix project even within the same organizational context, sometimes can be a very frustrating and time-consuming activity.</p>
<h2 id="decision"><a class="header" href="#decision">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>A semi-conventional folder structure shall be adopted.</p>
<p>That folder structure shall have an abstract organization concept.</p>
<p>At the same time, it shall leave the user maximum freedom of semantics and naming.</p>
<p>Hence, 3 levels of organization are adopted.
These levels correspond to the abstract organizational concepts of:</p>
<ul>
<li>consistent collection of functionality (&quot;what makes sense to group together?&quot;)</li>
<li>repository output type (&quot;what types of gitops artifacts are produced?&quot;)</li>
<li>named outputs (&quot;what are the actual outputs?&quot;)</li>
</ul>
<h2 id="consequences"><a class="header" href="#consequences">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>With this design and despite complete freedom of concrete semantics, a prototypical mental model can be reused across different projects.</p>
<p>That same prototypical mental model also speeds up schaffolding of new content and code.</p>
<p>At the expense of nested folders, it may still be further expanded, if additional organization is required.
All the while that the primary meta-information about a project is properly communicated through these first three levels via the file system api, itself (think <code>ls</code> / <code>rg</code> / <code>fd</code>).</p>
<p>On the other hand, this rigidity is sometimes overkill and users may resort to filler names such as &quot;<code>default</code>&quot;, because a given semantic only produces singletons.
This is acceptable, however, because this parallellity in addressing even these singleton values trades for very easy expansion or refactoring, as the meta-models of code organization already align.</p>
<hr />
<h1 id="2-restrict-the-calling-interface"><a class="header" href="#2-restrict-the-calling-interface">2. Restrict the calling interface</a></h1>
<p>Date: 2022-03-01</p>
<h2 id="status-1"><a class="header" href="#status-1">Status</a></h2>
<p>accepted</p>
<h2 id="context-1"><a class="header" href="#context-1">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>The Nix Ecosystem has optimized for contributor efficiency at the expense of local code readibility and local reasoning.
Over time, the <code>callPackage</code> idiom was developed that destructures arbitrary attributes of an 80k <em>upstream</em> attributeset provided by <code>nixpkgs</code>.
A complicating side condition is added, where overlays modify that original upstream packages set in arbitrary ways.
This is not a problem for people, who know nixpkgs by heart and it is not a problem for the author either.
It is a problem for the future code reader, Nix expert or less so, who needs to grasp the essence of &quot;what's going on&quot; under a productivity side condidion.</p>
<p>Local reasoning is a tried and tested strategy to help mitigate those issues.</p>
<p>In a variant of this problem, we observe only somewhat convergent, but still largely diverging styles of passing arguments in general across the repository context.</p>
<h2 id="decision-1"><a class="header" href="#decision-1">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Encourage local reasoning by always fully qualifing identifiers within the scope of a single file.</p>
<p>In order to do so, the entry level nix files of this framework have exactly one possible interface: <code>{inputs, cell}</code>.</p>
<p><code>inputs</code> represent the global inputs, whereas <code>cell</code> keeps reference to the local context.
<em>A Cell is the first ordering priciple for &quot;consitent collection of functionality&quot;.</em></p>
<h2 id="consequences-1"><a class="header" href="#consequences-1">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>This restricts up to the prescribed 3 layers of organization the notion of &quot;how files can communicate with each other&quot;.</p>
<p>That inter-files-interface is the <em>only</em> global context to really grasp, and it is structurally aligned across all Standard projects.</p>
<p>By virtue of this meta model of a global context and interfile-communications, for a somewhat familiarized code reader the barriers to local reasoning are greatly reduced.</p>
<p>The two context references are well known (flake inputs &amp; cell-local blocks) and easily discoverable.</p>
<p>For authors, this schema takes away any delay that might arise out of the consideration of how to best structure that inter-file communcation schema.</p>
<p>Out of experience, a significant and low value (and ad-hoc) design process can by leap-frogged via this guidance.</p>
<hr />
<h1 id="3-hide-system-for-mortals"><a class="header" href="#3-hide-system-for-mortals">3. Hide system for mortals</a></h1>
<p>Date: 2022-04-01</p>
<h2 id="status-2"><a class="header" href="#status-2">Status</a></h2>
<p>accepted</p>
<h2 id="context-2"><a class="header" href="#context-2">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>In the context of DevOps (Standard is a DevOps framework), cross compilation is a significatly lesser concern, than what it is for packagers.</p>
<p>The pervasive use of <code>system</code> in the current Nix (and foremost Flakes) Ecosystem is an optimization (and in part education) choice for these packagers.</p>
<p>However, in the context of DevOps, while not being irrelevant, it accounts for a fair share of distraction potential.</p>
<p>This ultimately diminuishes code-readibility and reasoning; and consequentially adoption. Especially in those code paths, where <code>system</code> is a secondary concern.</p>
<h2 id="decision-2"><a class="header" href="#decision-2">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>De-systemize everything to the &quot;current&quot; system and effectively hiding the explict manipulation from plain sight in most cases.</p>
<p>An attribute set, that differentiates for systems on any given level of its tree, is <code>deSystemized</code>.</p>
<p>This means that all child attributes of the &quot;current&quot; system are lifted onto the &quot;system&quot;-level as siblings to the system attributes.</p>
<p>That also means, if explicit reference to <code>system</code> is necessary, it is still there among the siblings.</p>
<p>The &quot;current&quot; system is brought into scope automatically, however.</p>
<p>What &quot;current&quot; means, is an early selector (&quot;select early and forget&quot;), usually determined by the user's operating system.</p>
<h2 id="consequences-2"><a class="header" href="#consequences-2">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>The explicit handling of <code>system</code> in foreing context, where <code>system</code> is not a primary concern is largely eliminated.</p>
<p>This makes using this framework a little easier for everybody, including packaging experts.</p>
<p>Since <code>nixpkgs</code>, itself, exposes <code>nixpkgs.system</code> and packaging without <code>nixpkgs</code> is hardly imaginably, power-users still enjoy easy access to the &quot;current&quot; system, in case it's needed.</p>
<hr />
<h1 id="4-early-select-system-for-conceptual-untangling"><a class="header" href="#4-early-select-system-for-conceptual-untangling">4. Early select system for conceptual untangling</a></h1>
<p>Date: 2022-04-01</p>
<h2 id="status-3"><a class="header" href="#status-3">Status</a></h2>
<p>accepted</p>
<h2 id="context-3"><a class="header" href="#context-3">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Building on the previous ADR, we saw why we hide <code>system</code> from plain sight.</p>
<p>In that ADR, we mention &quot;select early and forget&quot; as a strategy to scope the current system consistently across the project.</p>
<p>The current best practices for flakes postulate <code>system</code> as the second level selector of an output attribute.</p>
<p>For current flakes, type primes over system.</p>
<p>However, this design choice makes the lema &quot;select early and forget&quot; across multiple code-paths a pain to work with.</p>
<p>This handling is exacerbated by the distinction between &quot;systemized&quot; and &quot;non-systemized&quot; (e.g. <code>lib</code>) output attributes.</p>
<p>In the overall set of optimization goals of this framework, this distinction is of extraordinarily poor value, more so, that function
calls are memoized during a single evaluation, which renders the system selector comuptationally irrelevant where not used.</p>
<h2 id="decision-3"><a class="header" href="#decision-3">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<ul>
<li>Move the <code>system</code> selector from the second level to the first level.</li>
<li>Apply the <code>system</code> selector regardless and without excheption.</li>
</ul>
<h2 id="consequences-3"><a class="header" href="#consequences-3">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>The motto &quot;select early and forget&quot; makes various code-paths easier to reason about and maintain.</p>
<p>The Nix CLI completion won't respond gracefully to these changes.
However, the Nix CLI is explicitly <em>not</em> a primary target of this framework.
The reason for this is that the use cases for the Nix CLI are somewhat skewed towards the packager use case, but in any case are (currently) not purpose built for the DevOps use case.</p>
<p>A simple patch to the Nix binary, can mitigate this for people who's muscle memory prefers the Nix CLI regardless.
If you've already got that level of muscle memory, its meandering scope is probably anyways not an issue for you anymore.</p>
<hr />
<h1 id="5-nixpkgs-is-still-special-but-not-too-much"><a class="header" href="#5-nixpkgs-is-still-special-but-not-too-much">5. Nixpkgs is still special, but not too much</a></h1>
<p>Date: 2022-05-01</p>
<h2 id="status-4"><a class="header" href="#status-4">Status</a></h2>
<p>accepted</p>
<h2 id="context-4"><a class="header" href="#context-4">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>In general, Standard wouldn't treat any intput as special.
However, no project that requires source distributions of one of the 80k+ packages available in <code>nixpkgs</code> can practically do without it.</p>
<p>Now, <code>nixpkgs</code> has this wired and counter-intuitive mouthful of <code>legacyPackages</code>, which was originally intended to ring an alarm bell and, for the non-nix-historians, still does.</p>
<p>Also, not very many other package collections adopt this idiom which makes it pretty much a singularity of the Nix package collection (<code>nixpkgs</code>).</p>
<h2 id="decision-4"><a class="header" href="#decision-4">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>If <code>inputs.nixpkgs</code> is provided, in-scope <code>legacyPackages</code> onto <code>inputs.nixpkgs</code>, directly.</p>
<h2 id="consequences-4"><a class="header" href="#consequences-4">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Users of Standard access packages as <code>nixpkgs.&lt;package-name&gt;</code>.</p>
<p>Users that want to interact with nixos, do so by loading <code>nixos = import (inputs.nixpkgs + &quot;/nixos&quot;);</code> or similar.
The close coupling of the Nix Package Collection and NixOS now is broken.
This suites well the DevOps use case, which is not <em>primarily</em> concerned with the unseparable union of the Nix Packages Collection and NixOS.
It rather presents a plethora of use cases that content with the Nix Package Collection, alone, and where NixOS would present as a distraction.
Now, this separation is more <em>explicit</em>.</p>
<p>As another consequence of not treating <code>nixpkgs</code> (or even the packaging use case) special is that Standard does not implement primary support for <code>overlays</code>.</p>
<hr />
<h1 id="6-avoid-fix-point-logic-such-as-overlays"><a class="header" href="#6-avoid-fix-point-logic-such-as-overlays">6. Avoid fix-point logic, such as overlays</a></h1>
<p>Date: 2022-05-01</p>
<h2 id="status-5"><a class="header" href="#status-5">Status</a></h2>
<p>accepted</p>
<h2 id="context-5"><a class="header" href="#context-5">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Fix point logic is marvelously magic and also very practical.
A lot of people love the concept of <code>nixpkgs</code>'s <code>overlays</code>.</p>
<p>However, we've all been suckers in the early days, and fix point logic wasn't probably one of the concepts that we grasped intuitivly and right at the beginning of our Nix journey.</p>
<p>The concept of recursivity all in itself is already demanding to reason about, where the concept of recourse-until-not-more-possible is even more mind-boggling.</p>
<p>Fix points are also clear instances of overloading global context.</p>
<p>And global context is a double edged sword between high-productivity for that one who has a good mental model of it and nightmare for that one who has to resort to local reasoning.</p>
<h2 id="decision-5"><a class="header" href="#decision-5">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>In the interest of balancing productivity (for the veteran) and ease-of-onboarding (for the novice), we do not implement a prime support for fix-point logic, such as <code>overlays</code> at the framework level.</p>
<h2 id="consequences-5"><a class="header" href="#consequences-5">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Users who depend on it, need to scope its use to a particular Cell Block.
For the Nix package collection, users can do, for example: <code>nixpkgs.appendOverlays [ /* ... */ ]</code>.
There is a small penalty in evaluating <code>nixpkgs</code> a second time, since every moving of the fix point retriggers a complete evalutation.
But since this decision is made in the interest of <em>balancing</em> enacting trade-offs, this appears to be cost-effective in accordance with the overall optimization goals of Standard.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><em>This is an opinionated pattern.</em></p>
<p><em>It helps structure working together on microservices with <code>std</code>.</em></p>
</blockquote>
<h1 id="the-4-layers-of-packaging"><a class="header" href="#the-4-layers-of-packaging">The 4 Layers of Packaging</a></h1>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>We have written an application and now we want to package and run it.
For its supply chain security benefits, we have been advised to employ reproducible and source-based distribution mechanisms.
We furthermore need an interoperability platform that is generic and versatile: a <em>configuration &quot;lingua franca&quot;</em>.
Our peers who write another application in another language should share that same approach.
Thereby, we avoid the negative external effects of DevOps silos on integrators and operators, alike.
Short: we make adoption of our application as easy as possible for our consumers.</p>
<h2 id="the-actors"><a class="header" href="#the-actors">The Actors</a></h2>
<p><em>Note, that each actor persona can be exercised by one and the same person or a group of persons.
Although possible, and even frequently so, it doesn't imply that these roles are necessarily taken by distinct individuals.</em></p>
<h3 id="developer"><a class="header" href="#developer">Developer</a></h3>
<p>The Developer persona incrementally modifies the source code.
At times, such modification are relevant at the interface to the Operator persona.
One such example is when the app configuration is modified.
Another one, when important runtime characteristics are amended.</p>
<h3 id="operator"><a class="header" href="#operator">Operator</a></h3>
<p>The Operator persona brings the application to production.
She typically engages in further wrapping code or other artifact creation.
She also supervises and observes the running application across different environments.</p>
<h3 id="release-manager"><a class="header" href="#release-manager">Release Manager</a></h3>
<p>The Release Manager persona cuts releases at discrete points in time.
In doing so, she procures their artifacts for general (public) consumtion.
Any release is tied to a sufficiently high level of assurance of an artifact's desired properties.
For that purpose, she works with the Developer, Operator &amp; QA personas along these 4 layers of packaging.</p>
<h3 id="qa"><a class="header" href="#qa">QA</a></h3>
<p>The QA persona establishes various levels of assurance of an artifact's desired properties.
Thereby, the observable artifacts can emanate from any layer of these 4 layers of packaging.
She informs the Developer, Operator and Release Manager personas about any found assurance levels.
She can do so through manual or automatic (CI) means.</p>
<h2 id="the-layers"><a class="header" href="#the-layers">The Layers</a></h2>
<pre class="mermaid">flowchart TD
    packaging([Packaging])
    operable([Operable])
    image([OCI-Image])
    scheduler([Scheduler Chart])
    packaging --&gt; operable
    operable --&gt; image
    image --&gt; scheduler

    click packaging href &quot;#packaging-layer&quot; &quot;Jump to the packaging layer section&quot;
    click operable href &quot;#operable-layer&quot; &quot;Jump to the operable layer section&quot;
    click image href &quot;#oci-image-layer&quot; &quot;Jump to the OCI image layer section&quot;
    click scheduler href &quot;#scheduler-chart-layer&quot; &quot;Jump to the scheduler chart layer section&quot;
</pre>
<hr />
<p>There is one very important factoring &amp; interoperability rule about these layers:</p>
<p><em>A domain concern of a higher layer <strong>must not</strong> bleed into previous layers.</em></p>
<p>Observing this very simple rule ensures long term interoperability and maintainability of the stack.
For example, not presuming a particular scheduler in the operable gives contributors a chance to easily add another scheduler target without painful refactoring.</p>
<blockquote>
<p><em><strong>Future Work:</strong> depending on how you count, there may be actually a 5th layer: the <strong>operator</strong> layer. But we may cover this in a future version of this article in further detail. If you don't want to wait, you may have a conceptual look at the <a href="https://juju.is/docs/olm">Charmed Operator Framework</a> and <a href="https://charmhub.io/">Charmehub</a>.</em></p>
</blockquote>
<p><em>Note, that it would be possible to further fold these interfaces and a Nix veteran might be inclined to do so.
But doing so would defeat the purpose of exposing well defined layered interfaces alongside role-boundaries, subject matter concepts for ease of communication and collaboration; as well as external artifact consumers.</em></p>
<h3 id="packaging-layer"><a class="header" href="#packaging-layer">Packaging Layer</a></h3>
<pre><code class="language-yaml">Cell Block: (blockType.installables &quot;packages&quot;)
Location:  **/packages.nix          # or **/packages/
Actors:
 - Build Expert Panel, Nix- &amp; language-specific
 - Release Manager
</code></pre>
<p>This Cell Block builds, unit-tests &amp; packages the application via the appropriate <a href="patterns/../explain/why-nix.html#nix-superpowers">Nix primitives</a>.
Each programming language has a different best practice approach to packaging.
Therfore, a fair ammount of domain knowledge between Nix and the language's build system is required.</p>
<p>The location of the actual build instructions are secondary.
At minimum, though, for transparency's and uniformity's sake, they are still proxied via this Cell Block.
So in the case that upstream already contains appropriate build instructions, the following indirection is perfectly valid (and necessary):</p>
<pre><code class="language-nix">{ inputs, cell }: {
  app = inputs.upstream.packages.some-app;
}
</code></pre>
<p>Build instructions themselves should encompass executing unit tests.
Builds that fail unit tests should already be filtered out at this layer (i.e. &quot;a build that fails unit tests is no build, at all&quot;).</p>
<p>A Release Manager may decide to provide these artifacts to the general public on tagged releases.</p>
<blockquote>
<p><strong>In a hurry?</strong></p>
<p>Fetching binary artifacts and incorporating them at this layer as a temporary work-around for non-production enviornments is acceptable.</p>
</blockquote>
<h3 id="operable-layer"><a class="header" href="#operable-layer">Operable Layer</a></h3>
<pre><code class="language-yaml">Cell Block: (blockType.runnables &quot;operables&quot;)
Location:  **/operables.nix       # or **/operables/
Actors:
 - Developer
 - Operator
</code></pre>
<p>This Cell Block exclusively defines the runtime environment of the application via the operable script.
The role of this script — customarily written in <code>bash</code> — serves as a concise and reified communication channel between Developers and Operators.
As such, Operators will find all the primary configuration options re-encoded at a glance and in a well-known location.
In the other direction, Developers will find all the magic ad-hoc wrapping that Operators had to engage in, in order to run the application on the target scheduler.</p>
<p>Through this communication channel, operators take reliably note of configuration drift, while Developers gain a valuable source of backlog to increase the operational robustness of the application.</p>
<p>Standard includes a <a href="patterns/../reference/lib/ops/mkOperable.html">specific library function</a> that establishes an implementation-site interface for operables and their collaterals which significantly eases working on the following layers.</p>
<h3 id="oci-image-layer"><a class="header" href="#oci-image-layer">OCI-Image Layer</a></h3>
<pre><code class="language-yaml">Cell Block: (blockType.containers &quot;oci-images&quot;)
Location:  **/oci-images.nix        # or **/oci-images/
Actors:
 - Operator
 - Release Manager
</code></pre>
<p>This layered packaging pattern promotes source-based distribution in principle.
Despite, in common operating scenarios, we require a security stop-gap separation.
This ensures very fundamentally that nothing is accidentially <em>built</em> on the target (production) worker node, where it would cannibalize critical resources.</p>
<p>We chose OCI-Images as the binary distribution format.
It not only fits that purpose through the <a href="https://github.com/opencontainers/distribution-spec">OCI Distribution Specification</a>, but also collaterally procures interoperability for 3rd parties:
OCI images are the de-facto industry standard for deployment artifacts.</p>
<p>If the operables have been created via the above mentioned <a href="patterns/../reference/lib/ops/mkOperable.html">library function</a>.
Using the <a href="patterns/../reference/lib/ops/mkStandardOCI.html">Standard OCI image library function</a>, the creation of OCI images trivially reduces to:</p>
<pre><code class="language-nix">{ inputs, cell }: let
  inherit (inputs.std.lib) ops;
in {
  image-hard = ops.mkStandardOCI {
    name = &quot;docker.io/my-image-hardened&quot;;
    operable = cell.operables.app;
  };
  image = ops.mkStandardOCI {
    name = &quot;docker.io/my-image&quot;;
    operable = cell.operables.app;
    debug = true;
  };
}
</code></pre>
<p>Alternatively, any of the avaible Nix-based OCI generation mini-frameworks can be used;
<a href="https://github.com/nlewo/nix2container"><code>nlewo/nix2container</code></a> being the recommended one.
Hence, this mini-framework is internally used by the operables library function.</p>
<p>A Release Manager may decide to provide these artifacts to the general public on tagged releases.</p>
<blockquote>
<p><strong>In a hurry?</strong></p>
<p>Fetching published images and incorporating them at this layer as a temporary work-around for non-production enviornments is acceptable.</p>
</blockquote>
<h3 id="scheduler-chart-layer"><a class="header" href="#scheduler-chart-layer">Scheduler Chart Layer</a></h3>
<pre><code class="language-yaml">Cell Block: (blockType.functions &quot;&lt;sched&gt;Charts&quot;)
Location:  **/&lt;sched&gt;Charts.nix     # or **/&lt;sched&gt;Charts/
Actors:
 - Operator
 - Release Manager
</code></pre>
<p>The scheduler chart is not <em>yet</em> mainfest data.
Rather, it is a function interface that commonly renders to such json-serializable manifest data.
These mainfests are then ingested and interpreted by the scheduler.</p>
<p>A fair amount of scheduler domain knowledge and familiarity with its scheduling options is required, especially
during creation.</p>
<p>These charts can then be processed further downstream (e.g. in Nix code) to specialize out the final manifests and environments.</p>
<p>Since these charts are the basis of various environments for development, staging and production, it is <em>highly</em> recommended to keep their function interface extremely mininmal <strong>and</strong> stable.
This avoids the risk of inadvertely modifying production manifests (e.g. via a human error in the base charts) based on a development or staging requirement.
In these cases, it is <em>highly</em> recommended to resort to data-oriented overlay mechanisms for ad-hoc modification.
A purpose-built tool to do so (called <a href="https://github.com/divnix/data-merge"><code>data-merge</code></a>) is already re-exported under <code>std.dmerge</code> for convenience.
Those modifications should only propagate into a chart interface after <em>stabilizing</em> and after having successfully percolated through all existing environments first.</p>
<p>A Release Manager may decide to provide these artifacts to the general public on tagged releases.
For example: in the transpiled form of a widely used scheduler-specific config sharing format, such as <a href="https://helm.sh/docs/topics/charts/">helm-charts</a>.</p>
<blockquote>
<p><em><strong>Future Work:</strong> it might be a feasible task to extract a common base interface among different schedulers
and thereby implement a base chart that we could simply specialize for each target schedulers (including <code>systemd</code>).
But this may be subject of future research.
Potentially, the above mentioned <a href="https://juju.is/docs/olm">Charmed Operator Framework</a> even obsoletes that need a priori and in practical terms.</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-minimal-project-template-with-docs"><a class="header" href="#a-minimal-project-template-with-docs">A minimal project template with docs!</a></h1>
<h2 id="included-configuration"><a class="header" href="#included-configuration">Included Configuration</a></h2>
<ul>
<li><a href="https://numtide.github.io/devshell/"><code>devshell</code></a> for your contribution environments!</li>
<li><a href="https://numtide.github.io/treefmt/"><code>treefmt</code></a> for formatting all the things!</li>
<li><a href="https://rust-lang.github.io/mdBook/"><code>mdbook</code></a> for making documentation part of your workflow!</li>
<li><a href="https://github.com/evilmartians/lefthook"><code>lefthook</code></a> for commit discipline and a clean history!</li>
<li><a href="https://github.com/apps/settings">GitHub Setting App</a> for configuring GitHub declaratively!</li>
</ul>
<h2 id="bootstrap"><a class="header" href="#bootstrap">Bootstrap</a></h2>
<pre><code class="language-bash"># make a new empty project dir
mkdir my-project
cd my-project

# grab the template
nix flake init -t github:divnix/std#minimal

# see which values to change
grep -r --include=\*.nix 'CONFIGURE-ME' .

# do some inititialization
git init &amp;&amp; git add .

# enter the devshell and effectuate repo configuration
direnv allow

git add . &amp;&amp; git commit -m &quot;feat: initial commit&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-and-nix-and-rust-oh-my"><a class="header" href="#standard-and-nix-and-rust-oh-my">Standard, and Nix and Rust, oh my!</a></h1>
<p>This template uses <a href="https://nixos.org">Nix</a> to create a sane development shell for
Rust projects, <a href="https://github.com/divnix/std#readme">Standard</a> for keeping your Nix code well organized,
<a href="https://github.com/nix-community/fenix#readme">Fenix</a> for pulling the latest rust binaries via Nix, and
<a href="https://github.com/ipetkov/crane#readme">Crane</a> for building Rust projects in Nix incrementally, making
quick iteration a breeze.</p>
<p>Rust Analyzer is also wired up properly for immediate use from a
terminal based editor with language server support. Need one with
stellar Nix and Rust support? Try <a href="https://github.com/helix-editor/helix#readme">Helix</a>!</p>
<h2 id="bootstrap-1"><a class="header" href="#bootstrap-1">Bootstrap</a></h2>
<pre><code class="language-bash"># make a new empty project dir
mkdir my-project
cd my-project

# grab the template
nix flake init -t github:divnix/std#rust

# do some inititialization
git init &amp;&amp; git add .

# enter the devshell
direnv allow || nix develop

# continue some inititialization
cargo init # pass --lib for library projects
cargo build # to generate Cargo.lock

git add . &amp;&amp; git commit -m &quot;init&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuicli"><a class="header" href="#tuicli">TUI/CLI</a></h1>
<h4 id="tuicli-1"><a class="header" href="#tuicli-1">TUI/CLI:</a></h4>
<pre><code class="language-console"># TUI
std

# CLI
std //&lt;TAB&gt;
std re-cache # refresh the CLI cache
std list     # show a list of all targets

# Version
std -v
</code></pre>
<h4 id="help"><a class="header" href="#help">Help:</a></h4>
<pre><code class="language-console">❯ std -h
std is the CLI / TUI companion for Standard.

- Invoke without any arguments to start the TUI.
- Invoke with a target spec and action to run a known target's action directly.

Usage:
  std //[cell]/[block]/[target]:[action] [args...]
  std [command]

Available Commands:
  list        List available targets.
  re-cache    Refresh the CLI cache.

Flags:
  -h, --help      help for std
  -v, --version   version for std

Use &quot;std [command] --help&quot; for more information about a command.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conventions-in-std"><a class="header" href="#conventions-in-std">Conventions in <code>std</code></a></h1>
<p>In principle, we all want to be able to read code with local reasoning.</p>
<p>However, these few conventions are pure quality of life and
help us to keep our nix code organized.</p>
<h2 id="nix-file-locations"><a class="header" href="#nix-file-locations">Nix File Locations</a></h2>
<p>Nix files are imported from either of these two locations, if present, in this order of precedence:</p>
<pre><code>${cellsFrom}/${cell}/${block}.nix
${cellsFrom}/${cell}/${block}/default.nix
</code></pre>
<h2 id="readme-file-locations"><a class="header" href="#readme-file-locations">Readme File Locations</a></h2>
<p>Readme files are picked up by the TUI in the following places:</p>
<pre><code>${cellsFrom}/${cell}/Readme.md
${cellsFrom}/${cell}/${block}/Readme.md
${cellsFrom}/${cell}/${block}/${target}.md
</code></pre>
<h2 id="cell-block-file-arguments"><a class="header" href="#cell-block-file-arguments">Cell Block File Arguments</a></h2>
<p>Each Cell Block is a function and expects the following standardized interface for interoperability:</p>
<pre><code class="language-nix">{ inputs, cell }: {}
</code></pre>
<h2 id="the-inputs-argument"><a class="header" href="#the-inputs-argument">The <code>inputs</code> argument</a></h2>
<p>The <code>inputs</code> argument holds all the de-systemized flake inputs plus a few special inputs:</p>
<pre><code class="language-nix">{
  inputs = {
    self = {}; # sourceInfo of the current repository
    nixpkgs = {}; # an _instantiated_ nixpkgs
    cells = {}; # the other cells in this repo
  };
}
</code></pre>
<h2 id="the-cell-argument"><a class="header" href="#the-cell-argument">The <code>cell</code> argument</a></h2>
<p>The <code>cell</code> argument holds all the different Cell Block targets of the current cell.
This is the main mechanism by which code organization and separation of concern is enabled.</p>
<h2 id="the-desytemized-inputs"><a class="header" href="#the-desytemized-inputs">The <code>deSytemize</code>d inputs</a></h2>
<p>All inputs are scoped for the <em>current</em> system, that is derived from the <code>systems</code> input list to <code>std.grow</code>.
That means contrary to the usual nix-UX, in most cases, you don't need to worry about <code>system</code>.</p>
<p>The current system will be &quot;lifted up&quot; one level, while still providing full access to all <code>systems</code> for
cross-compilation scenarios.</p>
<pre><code class="language-nix"># inputs.a.packages.${system}
{
  inputs.a.packages.pkg1 = {};
  inputs.a.packages.pkg2 = {};
  /* ... */
  inputs.a.packages.${system}.pkgs1 = {};
  inputs.a.packages.${system}.pkgs2 = {};
  /* ... */
}
</code></pre>
<h2 id="top-level-system-scoping-of-outputs"><a class="header" href="#top-level-system-scoping-of-outputs">Top-level <code>system</code>-scoping of outputs</a></h2>
<p>Contrary to the upstream flake schema, all outputs are <code>system</code> spaced at the top-level.
This allows us to uniformly select on the <em>current</em> system and forget about it for most
of the time.</p>
<p>Sometimes <code>nix</code> evaluations don't strictly depend on a particular <code>system</code>, and scoping
them seems counter-intuitive. But due to the fact that function calls are memoized, there
is never a penalty in actually scoping them. So for the sake of uniformity, we scope them
anyways.</p>
<p>The outputs therefore abide by the following &quot;schema&quot;:</p>
<pre><code class="language-nix">{
  ${system}.${cell}.${block}.${target} = {};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deprecations"><a class="header" href="#deprecations">Deprecations</a></h1>
<pre><code class="language-nix">{inputs}: time: body: let
  l = inputs.nixpkgs.lib // builtins;
  ansi = import ./ansi.nix;
  pad = s: let
    n = 17;
    prefix = l.concatStringsSep &quot;&quot; (l.genList (_: &quot; &quot;) (n - (l.stringLength s)));
  in
    prefix + s;
  indent = s: let
    n = 5;
    prefix = l.concatStringsSep &quot;&quot; (l.genList (_: &quot; &quot;) n);
    lines = l.splitString &quot;\n&quot; s;
  in
    &quot;  📝 │ &quot; + (l.concatStringsSep &quot;\n${prefix}│ &quot; lines);
  warn = let
    apply =
      l.replaceStrings
      (map (key: &quot;{${key}}&quot;) (l.attrNames ansi))
      (l.attrValues ansi);
  in
    msg:
      l.trace (apply &quot;🔥 {bold}{196}Standard Deprecation Notices - {220}run `std check' to show!{reset}&quot;)
      l.traceVerbose (apply &quot;\n{202}${msg}{reset}&quot;);
in
  warn ''
    ─────┬─────────────────────────────────────────────────────────────────────────
      💪 │ {bold}Action Required !{un-bold}
    ─────┼─────────────────────────────────────────────────────────────────────────
    {italic}${indent body}{un-italic}
    ─────┼─────────────────────────────────────────────────────────────────────────
      📅 │ {bold}Scheduled Removal: ${pad time}{un-bold}
    ─────┴─────────────────────────────────────────────────────────────────────────
  ''
</code></pre>
<p>Please observe the following deprecations and their deprecation schedule:</p>
<pre><code class="language-nix">inputs: let
  removeBy = import ./cells/std/errors/removeBy.nix {inherit inputs;};
in {
  warnOldActionInterface = actions:
    removeBy &quot;March 2023&quot; ''
      The action interface has chaged from:
        { system, flake, fragment, fragmentRelPath }
      To:
        { system, target, fragment, fragmentRelPath }

      Please adjust the following actions:

      ${builtins.concatStringsSep &quot;\n&quot; (map (a: &quot; - ${a.name}: ${(builtins.unsafeGetAttrPos &quot;name&quot; a).file}&quot;) actions)}
    '';

  warnNixagoOutfactored = removeBy &quot;May 2023&quot; ''
    std.presets.nixago has been outfactored into its own repository.

    Add to your flake.nix

    inputs.std-data-collection.url = &quot;github:divnix/std-data-collection&quot;;
    inputs.std-data-collection.inputs.std.follows = &quot;std&quot;;
    inputs.std-data-collection.inputs.nixpkgs.follows = &quot;nixpkgs&quot;;

    Replace accessors of
      `inputs.std.presets.nixago`
    with
      `inputs.std-data-collection.data.configs`
  '';

  warnNixagoMoved = removeBy &quot;May 2023&quot; ''
    In order to improve semantic clarity,
    std.std.nixago has been moved to std.lib.cfg.

    Replace accessors of
      `inputs.std.std.nixago`
    with
      `inputs.std.lib.cfg`
  '';
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="sidetoc"><nav class="pagetoc"></nav></div>
<h1 id="builtin-block-types"><a class="header" href="#builtin-block-types">Builtin Block Types</a></h1>
<p>A few Block Types are packaged with <code>std</code>.</p>
<p>In practical terms, Block Types distinguish themselves through the
actions they provide to a particular Cell Block.</p>
<p>It is entirely possible to define custom Block Types with custom
Actions according to the needs of your project.</p>
<h2 id="arion"><a class="header" href="#arion">Arion</a></h2>
<pre><code class="language-nix">{
  nixpkgs,
  mkCommand,
}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the arion for arionCompose Jobs - https://docs.hercules-ci.com/arion/

  Available actions:
    - up
    - ps
    - stop
    - rm
    - config
    - arion
  */
  arion = name: {
    inherit name;
    type = &quot;arion&quot;;
    actions = {
      system,
      fragment,
      fragmentRelPath,
      target,
    }: let
      cmd = &quot;arion --prebuilt-file ${target.config.out.dockerComposeYaml}&quot;;
    in [
      (mkCommand system {
        name = &quot;up&quot;;
        description = &quot;arion up&quot;;
        command = ''
          ${cmd} up &quot;$@&quot;
        '';
      })
      (mkCommand system {
        name = &quot;ps&quot;;
        description = &quot;exec this arion task to ps&quot;;
        command = ''
          ${cmd} ps &quot;$@&quot;
        '';
      })
      (mkCommand system {
        name = &quot;stop&quot;;
        description = &quot;arion stop&quot;;
        command = ''
          ${cmd} stop &quot;$@&quot;
        '';
      })
      (mkCommand system {
        name = &quot;rm&quot;;
        description = &quot;arion rm&quot;;
        command = ''
          ${cmd} rm &quot;$@&quot;
        '';
      })
      (mkCommand system {
        name = &quot;config&quot;;
        description = &quot;check the docker-compose yaml file&quot;;
        command = ''
          ${cmd} config &quot;$@&quot;
        '';
      })
      (mkCommand system {
        name = &quot;arion&quot;;
        description = &quot;pass any command to arion&quot;;
        command = ''
          ${cmd} &quot;$@&quot;
        '';
      })
    ];
  };
in
  arion
</code></pre>
<h2 id="runnables-todo-vs-installables"><a class="header" href="#runnables-todo-vs-installables">Runnables (todo: vs installables)</a></h2>
<pre><code class="language-nix">{
  nixpkgs,
  mkCommand,
  sharedActions,
}: let
  lib = nixpkgs.lib // builtins;
  /*
  Use the Runnables Blocktype for targets that you want to
  make accessible with a 'run' action on the TUI.
  */
  runnables = name: {
    __functor = import ./__functor.nix;
    inherit name;
    type = &quot;runnables&quot;;
    actions = {
      system,
      fragment,
      fragmentRelPath,
      target,
    }: [
      (sharedActions.build system target)
      (sharedActions.run system target)
    ];
  };
in
  runnables
</code></pre>
<h2 id="installables-todo-vs-runnables"><a class="header" href="#installables-todo-vs-runnables">Installables (todo: vs runnables)</a></h2>
<pre><code class="language-nix">{
  nixpkgs,
  mkCommand,
  sharedActions,
}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Installables Blocktype for targets that you want to
  make availabe for installation into the user's nix profile.

  Available actions:
    - install
    - upgrade
    - remove
    - build
    - bundle
    - bundleImage
    - bundleAppImage
  */
  installables = name: {
    __functor = import ./__functor.nix;
    inherit name;
    type = &quot;installables&quot;;
    actions = {
      system,
      fragment,
      fragmentRelPath,
      target,
    }: [
      (sharedActions.build system target)
      # profile commands require a flake ref
      (mkCommand system {
        name = &quot;install&quot;;
        description = &quot;install this target&quot;;
        command = ''
          # ${target}
          if test -z &quot;$PRJ_ROOT&quot;; then
            echo &quot;PRJ_ROOT is not set. Action aborting.&quot;
            exit 1
          fi
          nix profile install $PRJ_ROOT#${fragment}
        '';
      })
      (mkCommand system {
        name = &quot;upgrade&quot;;
        description = &quot;upgrade this target&quot;;
        command = ''
          # ${target}
          if test -z &quot;$PRJ_ROOT&quot;; then
            echo &quot;PRJ_ROOT is not set. Action aborting.&quot;
            exit 1
          fi
          nix profile upgrade $PRJ_ROOT#${fragment}
        '';
      })
      (mkCommand system {
        name = &quot;remove&quot;;
        description = &quot;remove this target&quot;;
        command = ''
          # ${target}
          if test -z &quot;$PRJ_ROOT&quot;; then
            echo &quot;PRJ_ROOT is not set. Action aborting.&quot;
            exit 1
          fi
          nix profile remove $PRJ_ROOT#${fragment}
        '';
      })
      # TODO: use target. `nix bundle` requires a flake ref, but we may be able to use nix-bundle instead as a workaround
      (mkCommand system {
        name = &quot;bundle&quot;;
        description = &quot;bundle this target&quot;;
        command = ''
          # ${target}
          if test -z &quot;$PRJ_ROOT&quot;; then
            echo &quot;PRJ_ROOT is not set. Action aborting.&quot;
            exit 1
          fi
          nix bundle --bundler github:Ninlives/relocatable.nix --refresh $PRJ_ROOT#${fragment}
        '';
      })
      (mkCommand system {
        name = &quot;bundleImage&quot;;
        description = &quot;bundle this target to image&quot;;
        command = ''
          # ${target}
          if test -z &quot;$PRJ_ROOT&quot;; then
            echo &quot;PRJ_ROOT is not set. Action aborting.&quot;
            exit 1
          fi
          nix bundle --bundler github:NixOS/bundlers#toDockerImage --refresh $PRJ_ROOT#${fragment}
        '';
      })
      (mkCommand system {
        name = &quot;bundleAppImage&quot;;
        description = &quot;bundle this target to AppImage&quot;;
        command = ''
          # ${target}
          if test -z &quot;$PRJ_ROOT&quot;; then
            echo &quot;PRJ_ROOT is not set. Action aborting.&quot;
            exit 1
          fi
          nix bundle --bundler github:ralismark/nix-appimage --refresh $PRJ_ROOT#${fragment}
        '';
      })
    ];
  };
in
  installables
</code></pre>
<h2 id="pkgs"><a class="header" href="#pkgs">Pkgs</a></h2>
<pre><code class="language-nix">{...}: let
  /*
  Use the Pkgs Blocktype if you need to construct your custom
  variant of nixpkgs with overlays.

  Targets will be excluded from the CLI / TUI  and thus not
  slow them down.
  */
  pkgs = name: {
    inherit name;
    type = &quot;pkgs&quot;;
    cli = false; # its special power
  };
in
  pkgs
</code></pre>
<h2 id="devshells"><a class="header" href="#devshells">Devshells</a></h2>
<pre><code class="language-nix">{
  nixpkgs,
  mkCommand,
  sharedActions,
}: let
  l = nixpkgs.lib // builtins;
  mkDevelopDrv = import ../devshell-drv.nix;
  /*
  Use the Devshells Blocktype for devShells.

  Available actions:
    - build
    - enter
  */
  devshells = name: {
    __functor = import ./__functor.nix;
    inherit name;
    type = &quot;devshells&quot;;
    actions = {
      system,
      fragment,
      fragmentRelPath,
      target,
    }: let
      developDrv = mkDevelopDrv target;
    in [
      (sharedActions.build system target)
      (mkCommand system {
        name = &quot;enter&quot;;
        description = &quot;enter this devshell&quot;;
        command = ''
          if test -z &quot;$PRJ_ROOT&quot;; then
            echo &quot;PRJ_ROOT is not set. Action aborting.&quot;
            exit 1
          fi
          if test -z &quot;$PRJ_DATA_DIR&quot;; then
            echo &quot;PRJ_DATA_DIR is not set. Action aborting.&quot;
            exit 1
          fi
          profile_path=&quot;$PRJ_DATA_DIR/${fragmentRelPath}&quot;
          mkdir -p &quot;$profile_path&quot;
          # ${developDrv}
          nix_args=(
            &quot;${builtins.unsafeDiscardStringContext developDrv.drvPath}&quot;
            &quot;--no-update-lock-file&quot;
            &quot;--no-write-lock-file&quot;
            &quot;--no-warn-dirty&quot;
            &quot;--accept-flake-config&quot;
            &quot;--no-link&quot;
            &quot;--build-poll-interval&quot; &quot;0&quot;
            &quot;--builders-use-substitutes&quot;
          )
          nix build &quot;''${nix_args[@]}&quot; --profile &quot;$profile_path/shell-profile&quot;
          _SHELL=&quot;$SHELL&quot;
          eval &quot;$(nix print-dev-env ${developDrv})&quot;
          SHELL=&quot;$_SHELL&quot;
          if ! [[ -v STD_DIRENV ]]; then
            if declare -F __devshell-motd &amp;&gt;/dev/null; then
              __devshell-motd
            fi
            exec $SHELL -i
          fi
        '';
      })
    ];
  };
in
  devshells
</code></pre>
<h2 id="nixago"><a class="header" href="#nixago">Nixago</a></h2>
<pre><code class="language-nix">{
  nixpkgs,
  mkCommand,
}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Nixago Blocktype for nixago pebbles.

  Use Nixago pebbles to ensure files are present
  or symlinked into your repository. You may typically
  use this for repo dotfiles.

  For more information, see: https://github.com/nix-community/nixago.

  Available actions:
    - ensure
    - explore

  */
  nixago = name: {
    inherit name;
    type = &quot;nixago&quot;;
    actions = {
      system,
      fragment,
      fragmentRelPath,
      target,
    }: [
      (mkCommand system {
        name = &quot;populate&quot;;
        description = &quot;populate this nixago file into the repo&quot;;
        command = ''
          ${target.install}/bin/nixago_shell_hook
        '';
      })
      (mkCommand system {
        name = &quot;explore&quot;;
        description = &quot;interactively explore the nixago file&quot;;
        command = ''
          ${nixpkgs.legacyPackages.${system}.bat}/bin/bat &quot;${target.configFile}&quot;
        '';
      })
    ];
  };
in
  nixago
</code></pre>
<h2 id="containers"><a class="header" href="#containers">Containers</a></h2>
<pre><code class="language-nix">{
  nixpkgs,
  mkCommand,
  sharedActions,
}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Containers Blocktype for OCI-images built with nix2container.

  Available actions:
    - print-image
    - copy-to-registry
    - copy-to-podman
    - copy-to-docker
  */
  containers = name: {
    __functor = import ./__functor.nix;
    inherit name;
    type = &quot;containers&quot;;
    actions = {
      system,
      fragment,
      fragmentRelPath,
      target,
    }: [
      (sharedActions.build system target)
      (mkCommand system {
        name = &quot;print-image&quot;;
        description = &quot;print out the image name &amp; tag&quot;;
        command = ''
          echo
          echo &quot;${target.imageName}:${target.imageTag}&quot;
        '';
      })
      (mkCommand system {
        name = &quot;publish&quot;;
        description = &quot;copy the image to its remote registry&quot;;
        command = let
          image = target.imageRefUnsafe or &quot;${target.imageName}:${target.imageTag}&quot;;
        in ''
          # docker://${builtins.unsafeDiscardStringContext image}
          ${target.copyToRegistry}/bin/copy-to-registry
        '';
        proviso =
          l.toFile &quot;container-proviso&quot;
          # bash
          ''
            function proviso() {
            local -n input=$1
            local -n output=$2

            local -a images
            local delim=&quot;$RANDOM&quot;

            function get_images () {
              command nix show-derivation $@ \
              | command jq -r '.[].env.text' \
              | command grep -o 'docker://\S*'
            }

            drvs=&quot;$(command jq -r '.actionDrv | select(. != &quot;null&quot;)' &lt;&lt;&lt; &quot;''${input[@]}&quot;)&quot;

            mapfile -t images &lt; &lt;(get_images $drvs)

            command cat &lt;&lt; &quot;$delim&quot; &gt; /tmp/check.sh
            #!/usr/bin/env bash
            if ! command skopeo inspect --insecure-policy &quot;$1&quot; &amp;&gt;/dev/null; then
            echo &quot;$1&quot; &gt;&gt; /tmp/no_exist
            fi
            $delim

            chmod +x /tmp/check.sh

            rm -f /tmp/no_exist

            echo &quot;''${images[@]}&quot; \
            | command xargs -n 1 -P 0 /tmp/check.sh

            declare -a filtered

            for i in &quot;''${!images[@]}&quot;; do
              if command grep &quot;''${images[$i]}&quot; /tmp/no_exist &amp;&gt;/dev/null; then
                filtered+=(&quot;''${input[$i]}&quot;)
              fi
            done

            output=$(command jq -cs '. += $p' --argjson p &quot;$output&quot; &lt;&lt;&lt; &quot;''${filtered[@]}&quot;)
            }
          '';
      })
      (mkCommand system {
        name = &quot;copy-to-registry&quot;;
        description = &quot;copy the image to its remote registry&quot;;
        command = ''
          ${target.copyToRegistry}/bin/copy-to-registry
        '';
      })
      (mkCommand system {
        name = &quot;copy-to-docker&quot;;
        description = &quot;copy the image to the local docker registry&quot;;
        command = ''
          ${target.copyToDockerDaemon}/bin/copy-to-docker-daemon
        '';
      })
      (mkCommand system {
        name = &quot;copy-to-podman&quot;;
        description = &quot;copy the image to the local podman registry&quot;;
        command = ''
          ${target.copyToPodman}/bin/copy-to-podman
        '';
      })
    ];
  };
in
  containers
</code></pre>
<h2 id="data"><a class="header" href="#data">Data</a></h2>
<pre><code class="language-nix">{
  nixpkgs,
  mkCommand,
}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Data Blocktype for json serializable data.

  Available actions:
    - write
    - explore

  For all actions is true:
    Nix-proper 'stringContext'-carried dependency will be realized
    to the store, if present.
  */
  data = name: {
    inherit name;
    type = &quot;data&quot;;
    actions = {
      system,
      fragment,
      fragmentRelPath,
      target,
    }: let
      inherit (nixpkgs.legacyPackages.${system}) pkgs;

      # if target ? __std_data_wrapper, then we need to unpack from `.data`
      json = pkgs.writeTextFile {
        name = &quot;data.json&quot;;
        text = builtins.toJSON (
          if target ? __std_data_wrapper
          then target.data
          else target
        );
      };
      jq = [&quot;${pkgs.jq}/bin/jq&quot; &quot;-r&quot; &quot;'.'&quot; &quot;${json}&quot;];
      fx = [&quot;|&quot; &quot;${pkgs.fx}/bin/fx&quot;];
    in [
      (mkCommand system {
        name = &quot;write&quot;;
        description = &quot;write to file&quot;;
        command = &quot;echo ${json}&quot;;
      })
      (mkCommand system {
        name = &quot;explore&quot;;
        description = &quot;interactively explore&quot;;
        command = l.concatStringsSep &quot;\t&quot; (jq ++ fx);
      })
    ];
  };
in
  data
</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<pre><code class="language-nix">{
  nixpkgs,
  mkCommand,
}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Functions Blocktype for reusable nix functions that you would
  call elswhere in the code.

  Also use this for all types of modules and profiles, since they are
  implemented as functions.

  Consequently, there are no actions available for functions.
  */
  functions = name: {
    inherit name;
    type = &quot;functions&quot;;
  };
in
  functions
</code></pre>
<h2 id="anything"><a class="header" href="#anything">Anything</a></h2>
<p><em>Note: while the implementation is the same as <code>functions</code>, the semantics are different. Implementations may diverge in the future.</em></p>
<pre><code class="language-nix">{
  nixpkgs,
  mkCommand,
}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Anything Blocktype as a fallback.

  It doesn't have actions.
  */
  anything = name: {
    inherit name;
    type = &quot;anything&quot;;
  };
in
  anything
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="sidetoc"><nav class="pagetoc"></nav></div>
<h1 id="the-standard-library"><a class="header" href="#the-standard-library">The Standard Library</a></h1>
<p>This library intends to cover the Software Delivery Life Cycle in the Standard way.</p>
<p>Each Cell Block covers a specific SDLC topic.</p>
<hr />
<h2 id="the-dev-library"><a class="header" href="#the-dev-library">The Dev Library</a></h2>
<p>This library covers <em>development</em> aspects of the SDLC.</p>
<h3 id="mkarion"><a class="header" href="#mkarion"><code>mkArion</code></a></h3>
<p>This is a transparent convenience proxy for <a href="https://github.com/hercules-ci/arion"><code>hercules-ci/arion</code>'s</a> <code>lib.build</code> function.</p>
<p>However, the arion's <code>nixos</code> config option was removed.</p>
<p>As Standard claims to be the integration layer it will not delegate integration via a foreign
interface to commissioned tools, such as arion.</p>
<p>This is a bridge towards and from docker-compose users. Making nixos part of the interface would
likely alienate that bridge for those users.</p>
<p>If you need a nixos-based container image, please check out the arion source code on how it's done.</p>
<h3 id="mkmakes"><a class="header" href="#mkmakes"><code>mkMakes</code></a></h3>
<p>... provides an interface to <code>makes</code> tasks</p>
<p>This is an integration for <a href="https://github.com/fluidattacks/makes"><code>fluidattacks/makes</code></a>.</p>
<p>A version that has this <a href="https://github.com/fluidattacks/makes/commit/cd8c4eda69e2ce8dc6f811973ba0d80070b4628a">patch</a> is a prerequisite.</p>
<h4 id="usage-example"><a class="header" href="#usage-example">Usage example</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs.std.lib) dev;
in {
  task = ops.mkMakes ./path/to/make/task//main.nix {};
}
</code></pre>
<p><em>Some refactoring of the tasks may be necessary. Let the error messages be your friend.</em></p>
<hr />
<h3 id="mknixago"><a class="header" href="#mknixago"><code>mkNixago</code></a></h3>
<p>This is a transparent convenience proxy for <a href="https://github.com/nix-community/nixago"><code>nix-community/nixago</code>'s</a> <code>lib.${system}.make</code> function.</p>
<p>It is enriched with a forward contract towards <code>std</code> enriched <code>mkShell</code> implementation.</p>
<p>In order to define <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code>'s</a> <code>commands</code> &amp; <code>packages</code> alongside the Nixago pebble,
just add the following attrset to the Nixago spec. It will be picked up automatically by <code>mkShell</code> when that pebble
is used inside its <code>config.nixago</code>-option.</p>
<pre><code class="language-nix">{ inputs, cell }: {
  foo = inputs.std.lib.dev.mkNixago {
    /* ... */
    packages = [ /* ... */ ];
    commands = [ /* ... */ ];
    devshell = { /* ... */ }; # e.g. for startup hooks
  };
}
</code></pre>
<p>{{#include ./lib/dev/mkShell.md}</p>
<hr />
<h2 id="the-ops-library"><a class="header" href="#the-ops-library">The Ops Library</a></h2>
<p>This library covers <em>operational</em> aspects of the SDLC.</p>
<h3 id="mkoperable"><a class="header" href="#mkoperable"><code>mkOperable</code></a></h3>
<p>... is a function interface into the <a href="reference//patterns/four-packaging-layers.html#operable-layer">second layer of packaging</a> of the Standard SDLC Packaging pattern.</p>
<p>It's purpose is to provide an easy way to enrich a &quot;package&quot; into an &quot;operable&quot;.</p>
<p>The function signature is as follows:</p>
<pre><code class="language-nix">  /*
  Makes a package operable by configuring the necessary runtime environment.

  Args:
  package: The package to wrap.
  runtimeScript: A bash script to run at runtime.
  runtimeEnv: An attribute set of environment variables to set at runtime.
  runtimeInputs: A list of packages to add to the runtime environment.
  livenessProbe: An optional derivation to run to check if the program is alive.
  readinessProbe: An optional derivation to run to check if the program is ready.

  Returns:
  An operable for the given package.
  */
</code></pre>
<h3 id="mkoci"><a class="header" href="#mkoci"><code>mkOCI</code></a></h3>
<p>... is a function to generate an OCI Image via <a href="https://github.com/nlewo/nix2container"><code>nix2container</code></a>.</p>
<p>The function signature is as follows:</p>
<pre><code class="language-nix">  /*
  Creates an OCI container image

  Args:
  name: The name of the image.
  entrypoint: The entrypoint of the image. Must be a derivation.
  tag: Optional tag of the image (defaults to output hash)
  setup: A list of setup tasks to run to configure the container.
  uid: The user ID to run the container as.
  gid: The group ID to run the container as.
  perms: A list of permissions to set for the container.
  labels: An attribute set of labels to set for the container. The keys are
  automatically prefixed with &quot;org.opencontainers.image&quot;.
  options: Additional options to pass to nix2container.buildImage.

  Returns:
  An OCI container image (created with nix2container).
  */
</code></pre>
<h3 id="mkstandardoci"><a class="header" href="#mkstandardoci"><code>mkStandardOCI</code></a></h3>
<p>... is a function interface into the <a href="reference//patterns/four-packaging-layers.html#oci-image-layer">third layer of packaging</a> of the Standard SDLC Packaging pattern.</p>
<p>It produces a Standard OCI Image from an <a href="reference/./mkOperable.html">&quot;operable&quot;</a>.</p>
<p>The function signature is as follows:</p>
<pre><code class="language-nix">  /*
  Creates an OCI container image using the given operable.

  Args:
  name: The name of the image.
  operable: The operable to wrap in the image.
  tag: Optional tag of the image (defaults to output hash)
  setup: A list of setup tasks to run to configure the container.
  uid: The user ID to run the container as.
  gid: The group ID to run the container as.
  perms: A list of permissions to set for the container.
  labels: An attribute set of labels to set for the container. The keys are
  automatically prefixed with &quot;org.opencontainers.image&quot;.
  debug: Whether to include debug tools in the container (coreutils).
  options: Additional options to pass to nix2container.

  Returns:
  An OCI container image (created with nix2container).
  */
</code></pre>
<h4 id="the-standard-image"><a class="header" href="#the-standard-image">The Standard Image</a></h4>
<p>Standard images are minimal and hardened. They only contain required dependencies.</p>
<h5 id="contracts"><a class="header" href="#contracts">Contracts</a></h5>
<p>The following contracts can be consumed:</p>
<pre><code>/bin/entrypoint # always present
/bin/runtime    # always present, drops into the runtime environment
/bin/live       # if livenessProbe was set
/bin/ready      # if readinessProbe was set
</code></pre>
<p>That's it. There is nothing more to see.</p>
<p>All other dependencies are contained in <code>/nix/store/...</code>.</p>
<h4 id="the-debug-image"><a class="header" href="#the-debug-image">The Debug Image</a></h4>
<p>Debug Images wrap the standard images and provide additional debugging packages.</p>
<p>Hence, they are neither minimal, nor hardened because of the debugging packages' added surface.</p>
<h5 id="contracts-1"><a class="header" href="#contracts-1">Contracts</a></h5>
<p>The following contracts can be consumed:</p>
<pre><code>/bin/entrypoint # always present
/bin/runtime    # always present, drops into the runtime environment
/bin/debug      # always present, drops into the debugging environment
/bin/live       # if livenessProbe was set
/bin/ready      # if readinessProbe was set
</code></pre>
<h4 id="how-to-extend"><a class="header" href="#how-to-extend">How to extend?</a></h4>
<p>A Standard or Debug Image doesn't have a package manager available in the environment.</p>
<p>Hence, to extend the image you have two options:</p>
<h5 id="nix-based-extension"><a class="header" href="#nix-based-extension">Nix-based extension</a></h5>
<pre><code class="language-nix">rec {
  upstream = n2c.pullImage {
    imageName = &quot;docker.io/my-upstream-image&quot;;
    imageDigest = &quot;sha256:fffff.....&quot;;
    sha256 = &quot;sha256-ffffff...&quot;;
  };
  modified = n2c.buildImage {
    name = &quot;docker.io/my-modified-image&quot;;
    fromImage = upstream;
    contents = [nixpkgs.bashInteractive];
  };
}
</code></pre>
<h5 id="dockerfile-based-extension"><a class="header" href="#dockerfile-based-extension">Dockerfile-based extension</a></h5>
<pre><code class="language-Dockerfile">FROM alpine AS builder
RUN apk --no-cache curl

FROM docker.io/my-upstream-image
COPY --from=builder /... /

</code></pre>
<p><em>Please refer to the official dockerfile documentation for more details.</em></p>
<h3 id="mkmicrovm"><a class="header" href="#mkmicrovm"><code>mkMicrovm</code></a></h3>
<p>... provides an interface to <code>microvm</code> tasks</p>
<p>This is an integration for <a href="https://github.com/astro/microvm.nix"><code>astro/microvm.nix</code></a>.</p>
<h4 id="usage-example-1"><a class="header" href="#usage-example-1">Usage example</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs.std.lib) ops;
in {
  # microvm &lt;module&gt;
  myhost = ops.mkMicrovm ({ pkgs, lib, ... }: { networking.hostName = &quot;microvms-host&quot;;});
}
</code></pre>
<hr />
<hr />
<h2 id="the-cfg-library"><a class="header" href="#the-cfg-library">The Cfg Library</a></h2>
<p>Standard comes packages with some <a href="https://github.com/nix-community/nixago">Nixago</a> Pebbles for easy
downstream re-use.</p>
<p>Some Pebbles may have a special integration for <code>std</code>.</p>
<p>For example, the <code>conform</code> Pebble can undestand <code>inputs.cells</code>
and add each Cell as a so called &quot;scope&quot; to its
<a href="https://www.conventionalcommits.org/">Conventional Commit</a> configuration.</p>
<hr />
<p>If you're rather looking for Nixago Presets (i.e. pebbles that already have an opinionated default), please refer to the <a href="reference/../../../reference/presets/nixago"><em>nixago presets</em></a>, instead.</p>
<h3 id="adrgen"><a class="header" href="#adrgen"><code>adrgen</code></a></h3>
<p><a href="https://github.com/asiermarques/adrgen"><code>adrgen</code></a> is a great tool to manage Architecture Decision Records.</p>
<hr />
<h4 id="definition"><a class="header" href="#definition">Definition:</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
in {
  data = {};
  output = &quot;adrgen.config.yml&quot;;
  format = &quot;yaml&quot;;
  commands = [{package = inputs.cells.std.packages.adrgen;}];
}
</code></pre>
<h3 id="conform"><a class="header" href="#conform"><code>conform</code></a></h3>
<p><a href="reference/conform.html">Conform</a> your code to policies, e.g. in a pre-commit hook.</p>
<p>This version is wrapped, it can auto-enhance the conventional
commit scopes with your <code>cells</code> as follows:</p>
<pre><code class="language-nix">{ inputs, cell}: let
  inherit (inputs.std) lib;
in {

  default = lib.dev.mkShell {
    /* ... */
    nixago = [
      (lib.cfg.conform {data = {inherit (inputs) cells;};})
    ];
  };
}
</code></pre>
<hr />
<h4 id="definition-1"><a class="header" href="#definition-1">Definition:</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  l = nixpkgs.lib // builtins;
  inherit (inputs) nixpkgs;
in {
  data = {};
  format = &quot;yaml&quot;;
  output = &quot;.conform.yaml&quot;;
  packages = [nixpkgs.conform];
  apply = d: {
    policies =
      []
      ++ (l.optional (d ? commit) {
        type = &quot;commit&quot;;
        spec =
          d.commit
          // l.optionalAttrs (d ? cells) {
            conventional =
              d.commit.conventional
              // {
                scopes =
                  d.commit.conventional.scopes
                  ++ (l.subtractLists l.systems.doubles.all (l.attrNames d.cells));
              };
          };
      })
      ++ (l.optional (d ? license) {
        type = &quot;license&quot;;
        spec = d.license;
      });
  };
}
</code></pre>
<h3 id="editorconfig"><a class="header" href="#editorconfig"><code>editorconfig</code></a></h3>
<p>Most editors understand the <a href="https://github.com/editorconfig/"><code>.editorconfig</code></a> file and autoconfigure themselves accordingly.</p>
<hr />
<h4 id="definition-2"><a class="header" href="#definition-2">Definition:</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  l = nixpkgs.lib // builtins;
  inherit (inputs) nixpkgs;
in {
  data = {};
  output = &quot;.editorconfig&quot;;
  engine = request: let
    inherit (request) data output;
    name = l.baseNameOf output;
    value = {
      globalSection = {root = data.root or true;};
      sections = l.removeAttrs data [&quot;root&quot;];
    };
  in
    nixpkgs.writeText name (l.generators.toINIWithGlobalSection {} value);
  packages = [nixpkgs.editorconfig-checker];
}
</code></pre>
<h3 id="githubsettings"><a class="header" href="#githubsettings"><code>githubsettings</code></a></h3>
<p>Syncs repository settings defined in <code>.github/settings.yml</code> to GitHub, enabling Pull Requests for repository settings.</p>
<p>In order to use this, you also need to install <a href="https://github.com/apps/settings">Github Settings App</a>.
Please see the App's Homepage for the configuration schema.</p>
<hr />
<h4 id="definition-3"><a class="header" href="#definition-3">Definition:</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: {
  data = {};
  output = &quot;.github/settings.yml&quot;;
  format = &quot;yaml&quot;;
  hook.mode = &quot;copy&quot;; # let the Github Settings action pick it up outside of devshell
}
</code></pre>
<h3 id="just"><a class="header" href="#just"><code>just</code></a></h3>
<p><a href="https://github.com/casey/just">Just</a> is a general purpose command runner with syntax inspired by <code>make</code>.</p>
<p>Tasks are configured via an attribute set where the name is the name of the task
(i.e. <code>just &lt;task&gt;</code>) and the value is the task definition (see below for an
example). The generated <code>Justfile</code> should be committed to allow non-Nix users to
on-ramp without needing access to Nix.</p>
<p>Task dependencies (i.e. <code>treefmt</code> below) should be included in <code>packages</code> and
will automatically be picked up in the devshell.</p>
<pre><code class="language-nix">{ inputs, cell }:
let
  inherit (inputs) nixpkgs;
  inherit (inputs.std) lib;
in
{

  default = lib.dev.mkShell {
    /* ... */
    nixago = [
      (lib.cfg.just {
        packages = [ nixpkgs.treefmt ];
        data = {
          tasks = {
            fmt = {
              description = &quot;Formats all changed source files&quot;;
              content = ''
                treefmt $(git diff --name-only --cached)
              '';
            };
          };
        };
      })
    ];
  };
}
</code></pre>
<p>It's also possible to override the interpreter for a task:</p>
<pre><code class="language-nix">{
# ...
  hello = {
    description = &quot;Prints hello world&quot;;
    interpreter = nixpkgs.python3;
    content = ''
      print(&quot;Hello, world!&quot;)
    '';
  };
}
# ...
</code></pre>
<hr />
<h4 id="definition-4"><a class="header" href="#definition-4">Definition:</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
  l = nixpkgs.lib // builtins;
in {
  data = {};
  apply = d: let
    # Transforms interpreter attribute if present
    # nixpkgs.pkgname -&gt; nixpkgs.pkgname + '/bin/&lt;name&gt;'
    getExe = x: &quot;${l.getBin x}/bin/${x.meta.mainProgram or (l.getName x)}&quot;;
    final =
      d
      // {
        tasks =
          l.mapAttrs
          (n: v:
            v // l.optionalAttrs (v ? interpreter) {interpreter = getExe v.interpreter;})
          d.tasks;
      };
  in {
    data = final; # CUE expects structure to be wrapped with &quot;data&quot;
  };
  format = &quot;text&quot;;
  output = &quot;Justfile&quot;;
  packages = [nixpkgs.just];
  hook = {
    mode = &quot;copy&quot;;
  };
  engine = inputs.nixago.engines.cue {
    files = [./just.cue];
    flags = {
      expression = &quot;rendered&quot;;
      out = &quot;text&quot;;
    };
    postHook = ''
      ${l.getExe nixpkgs.just} --unstable --fmt -f $out
    '';
  };
}
</code></pre>
<h3 id="lefthook"><a class="header" href="#lefthook"><code>lefthook</code></a></h3>
<p><a href="https://github.com/evilmartians/lefthook">Lefthook</a> is a fast (parallel execution) and elegant git hook manager.</p>
<hr />
<h4 id="definition-5"><a class="header" href="#definition-5">Definition:</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
  l = nixpkgs.lib // builtins;
in {
  data = {};
  format = &quot;yaml&quot;;
  output = &quot;lefthook.yml&quot;;
  packages = [nixpkgs.lefthook];
  hook.extra = d: let
    # Add an extra hook for adding required stages whenever the file changes
    skip_attrs = [
      &quot;colors&quot;
      &quot;extends&quot;
      &quot;skip_output&quot;
      &quot;source_dir&quot;
      &quot;source_dir_local&quot;
    ];
    stages = l.attrNames (l.removeAttrs d skip_attrs);
    stagesStr = l.concatStringsSep &quot; &quot; stages;
  in ''
    # Install configured hooks
    for stage in ${stagesStr}; do
      ${l.getExe nixpkgs.lefthook} add -f &quot;$stage&quot;
    done
  '';
}
</code></pre>
<h3 id="mdbook"><a class="header" href="#mdbook"><code>mdbook</code></a></h3>
<p>Write clean docs for humans with <a href="https://github.com/rust-lang/mdBook"><code>mdbook</code></a>.</p>
<p>This version comes preset with this gem to make any
Solution Architect extra happy: <a href="https://github.com/joelcourtney/mdbook-kroki-preprocessor"><code>mdbook-kroki-preprocessor</code></a></p>
<hr />
<h4 id="definition-6"><a class="header" href="#definition-6">Definition:</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
in {
  data = {};
  output = &quot;book.toml&quot;;
  format = &quot;toml&quot;;
  hook.extra = d: let
    sentinel = &quot;nixago-auto-created: mdbook-build-folder&quot;;
    file = &quot;.gitignore&quot;;
    str = ''
      # ${sentinel}
      ${d.build.build-dir or &quot;book&quot;}/**
    '';
  in ''
    # Configure gitignore
    create() {
      echo -n &quot;${str}&quot; &gt; &quot;${file}&quot;
    }
    append() {
      echo -en &quot;\n${str}&quot; &gt;&gt; &quot;${file}&quot;
    }
    if ! test -f &quot;${file}&quot;; then
      create
    elif ! grep -qF &quot;${sentinel}&quot; &quot;${file}&quot;; then
      append
    fi
  '';
  commands = [{package = nixpkgs.mdbook;}];
}
</code></pre>
<h3 id="treefmt"><a class="header" href="#treefmt"><code>treefmt</code></a></h3>
<p>A <a href="https://github.com/numtide/treefmt">code-tree formatter</a> to fromat the entire code tree extremly fast (in parallel and with a smart cache).</p>
<hr />
<h4 id="definition-7"><a class="header" href="#definition-7">Definition:</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
in {
  data = {};
  output = &quot;treefmt.toml&quot;;
  format = &quot;toml&quot;;
  commands = [{package = nixpkgs.treefmt;}];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="sidetoc"><nav class="pagetoc"></nav></div>
<h1 id="the-std-cell"><a class="header" href="#the-std-cell">The <code>std</code> Cell</a></h1>
<p>... is the only cell in <code>divnix/std</code> and provides only very limited functionality.</p>
<ul>
<li>It contains the TUI, in <code>./cli</code>.</li>
<li>It contains a <code>devshellProfile</code> in <code>./devshellProfiles</code>.</li>
<li>It contains a growing number of second level library functions in <code>./lib</code>.</li>
<li>Packages that are used in std devshells are proxied in <code>./packages</code>.</li>
</ul>
<p>That's it.</p>
<hr />
<h2 id="the-std-tui--cli"><a class="header" href="#the-std-tui--cli">The <code>std</code> TUI / CLI</a></h2>
<h4 id="usage-1"><a class="header" href="#usage-1">Usage</a></h4>
<ul>
<li>Enter a <code>std</code>ized repository.</li>
<li>Enter it's devshell (which must include <code>//std/devshellProfiles:default</code>)</li>
<li>Run <code>std</code>.</li>
</ul>
<p>It will show you around interactively and lead you very quickly to what you're looking for.</p>
<p>It's self-documented on it's legend.</p>
<hr />
<h2 id="error-message-functions"><a class="header" href="#error-message-functions">Error Message Functions</a></h2>
<p>This Cell Block comprises several error message functions that can be used in different situations.</p>
<h3 id="removeby"><a class="header" href="#removeby"><code>removeBy</code></a></h3>
<pre><code class="language-nix">{inputs}: time: body: let
  l = inputs.nixpkgs.lib // builtins;
  ansi = import ./ansi.nix;
  pad = s: let
    n = 17;
    prefix = l.concatStringsSep &quot;&quot; (l.genList (_: &quot; &quot;) (n - (l.stringLength s)));
  in
    prefix + s;
  indent = s: let
    n = 5;
    prefix = l.concatStringsSep &quot;&quot; (l.genList (_: &quot; &quot;) n);
    lines = l.splitString &quot;\n&quot; s;
  in
    &quot;  📝 │ &quot; + (l.concatStringsSep &quot;\n${prefix}│ &quot; lines);
  warn = let
    apply =
      l.replaceStrings
      (map (key: &quot;{${key}}&quot;) (l.attrNames ansi))
      (l.attrValues ansi);
  in
    msg:
      l.trace (apply &quot;🔥 {bold}{196}Standard Deprecation Notices - {220}run `std check' to show!{reset}&quot;)
      l.traceVerbose (apply &quot;\n{202}${msg}{reset}&quot;);
in
  warn ''
    ─────┬─────────────────────────────────────────────────────────────────────────
      💪 │ {bold}Action Required !{un-bold}
    ─────┼─────────────────────────────────────────────────────────────────────────
    {italic}${indent body}{un-italic}
    ─────┼─────────────────────────────────────────────────────────────────────────
      📅 │ {bold}Scheduled Removal: ${pad time}{un-bold}
    ─────┴─────────────────────────────────────────────────────────────────────────
  ''
</code></pre>
<h3 id="requireinput"><a class="header" href="#requireinput"><code>requireInput</code></a></h3>
<pre><code class="language-nix">{inputs}: input: url: target: let
  l = inputs.nixpkgs.lib // builtins;

  # other than `divnix/blank`
  isBlank = input: inputs.${input}.sourceInfo.narHash == &quot;sha256-O8/MWsPBGhhyPoPLHZAuoZiiHo9q6FLlEeIDEXuj6T4=&quot;;

  ansi = import ./ansi.nix;

  pad = n: s: let
    prefix = l.concatStringsSep &quot;&quot; (l.genList (_: &quot; &quot;) n);
  in
    prefix + s;

  indent = s: let
    n = 5;
    prefix = l.concatStringsSep &quot;&quot; (l.genList (_: &quot; &quot;) n);
    lines = l.splitString &quot;\n&quot; s;
  in
    l.concatStringsSep &quot;\n${prefix}│ &quot; lines;

  warn = let
    apply =
      l.replaceStrings
      (map (key: &quot;{${key}}&quot;) (l.attrNames ansi))
      (l.attrValues ansi);
  in
    msg: l.trace (apply &quot;🚀 {bold}{200}Standard Input Overloading{reset}${msg}&quot;) &quot;&quot;;

  body = ''
    In order to use ${target}, add to {bold}flake.nix{un-bold}:

      inputs.std.inputs.${input}.url =
        &quot;${url}&quot;;
  '';

  inputs' = let
    names = l.attrNames (l.removeAttrs inputs [&quot;self&quot; &quot;cells&quot; &quot;blank&quot;]);
    nameLengths = map l.stringLength names;
    maxNameLength =
      l.foldl'
      (max: v:
        if v &gt; max
        then v
        else max)
      0
      nameLengths;

    lines =
      l.map (
        name: &quot;- ${name}${
          if isBlank name
          then pad (maxNameLength - (l.stringLength name)) &quot; | blanked out&quot;
          else &quot;&quot;
        }&quot;
      )
      names;
  in
    &quot;Declared Inputs:\n&quot; + (l.concatStringsSep &quot;\n&quot; lines);
in
  assert l.assertMsg (! (isBlank input)) (warn ''

    ─────┬─────────────────────────────────────────────────────────────────────────
      🏗️  │ {bold}Input Overloading for ${target}{un-bold}
    ─────┼─────────────────────────────────────────────────────────────────────────
      📝 │ {italic}${indent body}{un-italic}
    ─────┼─────────────────────────────────────────────────────────────────────────
      🙋 │ ${indent inputs'}
    ─────┴─────────────────────────────────────────────────────────────────────────
  ''); inputs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p><strong>Cell</strong></p>
<p>: A Cell is the folder name of the first level under <code>${cellsFrom}</code>. They represent a coherent semantic collection of functionality.</p>
<p><strong>Cell Block</strong></p>
<p>: A Cell Block is the specific <em>named type</em> of a Standard (and hence: Flake) output.</p>
<p><strong>Block Type</strong></p>
<p>: A Block Type is the unnamed generic type of a Cell Block and may or may not implement Block Type Actions.</p>
<p><strong>Target</strong></p>
<p>: A Target is the actual output of a Cell Block. If there is only one intended output, it is called <code>default</code> by convention.</p>
<p><strong>Action</strong></p>
<p>: An Action is a runnable procedure implemented on the generic Block Type type. These are abstract procedures that are valuable in any concrete Cell Block of such Block Type.</p>
<p><strong>The Registry</strong></p>
<p>: The Registry, in the context of Standard and if it doesn't refer to a well-known external concept, means the <code>.#__std</code> flake output. This Registry holds different Registers that serve different discovery purposes. For example, the CLI can discover relevant metadata or a CI can discover desired pipeline targets.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/mermaid.min.js"></script>
        <script src="theme/mermaid-init.js"></script>
        <script src="theme/pagetoc.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
